// Package servicefabric implements the Azure ARM Servicefabric service API version 6.0.0.1.
//
// Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
package servicefabric

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/validation"
	"github.com/satori/go.uuid"
	"net/http"
)

const (
	// DefaultBaseURI is the default URI used for the service Servicefabric
	DefaultBaseURI = "http://localhost:19080"
)

// BaseClient is the base client for Servicefabric.
type BaseClient struct {
	autorest.Client
	BaseURI string
}

// New creates an instance of the BaseClient client.
func New() BaseClient {
	return NewWithBaseURI(DefaultBaseURI)
}

// NewWithBaseURI creates an instance of the BaseClient client.
func NewWithBaseURI(baseURI string) BaseClient {
	return BaseClient{
		Client:  autorest.NewClientWithUserAgent(UserAgent()),
		BaseURI: baseURI,
	}
}

// CancelOperation the following is a list of APIs that start fault operations that may be cancelled using
// CancelOperation -
// - StartDataLoss
// - StartQuorumLoss
// - StartPartitionRestart
// - StartNodeTransition
//
// If force is false, then the specified user-induced operation will be gracefully stopped and cleaned up.  If force is
// true, the command will be aborted, and some internal state
// may be left behind.  Specifying force as true should be used with care.  Calling this API with force set to true is
// not allowed until this API has already
// been called on the same test command with force set to false first, or unless the test command already has an
// OperationState of OperationState.RollingBack.
// Clarification: OperationState.RollingBack means that the system will/is be cleaning up internal system state caused
// by executing the command.  It will not restore data if the
// test command was to cause data loss.  For example, if you call StartDataLoss then call this API, the system will
// only clean up internal state from running the command.
// It will not restore the target partition's data, if the command progressed far enough to cause data loss.
//
// Important note:  if this API is invoked with force==true, internal state may be left behind.
//
// operationID is a GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
// force is indicates whether to gracefully rollback and clean up internal system state modified by executing the
// user-induced operation. timeout is the server timeout for performing the operation in seconds. This specifies the
// time duration that the client is willing to wait for the requested operation to complete. The default value for this
// parameter is 60 seconds.
func (client BaseClient) CancelOperation(ctx context.Context, operationID uuid.UUID, force bool, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "CancelOperation")
	}

	req, err := client.CancelOperationPreparer(ctx, operationID, force, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CancelOperation", nil, "Failure preparing request")
		return
	}

	resp, err := client.CancelOperationSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CancelOperation", resp, "Failure sending request")
		return
	}

	result, err = client.CancelOperationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CancelOperation", resp, "Failure responding to request")
	}

	return
}

// CancelOperationPreparer prepares the CancelOperation request.
func (client BaseClient) CancelOperationPreparer(ctx context.Context, operationID uuid.UUID, force bool, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"Force":       autorest.Encode("query", force),
		"OperationId": autorest.Encode("query", operationID),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/Faults/$/Cancel"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CancelOperationSender sends the CancelOperation request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CancelOperationSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CancelOperationResponder handles the response to the CancelOperation request. The method always
// closes the http.Response Body.
func (client BaseClient) CancelOperationResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// CancelRepairTask this API supports the Service Fabric platform; it is not meant to be used directly from your code.
//
// repairTaskCancelDescription is describes the repair task to be cancelled.
func (client BaseClient) CancelRepairTask(ctx context.Context, repairTaskCancelDescription RepairTaskCancelDescription) (result RepairTaskUpdateInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: repairTaskCancelDescription,
			Constraints: []validation.Constraint{{Target: "repairTaskCancelDescription.TaskID", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "CancelRepairTask")
	}

	req, err := client.CancelRepairTaskPreparer(ctx, repairTaskCancelDescription)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CancelRepairTask", nil, "Failure preparing request")
		return
	}

	resp, err := client.CancelRepairTaskSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CancelRepairTask", resp, "Failure sending request")
		return
	}

	result, err = client.CancelRepairTaskResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CancelRepairTask", resp, "Failure responding to request")
	}

	return
}

// CancelRepairTaskPreparer prepares the CancelRepairTask request.
func (client BaseClient) CancelRepairTaskPreparer(ctx context.Context, repairTaskCancelDescription RepairTaskCancelDescription) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/CancelRepairTask"),
		autorest.WithJSON(repairTaskCancelDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CancelRepairTaskSender sends the CancelRepairTask request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CancelRepairTaskSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CancelRepairTaskResponder handles the response to the CancelRepairTask request. The method always
// closes the http.Response Body.
func (client BaseClient) CancelRepairTaskResponder(resp *http.Response) (result RepairTaskUpdateInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CopyImageStoreContent copies the image store content from the source image store relative path to the destination
// image store relative path.
//
// imageStoreCopyDescription is describes the copy description for the image store. timeout is the server timeout for
// performing the operation in seconds. This specifies the time duration that the client is willing to wait for the
// requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) CopyImageStoreContent(ctx context.Context, imageStoreCopyDescription ImageStoreCopyDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: imageStoreCopyDescription,
			Constraints: []validation.Constraint{{Target: "imageStoreCopyDescription.RemoteSource", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "imageStoreCopyDescription.RemoteDestination", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "CopyImageStoreContent")
	}

	req, err := client.CopyImageStoreContentPreparer(ctx, imageStoreCopyDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CopyImageStoreContent", nil, "Failure preparing request")
		return
	}

	resp, err := client.CopyImageStoreContentSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CopyImageStoreContent", resp, "Failure sending request")
		return
	}

	result, err = client.CopyImageStoreContentResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CopyImageStoreContent", resp, "Failure responding to request")
	}

	return
}

// CopyImageStoreContentPreparer prepares the CopyImageStoreContent request.
func (client BaseClient) CopyImageStoreContentPreparer(ctx context.Context, imageStoreCopyDescription ImageStoreCopyDescription, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/ImageStore/$/Copy"),
		autorest.WithJSON(imageStoreCopyDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CopyImageStoreContentSender sends the CopyImageStoreContent request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CopyImageStoreContentSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CopyImageStoreContentResponder handles the response to the CopyImageStoreContent request. The method always
// closes the http.Response Body.
func (client BaseClient) CopyImageStoreContentResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// CreateApplication creates a Service Fabric application using the specified description.
//
// applicationDescription is description for creating an application. timeout is the server timeout for performing the
// operation in seconds. This specifies the time duration that the client is willing to wait for the requested
// operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) CreateApplication(ctx context.Context, applicationDescription ApplicationDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: applicationDescription,
			Constraints: []validation.Constraint{{Target: "applicationDescription.Name", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "applicationDescription.TypeName", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "applicationDescription.TypeVersion", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "applicationDescription.ApplicationCapacity", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "applicationDescription.ApplicationCapacity.MinimumNodes", Name: validation.Null, Rule: false,
						Chain: []validation.Constraint{{Target: "applicationDescription.ApplicationCapacity.MinimumNodes", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil}}},
						{Target: "applicationDescription.ApplicationCapacity.MaximumNodes", Name: validation.Null, Rule: false,
							Chain: []validation.Constraint{{Target: "applicationDescription.ApplicationCapacity.MaximumNodes", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil}}},
					}}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "CreateApplication")
	}

	req, err := client.CreateApplicationPreparer(ctx, applicationDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateApplication", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateApplicationSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateApplication", resp, "Failure sending request")
		return
	}

	result, err = client.CreateApplicationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateApplication", resp, "Failure responding to request")
	}

	return
}

// CreateApplicationPreparer prepares the CreateApplication request.
func (client BaseClient) CreateApplicationPreparer(ctx context.Context, applicationDescription ApplicationDescription, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/Applications/$/Create"),
		autorest.WithJSON(applicationDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateApplicationSender sends the CreateApplication request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CreateApplicationSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateApplicationResponder handles the response to the CreateApplication request. The method always
// closes the http.Response Body.
func (client BaseClient) CreateApplicationResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByClosing())
	result.Response = resp
	return
}

// CreateComposeDeployment creates a Service Fabric compose deployment.
//
// createComposeDeploymentDescription is describes the compose deployment that needs to be created. timeout is the
// server timeout for performing the operation in seconds. This specifies the time duration that the client is willing
// to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) CreateComposeDeployment(ctx context.Context, createComposeDeploymentDescription CreateComposeDeploymentDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: createComposeDeploymentDescription,
			Constraints: []validation.Constraint{{Target: "createComposeDeploymentDescription.DeploymentName", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "createComposeDeploymentDescription.ComposeFileContent", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "CreateComposeDeployment")
	}

	req, err := client.CreateComposeDeploymentPreparer(ctx, createComposeDeploymentDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateComposeDeployment", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateComposeDeploymentSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateComposeDeployment", resp, "Failure sending request")
		return
	}

	result, err = client.CreateComposeDeploymentResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateComposeDeployment", resp, "Failure responding to request")
	}

	return
}

// CreateComposeDeploymentPreparer prepares the CreateComposeDeployment request.
func (client BaseClient) CreateComposeDeploymentPreparer(ctx context.Context, createComposeDeploymentDescription CreateComposeDeploymentDescription, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/ComposeDeployments/$/Create"),
		autorest.WithJSON(createComposeDeploymentDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateComposeDeploymentSender sends the CreateComposeDeployment request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CreateComposeDeploymentSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateComposeDeploymentResponder handles the response to the CreateComposeDeployment request. The method always
// closes the http.Response Body.
func (client BaseClient) CreateComposeDeploymentResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// CreateName creates the specified Service Fabric name.
//
// nameDescription is describes the Service Fabric name to be created. timeout is the server timeout for performing the
// operation in seconds. This specifies the time duration that the client is willing to wait for the requested
// operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) CreateName(ctx context.Context, nameDescription NameDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: nameDescription,
			Constraints: []validation.Constraint{{Target: "nameDescription.Name", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "CreateName")
	}

	req, err := client.CreateNamePreparer(ctx, nameDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateName", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateNameSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateName", resp, "Failure sending request")
		return
	}

	result, err = client.CreateNameResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateName", resp, "Failure responding to request")
	}

	return
}

// CreateNamePreparer prepares the CreateName request.
func (client BaseClient) CreateNamePreparer(ctx context.Context, nameDescription NameDescription, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/Names/$/Create"),
		autorest.WithJSON(nameDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateNameSender sends the CreateName request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CreateNameSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateNameResponder handles the response to the CreateName request. The method always
// closes the http.Response Body.
func (client BaseClient) CreateNameResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByClosing())
	result.Response = resp
	return
}

// CreateRepairTask for clusters that have the Repair Manager Service configured,
// this API provides a way to create repair tasks that run automatically or manually.
// For repair tasks that run automatically, an appropriate repair executor
// must be running for each repair action to run automatically.
// These are currently only available in specially-configured Azure Cloud Services.
//
// To create a manual repair task, provide the set of impacted node names and the
// expected impact. When the state of the created repair task changes to approved,
// you can safely perform repair actions on those nodes.
//
// This API supports the Service Fabric platform; it is not meant to be used directly from your code.
//
// repairTask is describes the repair task to be created or updated.
func (client BaseClient) CreateRepairTask(ctx context.Context, repairTask RepairTask) (result RepairTaskUpdateInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: repairTask,
			Constraints: []validation.Constraint{{Target: "repairTask.TaskID", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "repairTask.Action", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "CreateRepairTask")
	}

	req, err := client.CreateRepairTaskPreparer(ctx, repairTask)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateRepairTask", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateRepairTaskSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateRepairTask", resp, "Failure sending request")
		return
	}

	result, err = client.CreateRepairTaskResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateRepairTask", resp, "Failure responding to request")
	}

	return
}

// CreateRepairTaskPreparer prepares the CreateRepairTask request.
func (client BaseClient) CreateRepairTaskPreparer(ctx context.Context, repairTask RepairTask) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/CreateRepairTask"),
		autorest.WithJSON(repairTask),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateRepairTaskSender sends the CreateRepairTask request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CreateRepairTaskSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateRepairTaskResponder handles the response to the CreateRepairTask request. The method always
// closes the http.Response Body.
func (client BaseClient) CreateRepairTaskResponder(resp *http.Response) (result RepairTaskUpdateInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateService creates the specified service.
//
// applicationID is the identity of the application. This is typically the full name of the application without the
// 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For
// example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+
// and "myapp/app1" in previous versions. serviceDescription is the information necessary to create a service. timeout
// is the server timeout for performing the operation in seconds. This specifies the time duration that the client is
// willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) CreateService(ctx context.Context, applicationID string, serviceDescription BasicServiceDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: serviceDescription,
			Constraints: []validation.Constraint{{Target: "serviceDescription.ServiceName", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "serviceDescription.ServiceTypeName", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "serviceDescription.PartitionDescription", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "CreateService")
	}

	req, err := client.CreateServicePreparer(ctx, applicationID, serviceDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateService", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateServiceSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateService", resp, "Failure sending request")
		return
	}

	result, err = client.CreateServiceResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateService", resp, "Failure responding to request")
	}

	return
}

// CreateServicePreparer prepares the CreateService request.
func (client BaseClient) CreateServicePreparer(ctx context.Context, applicationID string, serviceDescription BasicServiceDescription, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/GetServices/$/Create", pathParameters),
		autorest.WithJSON(serviceDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateServiceSender sends the CreateService request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CreateServiceSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateServiceResponder handles the response to the CreateService request. The method always
// closes the http.Response Body.
func (client BaseClient) CreateServiceResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// CreateServiceFromTemplate creates a Service Fabric service from the service template defined in the application
// manifest.
//
// applicationID is the identity of the application. This is typically the full name of the application without the
// 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For
// example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+
// and "myapp/app1" in previous versions. serviceFromTemplateDescription is describes the service that needs to be
// created from the template defined in the application manifest. timeout is the server timeout for performing the
// operation in seconds. This specifies the time duration that the client is willing to wait for the requested
// operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) CreateServiceFromTemplate(ctx context.Context, applicationID string, serviceFromTemplateDescription ServiceFromTemplateDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: serviceFromTemplateDescription,
			Constraints: []validation.Constraint{{Target: "serviceFromTemplateDescription.ApplicationName", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "serviceFromTemplateDescription.ServiceName", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "serviceFromTemplateDescription.ServiceTypeName", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "CreateServiceFromTemplate")
	}

	req, err := client.CreateServiceFromTemplatePreparer(ctx, applicationID, serviceFromTemplateDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateServiceFromTemplate", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateServiceFromTemplateSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateServiceFromTemplate", resp, "Failure sending request")
		return
	}

	result, err = client.CreateServiceFromTemplateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateServiceFromTemplate", resp, "Failure responding to request")
	}

	return
}

// CreateServiceFromTemplatePreparer prepares the CreateServiceFromTemplate request.
func (client BaseClient) CreateServiceFromTemplatePreparer(ctx context.Context, applicationID string, serviceFromTemplateDescription ServiceFromTemplateDescription, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/GetServices/$/CreateFromTemplate", pathParameters),
		autorest.WithJSON(serviceFromTemplateDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateServiceFromTemplateSender sends the CreateServiceFromTemplate request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CreateServiceFromTemplateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateServiceFromTemplateResponder handles the response to the CreateServiceFromTemplate request. The method always
// closes the http.Response Body.
func (client BaseClient) CreateServiceFromTemplateResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteApplication deletes an existing Service Fabric application. An application must be created before it can be
// deleted. Deleting an application will delete all services that are part of that application. By default Service
// Fabric will try to close service replicas in a graceful manner and then delete the service. However if service is
// having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the
// optional ForceRemove flag to skip the graceful close sequence and forcefully delete the application and all of the
// its services.
//
// applicationID is the identity of the application. This is typically the full name of the application without the
// 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For
// example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+
// and "myapp/app1" in previous versions. forceRemove is remove a Service Fabric application or service forcefully
// without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application
// or service for which delete is timing out due to issues in the service code that prevents graceful close of
// replicas. timeout is the server timeout for performing the operation in seconds. This specifies the time duration
// that the client is willing to wait for the requested operation to complete. The default value for this parameter is
// 60 seconds.
func (client BaseClient) DeleteApplication(ctx context.Context, applicationID string, forceRemove *bool, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "DeleteApplication")
	}

	req, err := client.DeleteApplicationPreparer(ctx, applicationID, forceRemove, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteApplication", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteApplicationSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteApplication", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteApplicationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteApplication", resp, "Failure responding to request")
	}

	return
}

// DeleteApplicationPreparer prepares the DeleteApplication request.
func (client BaseClient) DeleteApplicationPreparer(ctx context.Context, applicationID string, forceRemove *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if forceRemove != nil {
		queryParameters["ForceRemove"] = autorest.Encode("query", *forceRemove)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/Delete", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteApplicationSender sends the DeleteApplication request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteApplicationSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteApplicationResponder handles the response to the DeleteApplication request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteApplicationResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteImageStoreContent deletes existing image store content being found within the given image store relative path.
// This can be used to delete uploaded application packages once they are provisioned.
//
// contentPath is relative path to file or folder in the image store from its root. timeout is the server timeout for
// performing the operation in seconds. This specifies the time duration that the client is willing to wait for the
// requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) DeleteImageStoreContent(ctx context.Context, contentPath string, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "DeleteImageStoreContent")
	}

	req, err := client.DeleteImageStoreContentPreparer(ctx, contentPath, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteImageStoreContent", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteImageStoreContentSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteImageStoreContent", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteImageStoreContentResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteImageStoreContent", resp, "Failure responding to request")
	}

	return
}

// DeleteImageStoreContentPreparer prepares the DeleteImageStoreContent request.
func (client BaseClient) DeleteImageStoreContentPreparer(ctx context.Context, contentPath string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"contentPath": autorest.Encode("path", contentPath),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ImageStore/{contentPath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteImageStoreContentSender sends the DeleteImageStoreContent request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteImageStoreContentSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteImageStoreContentResponder handles the response to the DeleteImageStoreContent request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteImageStoreContentResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteName deletes the specified Service Fabric name. A name must be created before it can be deleted. Deleting a
// name with child properties will fail.
//
// nameID is the Service Fabric name, without the 'fabric:' URI scheme. timeout is the server timeout for performing
// the operation in seconds. This specifies the time duration that the client is willing to wait for the requested
// operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) DeleteName(ctx context.Context, nameID string, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "DeleteName")
	}

	req, err := client.DeleteNamePreparer(ctx, nameID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteName", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteNameSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteName", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteNameResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteName", resp, "Failure responding to request")
	}

	return
}

// DeleteNamePreparer prepares the DeleteName request.
func (client BaseClient) DeleteNamePreparer(ctx context.Context, nameID string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nameId": nameID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Names/{nameId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteNameSender sends the DeleteName request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteNameSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteNameResponder handles the response to the DeleteName request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteNameResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteProperty deletes the specified Service Fabric property under a given name. A property must be created before
// it can be deleted.
//
// nameID is the Service Fabric name, without the 'fabric:' URI scheme. propertyName is specifies the name of the
// property to get. timeout is the server timeout for performing the operation in seconds. This specifies the time
// duration that the client is willing to wait for the requested operation to complete. The default value for this
// parameter is 60 seconds.
func (client BaseClient) DeleteProperty(ctx context.Context, nameID string, propertyName string, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "DeleteProperty")
	}

	req, err := client.DeletePropertyPreparer(ctx, nameID, propertyName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteProperty", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeletePropertySender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteProperty", resp, "Failure sending request")
		return
	}

	result, err = client.DeletePropertyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteProperty", resp, "Failure responding to request")
	}

	return
}

// DeletePropertyPreparer prepares the DeleteProperty request.
func (client BaseClient) DeletePropertyPreparer(ctx context.Context, nameID string, propertyName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nameId": nameID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version":  APIVersion,
		"PropertyName": autorest.Encode("query", propertyName),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Names/{nameId}/$/GetProperty", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeletePropertySender sends the DeleteProperty request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeletePropertySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeletePropertyResponder handles the response to the DeleteProperty request. The method always
// closes the http.Response Body.
func (client BaseClient) DeletePropertyResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteRepairTask this API supports the Service Fabric platform; it is not meant to be used directly from your code.
//
// repairTaskDeleteDescription is describes the repair task to be deleted.
func (client BaseClient) DeleteRepairTask(ctx context.Context, repairTaskDeleteDescription RepairTaskDeleteDescription) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: repairTaskDeleteDescription,
			Constraints: []validation.Constraint{{Target: "repairTaskDeleteDescription.TaskID", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "DeleteRepairTask")
	}

	req, err := client.DeleteRepairTaskPreparer(ctx, repairTaskDeleteDescription)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteRepairTask", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteRepairTaskSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteRepairTask", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteRepairTaskResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteRepairTask", resp, "Failure responding to request")
	}

	return
}

// DeleteRepairTaskPreparer prepares the DeleteRepairTask request.
func (client BaseClient) DeleteRepairTaskPreparer(ctx context.Context, repairTaskDeleteDescription RepairTaskDeleteDescription) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/DeleteRepairTask"),
		autorest.WithJSON(repairTaskDeleteDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteRepairTaskSender sends the DeleteRepairTask request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteRepairTaskSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteRepairTaskResponder handles the response to the DeleteRepairTask request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteRepairTaskResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteService deletes an existing Service Fabric service. A service must be created before it can be deleted. By
// default Service Fabric will try to close service replicas in a graceful manner and then delete the service. However
// if service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck.
// Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the service.
//
// serviceID is the identity of the service. This is typically the full name of the service without the 'fabric:' URI
// scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the
// service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and
// "myapp/app1/svc1" in previous versions. forceRemove is remove a Service Fabric application or service forcefully
// without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application
// or service for which delete is timing out due to issues in the service code that prevents graceful close of
// replicas. timeout is the server timeout for performing the operation in seconds. This specifies the time duration
// that the client is willing to wait for the requested operation to complete. The default value for this parameter is
// 60 seconds.
func (client BaseClient) DeleteService(ctx context.Context, serviceID string, forceRemove *bool, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "DeleteService")
	}

	req, err := client.DeleteServicePreparer(ctx, serviceID, forceRemove, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteService", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteServiceSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteService", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteServiceResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteService", resp, "Failure responding to request")
	}

	return
}

// DeleteServicePreparer prepares the DeleteService request.
func (client BaseClient) DeleteServicePreparer(ctx context.Context, serviceID string, forceRemove *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"serviceId": serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if forceRemove != nil {
		queryParameters["ForceRemove"] = autorest.Encode("query", *forceRemove)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Services/{serviceId}/$/Delete", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteServiceSender sends the DeleteService request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteServiceSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteServiceResponder handles the response to the DeleteService request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteServiceResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeployedServicePackageToNode downloads packages associated with specified service manifest to image cache on
// specified node.
//
// nodeName is the name of the node. deployServicePackageToNodeDescription is describes information for deploying a
// service package to a Service Fabric node. timeout is the server timeout for performing the operation in seconds.
// This specifies the time duration that the client is willing to wait for the requested operation to complete. The
// default value for this parameter is 60 seconds.
func (client BaseClient) DeployedServicePackageToNode(ctx context.Context, nodeName string, deployServicePackageToNodeDescription DeployServicePackageToNodeDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: deployServicePackageToNodeDescription,
			Constraints: []validation.Constraint{{Target: "deployServicePackageToNodeDescription.ServiceManifestName", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "deployServicePackageToNodeDescription.ApplicationTypeName", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "deployServicePackageToNodeDescription.ApplicationTypeVersion", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "deployServicePackageToNodeDescription.NodeName", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "DeployedServicePackageToNode")
	}

	req, err := client.DeployedServicePackageToNodePreparer(ctx, nodeName, deployServicePackageToNodeDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeployedServicePackageToNode", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeployedServicePackageToNodeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeployedServicePackageToNode", resp, "Failure sending request")
		return
	}

	result, err = client.DeployedServicePackageToNodeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeployedServicePackageToNode", resp, "Failure responding to request")
	}

	return
}

// DeployedServicePackageToNodePreparer prepares the DeployedServicePackageToNode request.
func (client BaseClient) DeployedServicePackageToNodePreparer(ctx context.Context, nodeName string, deployServicePackageToNodeDescription DeployServicePackageToNodeDescription, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/DeployServicePackage", pathParameters),
		autorest.WithJSON(deployServicePackageToNodeDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeployedServicePackageToNodeSender sends the DeployedServicePackageToNode request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeployedServicePackageToNodeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeployedServicePackageToNodeResponder handles the response to the DeployedServicePackageToNode request. The method always
// closes the http.Response Body.
func (client BaseClient) DeployedServicePackageToNodeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DisableNode deactivate a Service Fabric cluster node with the specified deactivation intent. Once the deactivation
// is in progress, the deactivation intent can be increased, but not decreased (for example, a node which is was
// deactivated with the Pause intent can be deactivated further with Restart, but not the other way around. Nodes may
// be reactivated using the Activate a node operation any time after they are deactivated. If the deactivation is not
// complete this will cancel the deactivation. A node which goes down and comes back up while deactivated will still
// need to be reactivated before services will be placed on that node.
//
// nodeName is the name of the node. deactivationIntentDescription is describes the intent or reason for deactivating
// the node. timeout is the server timeout for performing the operation in seconds. This specifies the time duration
// that the client is willing to wait for the requested operation to complete. The default value for this parameter is
// 60 seconds.
func (client BaseClient) DisableNode(ctx context.Context, nodeName string, deactivationIntentDescription DeactivationIntentDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "DisableNode")
	}

	req, err := client.DisableNodePreparer(ctx, nodeName, deactivationIntentDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DisableNode", nil, "Failure preparing request")
		return
	}

	resp, err := client.DisableNodeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DisableNode", resp, "Failure sending request")
		return
	}

	result, err = client.DisableNodeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DisableNode", resp, "Failure responding to request")
	}

	return
}

// DisableNodePreparer prepares the DisableNode request.
func (client BaseClient) DisableNodePreparer(ctx context.Context, nodeName string, deactivationIntentDescription DeactivationIntentDescription, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/Deactivate", pathParameters),
		autorest.WithJSON(deactivationIntentDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DisableNodeSender sends the DisableNode request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DisableNodeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DisableNodeResponder handles the response to the DisableNode request. The method always
// closes the http.Response Body.
func (client BaseClient) DisableNodeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// EnableNode activates a Service Fabric cluster node which is currently deactivated. Once activated, the node will
// again become a viable target for placing new replicas, and any deactivated replicas remaining on the node will be
// reactivated.
//
// nodeName is the name of the node. timeout is the server timeout for performing the operation in seconds. This
// specifies the time duration that the client is willing to wait for the requested operation to complete. The default
// value for this parameter is 60 seconds.
func (client BaseClient) EnableNode(ctx context.Context, nodeName string, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "EnableNode")
	}

	req, err := client.EnableNodePreparer(ctx, nodeName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "EnableNode", nil, "Failure preparing request")
		return
	}

	resp, err := client.EnableNodeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "EnableNode", resp, "Failure sending request")
		return
	}

	result, err = client.EnableNodeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "EnableNode", resp, "Failure responding to request")
	}

	return
}

// EnableNodePreparer prepares the EnableNode request.
func (client BaseClient) EnableNodePreparer(ctx context.Context, nodeName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/Activate", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// EnableNodeSender sends the EnableNode request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) EnableNodeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// EnableNodeResponder handles the response to the EnableNode request. The method always
// closes the http.Response Body.
func (client BaseClient) EnableNodeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ForceApproveRepairTask this API supports the Service Fabric platform; it is not meant to be used directly from your
// code.
//
// repairTaskApproveDescription is describes the repair task to be approved.
func (client BaseClient) ForceApproveRepairTask(ctx context.Context, repairTaskApproveDescription RepairTaskApproveDescription) (result RepairTaskUpdateInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: repairTaskApproveDescription,
			Constraints: []validation.Constraint{{Target: "repairTaskApproveDescription.TaskID", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "ForceApproveRepairTask")
	}

	req, err := client.ForceApproveRepairTaskPreparer(ctx, repairTaskApproveDescription)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ForceApproveRepairTask", nil, "Failure preparing request")
		return
	}

	resp, err := client.ForceApproveRepairTaskSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ForceApproveRepairTask", resp, "Failure sending request")
		return
	}

	result, err = client.ForceApproveRepairTaskResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ForceApproveRepairTask", resp, "Failure responding to request")
	}

	return
}

// ForceApproveRepairTaskPreparer prepares the ForceApproveRepairTask request.
func (client BaseClient) ForceApproveRepairTaskPreparer(ctx context.Context, repairTaskApproveDescription RepairTaskApproveDescription) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/ForceApproveRepairTask"),
		autorest.WithJSON(repairTaskApproveDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ForceApproveRepairTaskSender sends the ForceApproveRepairTask request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ForceApproveRepairTaskSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ForceApproveRepairTaskResponder handles the response to the ForceApproveRepairTask request. The method always
// closes the http.Response Body.
func (client BaseClient) ForceApproveRepairTaskResponder(resp *http.Response) (result RepairTaskUpdateInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetAadMetadata gets the Azure Active Directory metadata used for secured connection to cluster.
// This API is not supposed to be called separately. It provides information needed to set up an Azure Active Directory
// secured connection with a Service Fabric cluster.
//
// timeout is the server timeout for performing the operation in seconds. This specifies the time duration that the
// client is willing to wait for the requested operation to complete. The default value for this parameter is 60
// seconds.
func (client BaseClient) GetAadMetadata(ctx context.Context, timeout *int64) (result AadMetadataObject, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetAadMetadata")
	}

	req, err := client.GetAadMetadataPreparer(ctx, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetAadMetadata", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetAadMetadataSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetAadMetadata", resp, "Failure sending request")
		return
	}

	result, err = client.GetAadMetadataResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetAadMetadata", resp, "Failure responding to request")
	}

	return
}

// GetAadMetadataPreparer prepares the GetAadMetadata request.
func (client BaseClient) GetAadMetadataPreparer(ctx context.Context, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/GetAadMetadata"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetAadMetadataSender sends the GetAadMetadata request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetAadMetadataSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetAadMetadataResponder handles the response to the GetAadMetadata request. The method always
// closes the http.Response Body.
func (client BaseClient) GetAadMetadataResponder(resp *http.Response) (result AadMetadataObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetApplicationHealth returns the heath state of the service fabric application. The response reports either Ok,
// Error or Warning health state. If the entity is not found in the helath store, it will return Error.
//
// applicationID is the identity of the application. This is typically the full name of the application without the
// 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For
// example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+
// and "myapp/app1" in previous versions. eventsHealthStateFilter is allows filtering the collection of HealthEvent
// objects returned based on health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a
// combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of
// the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// deployedApplicationsHealthStateFilter is allows filtering of the deployed applications health state objects returned
// in the result of application health query based on their health state.
// The possible values for this parameter include integer value of one of the following health states. Only deployed
// applications that match the filter will be returned.\
// All deployed applications are used to evaluate the aggregated health state. If not specified, all entries are
// returned.
// The state values are flag based enumeration, so the value could be a combination of these value obtained using
// bitwise 'OR' operator.
// For example, if the provided value is 6 then health state of deployed applications with HealthState value of OK (2)
// and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. servicesHealthStateFilter is
// allows filtering of the services health state objects returned in the result of services health query based on their
// health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only services that match the filter are returned. All services are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a
// combination of these value
// obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services with
// HealthState value of OK (2) and Warning (4) will be returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. excludeHealthStatistics is
// indicates whether the health statistics should be returned as part of the query result. False by default.
// The statistics show the number of children entities in health state Ok, Warning, and Error. timeout is the server
// timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait
// for the requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetApplicationHealth(ctx context.Context, applicationID string, eventsHealthStateFilter *int32, deployedApplicationsHealthStateFilter *int32, servicesHealthStateFilter *int32, excludeHealthStatistics *bool, timeout *int64) (result ApplicationHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetApplicationHealth")
	}

	req, err := client.GetApplicationHealthPreparer(ctx, applicationID, eventsHealthStateFilter, deployedApplicationsHealthStateFilter, servicesHealthStateFilter, excludeHealthStatistics, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetApplicationHealthSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationHealth", resp, "Failure sending request")
		return
	}

	result, err = client.GetApplicationHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationHealth", resp, "Failure responding to request")
	}

	return
}

// GetApplicationHealthPreparer prepares the GetApplicationHealth request.
func (client BaseClient) GetApplicationHealthPreparer(ctx context.Context, applicationID string, eventsHealthStateFilter *int32, deployedApplicationsHealthStateFilter *int32, servicesHealthStateFilter *int32, excludeHealthStatistics *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	}
	if deployedApplicationsHealthStateFilter != nil {
		queryParameters["DeployedApplicationsHealthStateFilter"] = autorest.Encode("query", *deployedApplicationsHealthStateFilter)
	}
	if servicesHealthStateFilter != nil {
		queryParameters["ServicesHealthStateFilter"] = autorest.Encode("query", *servicesHealthStateFilter)
	}
	if excludeHealthStatistics != nil {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", *excludeHealthStatistics)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetApplicationHealthSender sends the GetApplicationHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetApplicationHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetApplicationHealthResponder handles the response to the GetApplicationHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) GetApplicationHealthResponder(resp *http.Response) (result ApplicationHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetApplicationHealthUsingPolicy gets the health of a Service Fabric application. Use EventsHealthStateFilter to
// filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicies to
// override the health policies used to evaluate the health.
//
// applicationID is the identity of the application. This is typically the full name of the application without the
// 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For
// example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+
// and "myapp/app1" in previous versions. eventsHealthStateFilter is allows filtering the collection of HealthEvent
// objects returned based on health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a
// combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of
// the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// deployedApplicationsHealthStateFilter is allows filtering of the deployed applications health state objects returned
// in the result of application health query based on their health state.
// The possible values for this parameter include integer value of one of the following health states. Only deployed
// applications that match the filter will be returned.\
// All deployed applications are used to evaluate the aggregated health state. If not specified, all entries are
// returned.
// The state values are flag based enumeration, so the value could be a combination of these value obtained using
// bitwise 'OR' operator.
// For example, if the provided value is 6 then health state of deployed applications with HealthState value of OK (2)
// and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. servicesHealthStateFilter is
// allows filtering of the services health state objects returned in the result of services health query based on their
// health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only services that match the filter are returned. All services are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a
// combination of these value
// obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services with
// HealthState value of OK (2) and Warning (4) will be returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. excludeHealthStatistics is
// indicates whether the health statistics should be returned as part of the query result. False by default.
// The statistics show the number of children entities in health state Ok, Warning, and Error. applicationHealthPolicy
// is describes the health policies used to evaluate the health of an application or one of its children.
// If not present, the health evaluation uses the health policy from application manifest or the default health policy.
// timeout is the server timeout for performing the operation in seconds. This specifies the time duration that the
// client is willing to wait for the requested operation to complete. The default value for this parameter is 60
// seconds.
func (client BaseClient) GetApplicationHealthUsingPolicy(ctx context.Context, applicationID string, eventsHealthStateFilter *int32, deployedApplicationsHealthStateFilter *int32, servicesHealthStateFilter *int32, excludeHealthStatistics *bool, applicationHealthPolicy *ApplicationHealthPolicy, timeout *int64) (result ApplicationHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetApplicationHealthUsingPolicy")
	}

	req, err := client.GetApplicationHealthUsingPolicyPreparer(ctx, applicationID, eventsHealthStateFilter, deployedApplicationsHealthStateFilter, servicesHealthStateFilter, excludeHealthStatistics, applicationHealthPolicy, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationHealthUsingPolicy", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetApplicationHealthUsingPolicySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationHealthUsingPolicy", resp, "Failure sending request")
		return
	}

	result, err = client.GetApplicationHealthUsingPolicyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationHealthUsingPolicy", resp, "Failure responding to request")
	}

	return
}

// GetApplicationHealthUsingPolicyPreparer prepares the GetApplicationHealthUsingPolicy request.
func (client BaseClient) GetApplicationHealthUsingPolicyPreparer(ctx context.Context, applicationID string, eventsHealthStateFilter *int32, deployedApplicationsHealthStateFilter *int32, servicesHealthStateFilter *int32, excludeHealthStatistics *bool, applicationHealthPolicy *ApplicationHealthPolicy, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	}
	if deployedApplicationsHealthStateFilter != nil {
		queryParameters["DeployedApplicationsHealthStateFilter"] = autorest.Encode("query", *deployedApplicationsHealthStateFilter)
	}
	if servicesHealthStateFilter != nil {
		queryParameters["ServicesHealthStateFilter"] = autorest.Encode("query", *servicesHealthStateFilter)
	}
	if excludeHealthStatistics != nil {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", *excludeHealthStatistics)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if applicationHealthPolicy != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(applicationHealthPolicy))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetApplicationHealthUsingPolicySender sends the GetApplicationHealthUsingPolicy request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetApplicationHealthUsingPolicySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetApplicationHealthUsingPolicyResponder handles the response to the GetApplicationHealthUsingPolicy request. The method always
// closes the http.Response Body.
func (client BaseClient) GetApplicationHealthUsingPolicyResponder(resp *http.Response) (result ApplicationHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetApplicationInfo returns the information about the application that was created or in the process of being created
// in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the
// name, type, status, parameters and other details about the application.
//
// applicationID is the identity of the application. This is typically the full name of the application without the
// 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For
// example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+
// and "myapp/app1" in previous versions. excludeApplicationParameters is the flag that specifies whether application
// parameters will be excluded from the result. timeout is the server timeout for performing the operation in seconds.
// This specifies the time duration that the client is willing to wait for the requested operation to complete. The
// default value for this parameter is 60 seconds.
func (client BaseClient) GetApplicationInfo(ctx context.Context, applicationID string, excludeApplicationParameters *bool, timeout *int64) (result ApplicationInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetApplicationInfo")
	}

	req, err := client.GetApplicationInfoPreparer(ctx, applicationID, excludeApplicationParameters, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetApplicationInfoSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetApplicationInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationInfo", resp, "Failure responding to request")
	}

	return
}

// GetApplicationInfoPreparer prepares the GetApplicationInfo request.
func (client BaseClient) GetApplicationInfoPreparer(ctx context.Context, applicationID string, excludeApplicationParameters *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if excludeApplicationParameters != nil {
		queryParameters["ExcludeApplicationParameters"] = autorest.Encode("query", *excludeApplicationParameters)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetApplicationInfoSender sends the GetApplicationInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetApplicationInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetApplicationInfoResponder handles the response to the GetApplicationInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetApplicationInfoResponder(resp *http.Response) (result ApplicationInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetApplicationInfoList gets the information about the applications that were created or in the process of being
// created in the Service Fabric cluster and match filters specified as the parameter. The response includes the name,
// type, status, parameters and other details about the application. If the applications do not fit in a page, one page
// of results is returned as well as a continuation token which can be used to get the next page. Filters
// ApplicationTypeName and ApplicationDefinitionKindFilter cannot be specified at the same time.
//
// applicationDefinitionKindFilter is used to filter on ApplicationDefinitionKind for application query operations.
// - Default - Default value, which performs the same function as selecting "All". The value is 0.
// - All - Filter that matches input with any ApplicationDefinitionKind value. The value is 65535.
// - ServiceFabricApplicationDescription - Filter that matches input with ApplicationDefinitionKind value
// ServiceFabricApplicationDescription. The value is 1.
// - Compose - Filter that matches input with ApplicationDefinitionKind value Compose. The value is 2.
// applicationTypeName is the application type name used to filter the applications to query for. This value should not
// contain the application type version. excludeApplicationParameters is the flag that specifies whether application
// parameters will be excluded from the result. continuationToken is the continuation token parameter is used to obtain
// next set of results. A continuation token with a non empty value is included in the response of the API when the
// results from the system do not fit in a single response. When this value is passed to the next API call, the API
// returns next set of results. If there are no further results then the continuation token does not contain a value.
// The value of this parameter should not be URL encoded. timeout is the server timeout for performing the operation in
// seconds. This specifies the time duration that the client is willing to wait for the requested operation to
// complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetApplicationInfoList(ctx context.Context, applicationDefinitionKindFilter *int32, applicationTypeName string, excludeApplicationParameters *bool, continuationToken string, timeout *int64) (result PagedApplicationInfoList, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetApplicationInfoList")
	}

	req, err := client.GetApplicationInfoListPreparer(ctx, applicationDefinitionKindFilter, applicationTypeName, excludeApplicationParameters, continuationToken, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetApplicationInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetApplicationInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationInfoList", resp, "Failure responding to request")
	}

	return
}

// GetApplicationInfoListPreparer prepares the GetApplicationInfoList request.
func (client BaseClient) GetApplicationInfoListPreparer(ctx context.Context, applicationDefinitionKindFilter *int32, applicationTypeName string, excludeApplicationParameters *bool, continuationToken string, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if applicationDefinitionKindFilter != nil {
		queryParameters["ApplicationDefinitionKindFilter"] = autorest.Encode("query", *applicationDefinitionKindFilter)
	}
	if len(applicationTypeName) > 0 {
		queryParameters["ApplicationTypeName"] = autorest.Encode("query", applicationTypeName)
	}
	if excludeApplicationParameters != nil {
		queryParameters["ExcludeApplicationParameters"] = autorest.Encode("query", *excludeApplicationParameters)
	}
	if len(continuationToken) > 0 {
		queryParameters["ContinuationToken"] = continuationToken
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/Applications"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetApplicationInfoListSender sends the GetApplicationInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetApplicationInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetApplicationInfoListResponder handles the response to the GetApplicationInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetApplicationInfoListResponder(resp *http.Response) (result PagedApplicationInfoList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetApplicationLoadInfo returns the load information about the application that was created or in the process of
// being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response
// includes the name, minimum nodes, maximum nodes, the number of nodes the app is occupying currently, and application
// load metric information about the application.
//
// applicationID is the identity of the application. This is typically the full name of the application without the
// 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For
// example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+
// and "myapp/app1" in previous versions. timeout is the server timeout for performing the operation in seconds. This
// specifies the time duration that the client is willing to wait for the requested operation to complete. The default
// value for this parameter is 60 seconds.
func (client BaseClient) GetApplicationLoadInfo(ctx context.Context, applicationID string, timeout *int64) (result ApplicationLoadInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetApplicationLoadInfo")
	}

	req, err := client.GetApplicationLoadInfoPreparer(ctx, applicationID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationLoadInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetApplicationLoadInfoSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationLoadInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetApplicationLoadInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationLoadInfo", resp, "Failure responding to request")
	}

	return
}

// GetApplicationLoadInfoPreparer prepares the GetApplicationLoadInfo request.
func (client BaseClient) GetApplicationLoadInfoPreparer(ctx context.Context, applicationID string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/GetLoadInformation", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetApplicationLoadInfoSender sends the GetApplicationLoadInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetApplicationLoadInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetApplicationLoadInfoResponder handles the response to the GetApplicationLoadInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetApplicationLoadInfoResponder(resp *http.Response) (result ApplicationLoadInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetApplicationManifest gets the manifest describing an application type. The response contains the application
// manifest XML as a string.
//
// applicationTypeName is the name of the application type. applicationTypeVersion is the version of the application
// type. timeout is the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter is 60
// seconds.
func (client BaseClient) GetApplicationManifest(ctx context.Context, applicationTypeName string, applicationTypeVersion string, timeout *int64) (result ApplicationTypeManifest, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetApplicationManifest")
	}

	req, err := client.GetApplicationManifestPreparer(ctx, applicationTypeName, applicationTypeVersion, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationManifest", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetApplicationManifestSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationManifest", resp, "Failure sending request")
		return
	}

	result, err = client.GetApplicationManifestResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationManifest", resp, "Failure responding to request")
	}

	return
}

// GetApplicationManifestPreparer prepares the GetApplicationManifest request.
func (client BaseClient) GetApplicationManifestPreparer(ctx context.Context, applicationTypeName string, applicationTypeVersion string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationTypeName": autorest.Encode("path", applicationTypeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version":            APIVersion,
		"ApplicationTypeVersion": autorest.Encode("query", applicationTypeVersion),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ApplicationTypes/{applicationTypeName}/$/GetApplicationManifest", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetApplicationManifestSender sends the GetApplicationManifest request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetApplicationManifestSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetApplicationManifestResponder handles the response to the GetApplicationManifest request. The method always
// closes the http.Response Body.
func (client BaseClient) GetApplicationManifestResponder(resp *http.Response) (result ApplicationTypeManifest, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetApplicationNameInfo the GetApplicationName endpoint returns the name of the application for the specified
// service.
//
// serviceID is the identity of the service. This is typically the full name of the service without the 'fabric:' URI
// scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the
// service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and
// "myapp/app1/svc1" in previous versions. timeout is the server timeout for performing the operation in seconds. This
// specifies the time duration that the client is willing to wait for the requested operation to complete. The default
// value for this parameter is 60 seconds.
func (client BaseClient) GetApplicationNameInfo(ctx context.Context, serviceID string, timeout *int64) (result ApplicationNameInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetApplicationNameInfo")
	}

	req, err := client.GetApplicationNameInfoPreparer(ctx, serviceID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationNameInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetApplicationNameInfoSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationNameInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetApplicationNameInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationNameInfo", resp, "Failure responding to request")
	}

	return
}

// GetApplicationNameInfoPreparer prepares the GetApplicationNameInfo request.
func (client BaseClient) GetApplicationNameInfoPreparer(ctx context.Context, serviceID string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"serviceId": serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Services/{serviceId}/$/GetApplicationName", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetApplicationNameInfoSender sends the GetApplicationNameInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetApplicationNameInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetApplicationNameInfoResponder handles the response to the GetApplicationNameInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetApplicationNameInfoResponder(resp *http.Response) (result ApplicationNameInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetApplicationTypeInfoList returns the information about the application types that are provisioned or in the
// process of being provisioned in the Service Fabric cluster. Each version of an application type is returned as one
// application type. The response includes the name, version, status and other details about the application type. This
// is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as
// well as a continuation token which can be used to get the next page. For example, if there are 10 application types
// but a page only fits the first 3 application types, or if max results is set to 3, then 3 is returned. To access the
// rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty
// continuation token is returned if there are no subsequent pages.
//
// applicationTypeDefinitionKindFilter is used to filter on ApplicationTypeDefinitionKind for application type query
// operations.
// - Default - Default value, which performs the same function as selecting "All". The value is 0.
// - All - Filter that matches input with any ApplicationTypeDefinitionKind value. The value is 65535.
// - ServiceFabricApplicationPackage - Filter that matches input with ApplicationTypeDefinitionKind value
// ServiceFabricApplicationPackage. The value is 1.
// - Compose - Filter that matches input with ApplicationTypeDefinitionKind value Compose. The value is 2.
// excludeApplicationParameters is the flag that specifies whether application parameters will be excluded from the
// result. continuationToken is the continuation token parameter is used to obtain next set of results. A continuation
// token with a non empty value is included in the response of the API when the results from the system do not fit in a
// single response. When this value is passed to the next API call, the API returns next set of results. If there are
// no further results then the continuation token does not contain a value. The value of this parameter should not be
// URL encoded. maxResults is the maximum number of results to be returned as part of the paged queries. This parameter
// defines the upper bound on the number of results returned. The results returned can be less than the specified
// maximum results if they do not fit in the message as per the max message size restrictions defined in the
// configuration. If this parameter is zero or not specified, the paged queries includes as much results as possible
// that fit in the return message. timeout is the server timeout for performing the operation in seconds. This
// specifies the time duration that the client is willing to wait for the requested operation to complete. The default
// value for this parameter is 60 seconds.
func (client BaseClient) GetApplicationTypeInfoList(ctx context.Context, applicationTypeDefinitionKindFilter *int32, excludeApplicationParameters *bool, continuationToken string, maxResults *int64, timeout *int64) (result PagedApplicationTypeInfoList, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: maxResults,
			Constraints: []validation.Constraint{{Target: "maxResults", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "maxResults", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil}}}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetApplicationTypeInfoList")
	}

	req, err := client.GetApplicationTypeInfoListPreparer(ctx, applicationTypeDefinitionKindFilter, excludeApplicationParameters, continuationToken, maxResults, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationTypeInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetApplicationTypeInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationTypeInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetApplicationTypeInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationTypeInfoList", resp, "Failure responding to request")
	}

	return
}

// GetApplicationTypeInfoListPreparer prepares the GetApplicationTypeInfoList request.
func (client BaseClient) GetApplicationTypeInfoListPreparer(ctx context.Context, applicationTypeDefinitionKindFilter *int32, excludeApplicationParameters *bool, continuationToken string, maxResults *int64, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if applicationTypeDefinitionKindFilter != nil {
		queryParameters["ApplicationTypeDefinitionKindFilter"] = autorest.Encode("query", *applicationTypeDefinitionKindFilter)
	}
	if excludeApplicationParameters != nil {
		queryParameters["ExcludeApplicationParameters"] = autorest.Encode("query", *excludeApplicationParameters)
	}
	if len(continuationToken) > 0 {
		queryParameters["ContinuationToken"] = continuationToken
	}
	if maxResults != nil {
		queryParameters["MaxResults"] = autorest.Encode("query", *maxResults)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/ApplicationTypes"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetApplicationTypeInfoListSender sends the GetApplicationTypeInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetApplicationTypeInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetApplicationTypeInfoListResponder handles the response to the GetApplicationTypeInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetApplicationTypeInfoListResponder(resp *http.Response) (result PagedApplicationTypeInfoList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetApplicationTypeInfoListByName returns the information about the application types that are provisioned or in the
// process of being provisioned in the Service Fabric cluster. These results are of application types whose name match
// exactly the one specified as the parameter, and which comply with the given query parameters. All versions of the
// application type matching the application type name are returned, with each version returned as one application
// type. The response includes the name, version, status and other details about the application type. This is a paged
// query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a
// continuation token which can be used to get the next page. For example, if there are 10 application types but a page
// only fits the first 3 application types, or if max results is set to 3, then 3 is returned. To access the rest of
// the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty
// continuation token is returned if there are no subsequent pages.
//
// applicationTypeName is the name of the application type. applicationTypeVersion is the version of the application
// type. excludeApplicationParameters is the flag that specifies whether application parameters will be excluded from
// the result. continuationToken is the continuation token parameter is used to obtain next set of results. A
// continuation token with a non empty value is included in the response of the API when the results from the system do
// not fit in a single response. When this value is passed to the next API call, the API returns next set of results.
// If there are no further results then the continuation token does not contain a value. The value of this parameter
// should not be URL encoded. maxResults is the maximum number of results to be returned as part of the paged queries.
// This parameter defines the upper bound on the number of results returned. The results returned can be less than the
// specified maximum results if they do not fit in the message as per the max message size restrictions defined in the
// configuration. If this parameter is zero or not specified, the paged queries includes as much results as possible
// that fit in the return message. timeout is the server timeout for performing the operation in seconds. This
// specifies the time duration that the client is willing to wait for the requested operation to complete. The default
// value for this parameter is 60 seconds.
func (client BaseClient) GetApplicationTypeInfoListByName(ctx context.Context, applicationTypeName string, applicationTypeVersion string, excludeApplicationParameters *bool, continuationToken string, maxResults *int64, timeout *int64) (result PagedApplicationTypeInfoList, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: maxResults,
			Constraints: []validation.Constraint{{Target: "maxResults", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "maxResults", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil}}}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetApplicationTypeInfoListByName")
	}

	req, err := client.GetApplicationTypeInfoListByNamePreparer(ctx, applicationTypeName, applicationTypeVersion, excludeApplicationParameters, continuationToken, maxResults, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationTypeInfoListByName", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetApplicationTypeInfoListByNameSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationTypeInfoListByName", resp, "Failure sending request")
		return
	}

	result, err = client.GetApplicationTypeInfoListByNameResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationTypeInfoListByName", resp, "Failure responding to request")
	}

	return
}

// GetApplicationTypeInfoListByNamePreparer prepares the GetApplicationTypeInfoListByName request.
func (client BaseClient) GetApplicationTypeInfoListByNamePreparer(ctx context.Context, applicationTypeName string, applicationTypeVersion string, excludeApplicationParameters *bool, continuationToken string, maxResults *int64, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationTypeName": autorest.Encode("path", applicationTypeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(applicationTypeVersion) > 0 {
		queryParameters["ApplicationTypeVersion"] = autorest.Encode("query", applicationTypeVersion)
	}
	if excludeApplicationParameters != nil {
		queryParameters["ExcludeApplicationParameters"] = autorest.Encode("query", *excludeApplicationParameters)
	}
	if len(continuationToken) > 0 {
		queryParameters["ContinuationToken"] = continuationToken
	}
	if maxResults != nil {
		queryParameters["MaxResults"] = autorest.Encode("query", *maxResults)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ApplicationTypes/{applicationTypeName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetApplicationTypeInfoListByNameSender sends the GetApplicationTypeInfoListByName request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetApplicationTypeInfoListByNameSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetApplicationTypeInfoListByNameResponder handles the response to the GetApplicationTypeInfoListByName request. The method always
// closes the http.Response Body.
func (client BaseClient) GetApplicationTypeInfoListByNameResponder(resp *http.Response) (result PagedApplicationTypeInfoList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetApplicationUpgrade returns information about the state of the latest application upgrade along with details to
// aid debugging application health issues.
//
// applicationID is the identity of the application. This is typically the full name of the application without the
// 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For
// example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+
// and "myapp/app1" in previous versions. timeout is the server timeout for performing the operation in seconds. This
// specifies the time duration that the client is willing to wait for the requested operation to complete. The default
// value for this parameter is 60 seconds.
func (client BaseClient) GetApplicationUpgrade(ctx context.Context, applicationID string, timeout *int64) (result ApplicationUpgradeProgressInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetApplicationUpgrade")
	}

	req, err := client.GetApplicationUpgradePreparer(ctx, applicationID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationUpgrade", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetApplicationUpgradeSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationUpgrade", resp, "Failure sending request")
		return
	}

	result, err = client.GetApplicationUpgradeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationUpgrade", resp, "Failure responding to request")
	}

	return
}

// GetApplicationUpgradePreparer prepares the GetApplicationUpgrade request.
func (client BaseClient) GetApplicationUpgradePreparer(ctx context.Context, applicationID string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/GetUpgradeProgress", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetApplicationUpgradeSender sends the GetApplicationUpgrade request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetApplicationUpgradeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetApplicationUpgradeResponder handles the response to the GetApplicationUpgrade request. The method always
// closes the http.Response Body.
func (client BaseClient) GetApplicationUpgradeResponder(resp *http.Response) (result ApplicationUpgradeProgressInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetChaosReport you can either specify the ContinuationToken to get the next segment of the Chaos report or you can
// specify the time-range
// through StartTimeUtc and EndTimeUtc, but you cannot specify both the ContinuationToken and the time-range in the
// same call.
// When there are more than 100 Chaos events, the Chaos report is returned in segments where a segment contains no more
// than 100 Chaos events.
//
// continuationToken is the continuation token parameter is used to obtain next set of results. A continuation token
// with a non empty value is included in the response of the API when the results from the system do not fit in a
// single response. When this value is passed to the next API call, the API returns next set of results. If there are
// no further results then the continuation token does not contain a value. The value of this parameter should not be
// URL encoded. startTimeUtc is the count of ticks representing the start time of the time range for which a Chaos
// report is to be generated. Please consult [DateTime.Ticks
// Property](https://msdn.microsoft.com/en-us/library/system.datetime.ticks%28v=vs.110%29) for details about tick.
// endTimeUtc is the count of ticks representing the end time of the time range for which a Chaos report is to be
// generated. Please consult [DateTime.Ticks
// Property](https://msdn.microsoft.com/en-us/library/system.datetime.ticks%28v=vs.110%29) for details about tick.
// timeout is the server timeout for performing the operation in seconds. This specifies the time duration that the
// client is willing to wait for the requested operation to complete. The default value for this parameter is 60
// seconds.
func (client BaseClient) GetChaosReport(ctx context.Context, continuationToken string, startTimeUtc string, endTimeUtc string, timeout *int64) (result ChaosReport, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetChaosReport")
	}

	req, err := client.GetChaosReportPreparer(ctx, continuationToken, startTimeUtc, endTimeUtc, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetChaosReport", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetChaosReportSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetChaosReport", resp, "Failure sending request")
		return
	}

	result, err = client.GetChaosReportResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetChaosReport", resp, "Failure responding to request")
	}

	return
}

// GetChaosReportPreparer prepares the GetChaosReport request.
func (client BaseClient) GetChaosReportPreparer(ctx context.Context, continuationToken string, startTimeUtc string, endTimeUtc string, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(continuationToken) > 0 {
		queryParameters["ContinuationToken"] = continuationToken
	}
	if len(startTimeUtc) > 0 {
		queryParameters["StartTimeUtc"] = autorest.Encode("query", startTimeUtc)
	}
	if len(endTimeUtc) > 0 {
		queryParameters["EndTimeUtc"] = autorest.Encode("query", endTimeUtc)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/Tools/Chaos/$/Report"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetChaosReportSender sends the GetChaosReport request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetChaosReportSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetChaosReportResponder handles the response to the GetChaosReport request. The method always
// closes the http.Response Body.
func (client BaseClient) GetChaosReportResponder(resp *http.Response) (result ChaosReport, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetClusterConfiguration get the Service Fabric standalone cluster configuration. The cluster configuration contains
// properties of the cluster that include different node types on the cluster,
// security configurations, fault and upgrade domain topologies etc.
//
// configurationAPIVersion is the API version of the Standalone cluster json configuration. timeout is the server
// timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait
// for the requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetClusterConfiguration(ctx context.Context, configurationAPIVersion string, timeout *int64) (result ClusterConfiguration, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetClusterConfiguration")
	}

	req, err := client.GetClusterConfigurationPreparer(ctx, configurationAPIVersion, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterConfiguration", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetClusterConfigurationSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterConfiguration", resp, "Failure sending request")
		return
	}

	result, err = client.GetClusterConfigurationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterConfiguration", resp, "Failure responding to request")
	}

	return
}

// GetClusterConfigurationPreparer prepares the GetClusterConfiguration request.
func (client BaseClient) GetClusterConfigurationPreparer(ctx context.Context, configurationAPIVersion string, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version":             APIVersion,
		"ConfigurationApiVersion": autorest.Encode("query", configurationAPIVersion),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/GetClusterConfiguration"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetClusterConfigurationSender sends the GetClusterConfiguration request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetClusterConfigurationSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetClusterConfigurationResponder handles the response to the GetClusterConfiguration request. The method always
// closes the http.Response Body.
func (client BaseClient) GetClusterConfigurationResponder(resp *http.Response) (result ClusterConfiguration, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetClusterConfigurationUpgradeStatus get the cluster configuration upgrade status of a Service Fabric standalone
// cluster.
//
// timeout is the server timeout for performing the operation in seconds. This specifies the time duration that the
// client is willing to wait for the requested operation to complete. The default value for this parameter is 60
// seconds.
func (client BaseClient) GetClusterConfigurationUpgradeStatus(ctx context.Context, timeout *int64) (result ClusterConfigurationUpgradeStatusInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetClusterConfigurationUpgradeStatus")
	}

	req, err := client.GetClusterConfigurationUpgradeStatusPreparer(ctx, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterConfigurationUpgradeStatus", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetClusterConfigurationUpgradeStatusSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterConfigurationUpgradeStatus", resp, "Failure sending request")
		return
	}

	result, err = client.GetClusterConfigurationUpgradeStatusResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterConfigurationUpgradeStatus", resp, "Failure responding to request")
	}

	return
}

// GetClusterConfigurationUpgradeStatusPreparer prepares the GetClusterConfigurationUpgradeStatus request.
func (client BaseClient) GetClusterConfigurationUpgradeStatusPreparer(ctx context.Context, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/GetClusterConfigurationUpgradeStatus"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetClusterConfigurationUpgradeStatusSender sends the GetClusterConfigurationUpgradeStatus request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetClusterConfigurationUpgradeStatusSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetClusterConfigurationUpgradeStatusResponder handles the response to the GetClusterConfigurationUpgradeStatus request. The method always
// closes the http.Response Body.
func (client BaseClient) GetClusterConfigurationUpgradeStatusResponder(resp *http.Response) (result ClusterConfigurationUpgradeStatusInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetClusterHealth gets the health of a Service Fabric cluster.
// Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health
// state.
// Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and
// applications returned based on their aggregated health state.
//
// nodesHealthStateFilter is allows filtering of the node health state objects returned in the result of cluster health
// query
// based on their health state. The possible values for this parameter include integer value of one of the
// following health states. Only nodes that match the filter are returned. All nodes are used to evaluate the
// aggregated health state.
// If not specified, all entries are returned.
// The state values are flag based enumeration, so the value could be a combination of these values obtained using
// bitwise 'OR' operator.
// For example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and Warning (4)
// are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. applicationsHealthStateFilter is
// allows filtering of the application health state objects returned in the result of cluster health
// query based on their health state.
// The possible values for this parameter include integer value obtained from members or bitwise operations
// on members of HealthStateFilter enumeration. Only applications that match the filter are returned.
// All applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
// The state values are flag based enumeration, so the value could be a combination of these values obtained using
// bitwise 'OR' operator.
// For example, if the provided value is 6 then health state of applications with HealthState value of OK (2) and
// Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. eventsHealthStateFilter is allows
// filtering the collection of HealthEvent objects returned based on health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a
// combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of
// the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. excludeHealthStatistics is
// indicates whether the health statistics should be returned as part of the query result. False by default.
// The statistics show the number of children entities in health state Ok, Warning, and Error.
// includeSystemApplicationHealthStatistics is indicates whether the health statistics should include the
// fabric:/System application health statistics. False by default.
// If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that belong
// to the fabric:/System application.
// Otherwise, the query result includes health statistics only for user applications.
// The health statistics must be included in the query result for this parameter to be applied. timeout is the server
// timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait
// for the requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetClusterHealth(ctx context.Context, nodesHealthStateFilter *int32, applicationsHealthStateFilter *int32, eventsHealthStateFilter *int32, excludeHealthStatistics *bool, includeSystemApplicationHealthStatistics *bool, timeout *int64) (result ClusterHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetClusterHealth")
	}

	req, err := client.GetClusterHealthPreparer(ctx, nodesHealthStateFilter, applicationsHealthStateFilter, eventsHealthStateFilter, excludeHealthStatistics, includeSystemApplicationHealthStatistics, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetClusterHealthSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterHealth", resp, "Failure sending request")
		return
	}

	result, err = client.GetClusterHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterHealth", resp, "Failure responding to request")
	}

	return
}

// GetClusterHealthPreparer prepares the GetClusterHealth request.
func (client BaseClient) GetClusterHealthPreparer(ctx context.Context, nodesHealthStateFilter *int32, applicationsHealthStateFilter *int32, eventsHealthStateFilter *int32, excludeHealthStatistics *bool, includeSystemApplicationHealthStatistics *bool, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if nodesHealthStateFilter != nil {
		queryParameters["NodesHealthStateFilter"] = autorest.Encode("query", *nodesHealthStateFilter)
	}
	if applicationsHealthStateFilter != nil {
		queryParameters["ApplicationsHealthStateFilter"] = autorest.Encode("query", *applicationsHealthStateFilter)
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	}
	if excludeHealthStatistics != nil {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", *excludeHealthStatistics)
	}
	if includeSystemApplicationHealthStatistics != nil {
		queryParameters["IncludeSystemApplicationHealthStatistics"] = autorest.Encode("query", *includeSystemApplicationHealthStatistics)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/GetClusterHealth"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetClusterHealthSender sends the GetClusterHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetClusterHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetClusterHealthResponder handles the response to the GetClusterHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) GetClusterHealthResponder(resp *http.Response) (result ClusterHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetClusterHealthChunk gets the health of a Service Fabric cluster using health chunks. Includes the aggregated
// health state of the cluster, but none of the cluster entities.
// To expand the cluster health and get the health state of all or some of the entities, use the POST URI and specify
// the cluster health chunk query description.
//
// timeout is the server timeout for performing the operation in seconds. This specifies the time duration that the
// client is willing to wait for the requested operation to complete. The default value for this parameter is 60
// seconds.
func (client BaseClient) GetClusterHealthChunk(ctx context.Context, timeout *int64) (result ClusterHealthChunk, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetClusterHealthChunk")
	}

	req, err := client.GetClusterHealthChunkPreparer(ctx, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterHealthChunk", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetClusterHealthChunkSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterHealthChunk", resp, "Failure sending request")
		return
	}

	result, err = client.GetClusterHealthChunkResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterHealthChunk", resp, "Failure responding to request")
	}

	return
}

// GetClusterHealthChunkPreparer prepares the GetClusterHealthChunk request.
func (client BaseClient) GetClusterHealthChunkPreparer(ctx context.Context, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/GetClusterHealthChunk"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetClusterHealthChunkSender sends the GetClusterHealthChunk request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetClusterHealthChunkSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetClusterHealthChunkResponder handles the response to the GetClusterHealthChunk request. The method always
// closes the http.Response Body.
func (client BaseClient) GetClusterHealthChunkResponder(resp *http.Response) (result ClusterHealthChunk, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetClusterHealthChunkUsingPolicyAndAdvancedFilters gets the health of a Service Fabric cluster using health chunks.
// The health evaluation is done based on the input cluster health chunk query description.
// The query description allows users to specify health policies for evaluating the cluster and its children.
// Users can specify very flexible filters to select which cluster entities to return. The selection can be done based
// on the entities health state and based on the hierarchy.
// The query can return multi-level children of the entities based on the specified filters. For example, it can return
// one application with a specified name, and for this application, return
// only services that are in Error or Warning, and all partitions and replicas for one of these services.
//
// clusterHealthChunkQueryDescription is describes the cluster and application health policies used to evaluate the
// cluster health and the filters to select which cluster entities to be returned.
// If the cluster health policy is present, it is used to evaluate the cluster events and the cluster nodes. If not
// present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default cluster
// health policy.
// By default, each application is evaluated using its specific application health policy, defined in the application
// manifest, or the default health policy, if no policy is defined in manifest.
// If the application health policy map is specified, and it has an entry for an application, the specified application
// health policy
// is used to evaluate the application health.
// Users can specify very flexible filters to select which cluster entities to include in response. The selection can
// be done based on the entities health state and based on the hierarchy.
// The query can return multi-level children of the entities based on the specified filters. For example, it can return
// one application with a specified name, and for this application, return
// only services that are in Error or Warning, and all partitions and replicas for one of these services. timeout is
// the server timeout for performing the operation in seconds. This specifies the time duration that the client is
// willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetClusterHealthChunkUsingPolicyAndAdvancedFilters(ctx context.Context, clusterHealthChunkQueryDescription *ClusterHealthChunkQueryDescription, timeout *int64) (result ClusterHealthChunk, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetClusterHealthChunkUsingPolicyAndAdvancedFilters")
	}

	req, err := client.GetClusterHealthChunkUsingPolicyAndAdvancedFiltersPreparer(ctx, clusterHealthChunkQueryDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterHealthChunkUsingPolicyAndAdvancedFilters", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetClusterHealthChunkUsingPolicyAndAdvancedFiltersSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterHealthChunkUsingPolicyAndAdvancedFilters", resp, "Failure sending request")
		return
	}

	result, err = client.GetClusterHealthChunkUsingPolicyAndAdvancedFiltersResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterHealthChunkUsingPolicyAndAdvancedFilters", resp, "Failure responding to request")
	}

	return
}

// GetClusterHealthChunkUsingPolicyAndAdvancedFiltersPreparer prepares the GetClusterHealthChunkUsingPolicyAndAdvancedFilters request.
func (client BaseClient) GetClusterHealthChunkUsingPolicyAndAdvancedFiltersPreparer(ctx context.Context, clusterHealthChunkQueryDescription *ClusterHealthChunkQueryDescription, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/GetClusterHealthChunk"),
		autorest.WithQueryParameters(queryParameters))
	if clusterHealthChunkQueryDescription != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(clusterHealthChunkQueryDescription))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetClusterHealthChunkUsingPolicyAndAdvancedFiltersSender sends the GetClusterHealthChunkUsingPolicyAndAdvancedFilters request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetClusterHealthChunkUsingPolicyAndAdvancedFiltersSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetClusterHealthChunkUsingPolicyAndAdvancedFiltersResponder handles the response to the GetClusterHealthChunkUsingPolicyAndAdvancedFilters request. The method always
// closes the http.Response Body.
func (client BaseClient) GetClusterHealthChunkUsingPolicyAndAdvancedFiltersResponder(resp *http.Response) (result ClusterHealthChunk, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetClusterHealthUsingPolicy gets the health of a Service Fabric cluster.
// Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health
// state.
// Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and
// applications returned based on their aggregated health state.
// Use ClusterHealthPolicies to override the health policies used to evaluate the health.
//
// nodesHealthStateFilter is allows filtering of the node health state objects returned in the result of cluster health
// query
// based on their health state. The possible values for this parameter include integer value of one of the
// following health states. Only nodes that match the filter are returned. All nodes are used to evaluate the
// aggregated health state.
// If not specified, all entries are returned.
// The state values are flag based enumeration, so the value could be a combination of these values obtained using
// bitwise 'OR' operator.
// For example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and Warning (4)
// are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. applicationsHealthStateFilter is
// allows filtering of the application health state objects returned in the result of cluster health
// query based on their health state.
// The possible values for this parameter include integer value obtained from members or bitwise operations
// on members of HealthStateFilter enumeration. Only applications that match the filter are returned.
// All applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
// The state values are flag based enumeration, so the value could be a combination of these values obtained using
// bitwise 'OR' operator.
// For example, if the provided value is 6 then health state of applications with HealthState value of OK (2) and
// Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. eventsHealthStateFilter is allows
// filtering the collection of HealthEvent objects returned based on health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a
// combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of
// the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. excludeHealthStatistics is
// indicates whether the health statistics should be returned as part of the query result. False by default.
// The statistics show the number of children entities in health state Ok, Warning, and Error.
// includeSystemApplicationHealthStatistics is indicates whether the health statistics should include the
// fabric:/System application health statistics. False by default.
// If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that belong
// to the fabric:/System application.
// Otherwise, the query result includes health statistics only for user applications.
// The health statistics must be included in the query result for this parameter to be applied. clusterHealthPolicies
// is describes the health policies used to evaluate the cluster health.
// If not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default
// cluster health policy.
// By default, each application is evaluated using its specific application health policy, defined in the application
// manifest, or the default health policy, if no policy is defined in manifest.
// If the application health policy map is specified, and it has an entry for an application, the specified application
// health policy
// is used to evaluate the application health. timeout is the server timeout for performing the operation in seconds.
// This specifies the time duration that the client is willing to wait for the requested operation to complete. The
// default value for this parameter is 60 seconds.
func (client BaseClient) GetClusterHealthUsingPolicy(ctx context.Context, nodesHealthStateFilter *int32, applicationsHealthStateFilter *int32, eventsHealthStateFilter *int32, excludeHealthStatistics *bool, includeSystemApplicationHealthStatistics *bool, clusterHealthPolicies *ClusterHealthPolicies, timeout *int64) (result ClusterHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetClusterHealthUsingPolicy")
	}

	req, err := client.GetClusterHealthUsingPolicyPreparer(ctx, nodesHealthStateFilter, applicationsHealthStateFilter, eventsHealthStateFilter, excludeHealthStatistics, includeSystemApplicationHealthStatistics, clusterHealthPolicies, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterHealthUsingPolicy", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetClusterHealthUsingPolicySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterHealthUsingPolicy", resp, "Failure sending request")
		return
	}

	result, err = client.GetClusterHealthUsingPolicyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterHealthUsingPolicy", resp, "Failure responding to request")
	}

	return
}

// GetClusterHealthUsingPolicyPreparer prepares the GetClusterHealthUsingPolicy request.
func (client BaseClient) GetClusterHealthUsingPolicyPreparer(ctx context.Context, nodesHealthStateFilter *int32, applicationsHealthStateFilter *int32, eventsHealthStateFilter *int32, excludeHealthStatistics *bool, includeSystemApplicationHealthStatistics *bool, clusterHealthPolicies *ClusterHealthPolicies, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if nodesHealthStateFilter != nil {
		queryParameters["NodesHealthStateFilter"] = autorest.Encode("query", *nodesHealthStateFilter)
	}
	if applicationsHealthStateFilter != nil {
		queryParameters["ApplicationsHealthStateFilter"] = autorest.Encode("query", *applicationsHealthStateFilter)
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	}
	if excludeHealthStatistics != nil {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", *excludeHealthStatistics)
	}
	if includeSystemApplicationHealthStatistics != nil {
		queryParameters["IncludeSystemApplicationHealthStatistics"] = autorest.Encode("query", *includeSystemApplicationHealthStatistics)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/GetClusterHealth"),
		autorest.WithQueryParameters(queryParameters))
	if clusterHealthPolicies != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(clusterHealthPolicies))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetClusterHealthUsingPolicySender sends the GetClusterHealthUsingPolicy request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetClusterHealthUsingPolicySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetClusterHealthUsingPolicyResponder handles the response to the GetClusterHealthUsingPolicy request. The method always
// closes the http.Response Body.
func (client BaseClient) GetClusterHealthUsingPolicyResponder(resp *http.Response) (result ClusterHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetClusterManifest get the Service Fabric cluster manifest. The cluster manifest contains properties of the cluster
// that include different node types on the cluster,
// security configurations, fault and upgrade domain topologies etc.
//
// These properties are specified as part of the ClusterConfig.JSON file while deploying a stand alone cluster.
// However, most of the information in the cluster manifest
// is generated internally by service fabric during cluster deployment in other deployment scenarios (for e.g when
// using azuer portal).
//
// The contents of the cluster manifest are for informational purposes only and users are not expected to take a
// dependency on the format of the file contents or its interpretation.
//
// timeout is the server timeout for performing the operation in seconds. This specifies the time duration that the
// client is willing to wait for the requested operation to complete. The default value for this parameter is 60
// seconds.
func (client BaseClient) GetClusterManifest(ctx context.Context, timeout *int64) (result ClusterManifest, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetClusterManifest")
	}

	req, err := client.GetClusterManifestPreparer(ctx, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterManifest", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetClusterManifestSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterManifest", resp, "Failure sending request")
		return
	}

	result, err = client.GetClusterManifestResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterManifest", resp, "Failure responding to request")
	}

	return
}

// GetClusterManifestPreparer prepares the GetClusterManifest request.
func (client BaseClient) GetClusterManifestPreparer(ctx context.Context, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/GetClusterManifest"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetClusterManifestSender sends the GetClusterManifest request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetClusterManifestSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetClusterManifestResponder handles the response to the GetClusterManifest request. The method always
// closes the http.Response Body.
func (client BaseClient) GetClusterManifestResponder(resp *http.Response) (result ClusterManifest, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetClusterUpgradeProgress gets the current progress of the ongoing cluster upgrade. If no upgrade is currently in
// progress, gets the last state of the previous cluster upgrade.
//
// timeout is the server timeout for performing the operation in seconds. This specifies the time duration that the
// client is willing to wait for the requested operation to complete. The default value for this parameter is 60
// seconds.
func (client BaseClient) GetClusterUpgradeProgress(ctx context.Context, timeout *int64) (result ClusterUpgradeProgressObject, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetClusterUpgradeProgress")
	}

	req, err := client.GetClusterUpgradeProgressPreparer(ctx, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterUpgradeProgress", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetClusterUpgradeProgressSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterUpgradeProgress", resp, "Failure sending request")
		return
	}

	result, err = client.GetClusterUpgradeProgressResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterUpgradeProgress", resp, "Failure responding to request")
	}

	return
}

// GetClusterUpgradeProgressPreparer prepares the GetClusterUpgradeProgress request.
func (client BaseClient) GetClusterUpgradeProgressPreparer(ctx context.Context, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/GetUpgradeProgress"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetClusterUpgradeProgressSender sends the GetClusterUpgradeProgress request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetClusterUpgradeProgressSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetClusterUpgradeProgressResponder handles the response to the GetClusterUpgradeProgress request. The method always
// closes the http.Response Body.
func (client BaseClient) GetClusterUpgradeProgressResponder(resp *http.Response) (result ClusterUpgradeProgressObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetComposeDeploymentStatus returns the status of the compose deployment that was created or in the process of being
// created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response
// includes the name, status and other details about the deployment.
//
// deploymentName is the identity of the deployment. timeout is the server timeout for performing the operation in
// seconds. This specifies the time duration that the client is willing to wait for the requested operation to
// complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetComposeDeploymentStatus(ctx context.Context, deploymentName string, timeout *int64) (result ComposeDeploymentStatusInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetComposeDeploymentStatus")
	}

	req, err := client.GetComposeDeploymentStatusPreparer(ctx, deploymentName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetComposeDeploymentStatus", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetComposeDeploymentStatusSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetComposeDeploymentStatus", resp, "Failure sending request")
		return
	}

	result, err = client.GetComposeDeploymentStatusResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetComposeDeploymentStatus", resp, "Failure responding to request")
	}

	return
}

// GetComposeDeploymentStatusPreparer prepares the GetComposeDeploymentStatus request.
func (client BaseClient) GetComposeDeploymentStatusPreparer(ctx context.Context, deploymentName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"deploymentName": deploymentName,
	}

	const APIVersion = "6.0-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ComposeDeployments/{deploymentName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetComposeDeploymentStatusSender sends the GetComposeDeploymentStatus request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetComposeDeploymentStatusSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetComposeDeploymentStatusResponder handles the response to the GetComposeDeploymentStatus request. The method always
// closes the http.Response Body.
func (client BaseClient) GetComposeDeploymentStatusResponder(resp *http.Response) (result ComposeDeploymentStatusInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetComposeDeploymentStatusList gets the status about the compose deployments that were created or in the process of
// being created in the Service Fabric cluster. The response includes the name, status and other details about the
// compose deployments. If the list of deployments do not fit in a page, one page of results is returned as well as a
// continuation token which can be used to get the next page.
//
// continuationToken is the continuation token parameter is used to obtain next set of results. A continuation token
// with a non empty value is included in the response of the API when the results from the system do not fit in a
// single response. When this value is passed to the next API call, the API returns next set of results. If there are
// no further results then the continuation token does not contain a value. The value of this parameter should not be
// URL encoded. maxResults is the maximum number of results to be returned as part of the paged queries. This parameter
// defines the upper bound on the number of results returned. The results returned can be less than the specified
// maximum results if they do not fit in the message as per the max message size restrictions defined in the
// configuration. If this parameter is zero or not specified, the paged queries includes as much results as possible
// that fit in the return message. timeout is the server timeout for performing the operation in seconds. This
// specifies the time duration that the client is willing to wait for the requested operation to complete. The default
// value for this parameter is 60 seconds.
func (client BaseClient) GetComposeDeploymentStatusList(ctx context.Context, continuationToken string, maxResults *int64, timeout *int64) (result PagedComposeDeploymentStatusInfoList, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: maxResults,
			Constraints: []validation.Constraint{{Target: "maxResults", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "maxResults", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil}}}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetComposeDeploymentStatusList")
	}

	req, err := client.GetComposeDeploymentStatusListPreparer(ctx, continuationToken, maxResults, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetComposeDeploymentStatusList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetComposeDeploymentStatusListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetComposeDeploymentStatusList", resp, "Failure sending request")
		return
	}

	result, err = client.GetComposeDeploymentStatusListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetComposeDeploymentStatusList", resp, "Failure responding to request")
	}

	return
}

// GetComposeDeploymentStatusListPreparer prepares the GetComposeDeploymentStatusList request.
func (client BaseClient) GetComposeDeploymentStatusListPreparer(ctx context.Context, continuationToken string, maxResults *int64, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(continuationToken) > 0 {
		queryParameters["ContinuationToken"] = continuationToken
	}
	if maxResults != nil {
		queryParameters["MaxResults"] = autorest.Encode("query", *maxResults)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/ComposeDeployments"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetComposeDeploymentStatusListSender sends the GetComposeDeploymentStatusList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetComposeDeploymentStatusListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetComposeDeploymentStatusListResponder handles the response to the GetComposeDeploymentStatusList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetComposeDeploymentStatusListResponder(resp *http.Response) (result PagedComposeDeploymentStatusInfoList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetComposeDeploymentUpgradeProgress returns the information about the state of the compose deployment upgrade along
// with details to aid debugging application health issues.
//
// deploymentName is the identity of the deployment. timeout is the server timeout for performing the operation in
// seconds. This specifies the time duration that the client is willing to wait for the requested operation to
// complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetComposeDeploymentUpgradeProgress(ctx context.Context, deploymentName string, timeout *int64) (result ComposeDeploymentUpgradeProgressInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetComposeDeploymentUpgradeProgress")
	}

	req, err := client.GetComposeDeploymentUpgradeProgressPreparer(ctx, deploymentName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetComposeDeploymentUpgradeProgress", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetComposeDeploymentUpgradeProgressSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetComposeDeploymentUpgradeProgress", resp, "Failure sending request")
		return
	}

	result, err = client.GetComposeDeploymentUpgradeProgressResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetComposeDeploymentUpgradeProgress", resp, "Failure responding to request")
	}

	return
}

// GetComposeDeploymentUpgradeProgressPreparer prepares the GetComposeDeploymentUpgradeProgress request.
func (client BaseClient) GetComposeDeploymentUpgradeProgressPreparer(ctx context.Context, deploymentName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"deploymentName": deploymentName,
	}

	const APIVersion = "6.0-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ComposeDeployments/{deploymentName}/$/GetUpgradeProgress", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetComposeDeploymentUpgradeProgressSender sends the GetComposeDeploymentUpgradeProgress request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetComposeDeploymentUpgradeProgressSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetComposeDeploymentUpgradeProgressResponder handles the response to the GetComposeDeploymentUpgradeProgress request. The method always
// closes the http.Response Body.
func (client BaseClient) GetComposeDeploymentUpgradeProgressResponder(resp *http.Response) (result ComposeDeploymentUpgradeProgressInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDataLossProgress gets the progress of a data loss operation started with StartDataLoss, using the OperationId.
//
// serviceID is the identity of the service. This is typically the full name of the service without the 'fabric:' URI
// scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the
// service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and
// "myapp/app1/svc1" in previous versions. partitionID is the identity of the partition. operationID is a GUID that
// identifies a call of this API.  This is passed into the corresponding GetProgress API timeout is the server timeout
// for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the
// requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetDataLossProgress(ctx context.Context, serviceID string, partitionID uuid.UUID, operationID uuid.UUID, timeout *int64) (result PartitionDataLossProgress, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetDataLossProgress")
	}

	req, err := client.GetDataLossProgressPreparer(ctx, serviceID, partitionID, operationID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDataLossProgress", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDataLossProgressSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDataLossProgress", resp, "Failure sending request")
		return
	}

	result, err = client.GetDataLossProgressResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDataLossProgress", resp, "Failure responding to request")
	}

	return
}

// GetDataLossProgressPreparer prepares the GetDataLossProgress request.
func (client BaseClient) GetDataLossProgressPreparer(ctx context.Context, serviceID string, partitionID uuid.UUID, operationID uuid.UUID, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
		"serviceId":   serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"OperationId": autorest.Encode("query", operationID),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/GetDataLossProgress", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDataLossProgressSender sends the GetDataLossProgress request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDataLossProgressSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDataLossProgressResponder handles the response to the GetDataLossProgress request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDataLossProgressResponder(resp *http.Response) (result PartitionDataLossProgress, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDeployedApplicationHealth gets the information about health of an application deployed on a Service Fabric node.
// Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed
// application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for
// DeployedServicePackageHealth children based on health state.
//
// nodeName is the name of the node. applicationID is the identity of the application. This is typically the full name
// of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited
// with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity
// would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions. eventsHealthStateFilter is allows filtering the
// collection of HealthEvent objects returned based on health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a
// combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of
// the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// deployedServicePackagesHealthStateFilter is allows filtering of the deployed service package health state objects
// returned in the result of deployed application health query based on their health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only deployed service packages that match the filter are returned. All deployed service packages are used to
// evaluate the aggregated health state of the deployed application.
// If not specified, all entries are returned.
// The state values are flag based enumeration, so the value can be a combination of these value obtained using bitwise
// 'OR' operator.
// For example, if the provided value is 6 then health state of service packages with HealthState value of OK (2) and
// Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. excludeHealthStatistics is
// indicates whether the health statistics should be returned as part of the query result. False by default.
// The statistics show the number of children entities in health state Ok, Warning, and Error. timeout is the server
// timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait
// for the requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetDeployedApplicationHealth(ctx context.Context, nodeName string, applicationID string, eventsHealthStateFilter *int32, deployedServicePackagesHealthStateFilter *int32, excludeHealthStatistics *bool, timeout *int64) (result DeployedApplicationHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetDeployedApplicationHealth")
	}

	req, err := client.GetDeployedApplicationHealthPreparer(ctx, nodeName, applicationID, eventsHealthStateFilter, deployedServicePackagesHealthStateFilter, excludeHealthStatistics, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedApplicationHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedApplicationHealthSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedApplicationHealth", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedApplicationHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedApplicationHealth", resp, "Failure responding to request")
	}

	return
}

// GetDeployedApplicationHealthPreparer prepares the GetDeployedApplicationHealth request.
func (client BaseClient) GetDeployedApplicationHealthPreparer(ctx context.Context, nodeName string, applicationID string, eventsHealthStateFilter *int32, deployedServicePackagesHealthStateFilter *int32, excludeHealthStatistics *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
		"nodeName":      autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	}
	if deployedServicePackagesHealthStateFilter != nil {
		queryParameters["DeployedServicePackagesHealthStateFilter"] = autorest.Encode("query", *deployedServicePackagesHealthStateFilter)
	}
	if excludeHealthStatistics != nil {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", *excludeHealthStatistics)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDeployedApplicationHealthSender sends the GetDeployedApplicationHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedApplicationHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDeployedApplicationHealthResponder handles the response to the GetDeployedApplicationHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedApplicationHealthResponder(resp *http.Response) (result DeployedApplicationHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDeployedApplicationHealthUsingPolicy gets the information about health of an application deployed on a Service
// Fabric node using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of
// HealthEvent objects reported on the deployed application based on health state. Use
// DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on
// health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health.
// This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored
// while evaluating the health of the deployed application.
//
// nodeName is the name of the node. applicationID is the identity of the application. This is typically the full name
// of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited
// with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity
// would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions. eventsHealthStateFilter is allows filtering the
// collection of HealthEvent objects returned based on health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a
// combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of
// the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// deployedServicePackagesHealthStateFilter is allows filtering of the deployed service package health state objects
// returned in the result of deployed application health query based on their health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only deployed service packages that match the filter are returned. All deployed service packages are used to
// evaluate the aggregated health state of the deployed application.
// If not specified, all entries are returned.
// The state values are flag based enumeration, so the value can be a combination of these value obtained using bitwise
// 'OR' operator.
// For example, if the provided value is 6 then health state of service packages with HealthState value of OK (2) and
// Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. applicationHealthPolicy is
// describes the health policies used to evaluate the health of an application or one of its children.
// If not present, the health evaluation uses the health policy from application manifest or the default health policy.
// excludeHealthStatistics is indicates whether the health statistics should be returned as part of the query result.
// False by default.
// The statistics show the number of children entities in health state Ok, Warning, and Error. timeout is the server
// timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait
// for the requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetDeployedApplicationHealthUsingPolicy(ctx context.Context, nodeName string, applicationID string, eventsHealthStateFilter *int32, deployedServicePackagesHealthStateFilter *int32, applicationHealthPolicy *ApplicationHealthPolicy, excludeHealthStatistics *bool, timeout *int64) (result DeployedApplicationHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetDeployedApplicationHealthUsingPolicy")
	}

	req, err := client.GetDeployedApplicationHealthUsingPolicyPreparer(ctx, nodeName, applicationID, eventsHealthStateFilter, deployedServicePackagesHealthStateFilter, applicationHealthPolicy, excludeHealthStatistics, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedApplicationHealthUsingPolicy", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedApplicationHealthUsingPolicySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedApplicationHealthUsingPolicy", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedApplicationHealthUsingPolicyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedApplicationHealthUsingPolicy", resp, "Failure responding to request")
	}

	return
}

// GetDeployedApplicationHealthUsingPolicyPreparer prepares the GetDeployedApplicationHealthUsingPolicy request.
func (client BaseClient) GetDeployedApplicationHealthUsingPolicyPreparer(ctx context.Context, nodeName string, applicationID string, eventsHealthStateFilter *int32, deployedServicePackagesHealthStateFilter *int32, applicationHealthPolicy *ApplicationHealthPolicy, excludeHealthStatistics *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
		"nodeName":      autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	}
	if deployedServicePackagesHealthStateFilter != nil {
		queryParameters["DeployedServicePackagesHealthStateFilter"] = autorest.Encode("query", *deployedServicePackagesHealthStateFilter)
	}
	if excludeHealthStatistics != nil {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", *excludeHealthStatistics)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if applicationHealthPolicy != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(applicationHealthPolicy))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDeployedApplicationHealthUsingPolicySender sends the GetDeployedApplicationHealthUsingPolicy request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedApplicationHealthUsingPolicySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDeployedApplicationHealthUsingPolicyResponder handles the response to the GetDeployedApplicationHealthUsingPolicy request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedApplicationHealthUsingPolicyResponder(resp *http.Response) (result DeployedApplicationHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDeployedApplicationInfo gets the information about an application deployed on a Service Fabric node.
//
// nodeName is the name of the node. applicationID is the identity of the application. This is typically the full name
// of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited
// with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity
// would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions. timeout is the server timeout for performing
// the operation in seconds. This specifies the time duration that the client is willing to wait for the requested
// operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetDeployedApplicationInfo(ctx context.Context, nodeName string, applicationID string, timeout *int64) (result DeployedApplicationInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetDeployedApplicationInfo")
	}

	req, err := client.GetDeployedApplicationInfoPreparer(ctx, nodeName, applicationID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedApplicationInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedApplicationInfoSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedApplicationInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedApplicationInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedApplicationInfo", resp, "Failure responding to request")
	}

	return
}

// GetDeployedApplicationInfoPreparer prepares the GetDeployedApplicationInfo request.
func (client BaseClient) GetDeployedApplicationInfoPreparer(ctx context.Context, nodeName string, applicationID string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
		"nodeName":      autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDeployedApplicationInfoSender sends the GetDeployedApplicationInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedApplicationInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDeployedApplicationInfoResponder handles the response to the GetDeployedApplicationInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedApplicationInfoResponder(resp *http.Response) (result DeployedApplicationInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDeployedApplicationInfoList gets the list of applications deployed on a Service Fabric node.
//
// nodeName is the name of the node. timeout is the server timeout for performing the operation in seconds. This
// specifies the time duration that the client is willing to wait for the requested operation to complete. The default
// value for this parameter is 60 seconds.
func (client BaseClient) GetDeployedApplicationInfoList(ctx context.Context, nodeName string, timeout *int64) (result ListDeployedApplicationInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetDeployedApplicationInfoList")
	}

	req, err := client.GetDeployedApplicationInfoListPreparer(ctx, nodeName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedApplicationInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedApplicationInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedApplicationInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedApplicationInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedApplicationInfoList", resp, "Failure responding to request")
	}

	return
}

// GetDeployedApplicationInfoListPreparer prepares the GetDeployedApplicationInfoList request.
func (client BaseClient) GetDeployedApplicationInfoListPreparer(ctx context.Context, nodeName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDeployedApplicationInfoListSender sends the GetDeployedApplicationInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedApplicationInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDeployedApplicationInfoListResponder handles the response to the GetDeployedApplicationInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedApplicationInfoListResponder(resp *http.Response) (result ListDeployedApplicationInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDeployedCodePackageInfoList gets the list of code packages deployed on a Service Fabric node for the given
// application.
//
// nodeName is the name of the node. applicationID is the identity of the application. This is typically the full name
// of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited
// with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity
// would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions. serviceManifestName is the name of a service
// manifest registered as part of an application type in a Service Fabric cluster. codePackageName is the name of code
// package specified in service manifest registered as part of an application type in a Service Fabric cluster. timeout
// is the server timeout for performing the operation in seconds. This specifies the time duration that the client is
// willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetDeployedCodePackageInfoList(ctx context.Context, nodeName string, applicationID string, serviceManifestName string, codePackageName string, timeout *int64) (result ListDeployedCodePackageInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetDeployedCodePackageInfoList")
	}

	req, err := client.GetDeployedCodePackageInfoListPreparer(ctx, nodeName, applicationID, serviceManifestName, codePackageName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedCodePackageInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedCodePackageInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedCodePackageInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedCodePackageInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedCodePackageInfoList", resp, "Failure responding to request")
	}

	return
}

// GetDeployedCodePackageInfoListPreparer prepares the GetDeployedCodePackageInfoList request.
func (client BaseClient) GetDeployedCodePackageInfoListPreparer(ctx context.Context, nodeName string, applicationID string, serviceManifestName string, codePackageName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
		"nodeName":      autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(serviceManifestName) > 0 {
		queryParameters["ServiceManifestName"] = autorest.Encode("query", serviceManifestName)
	}
	if len(codePackageName) > 0 {
		queryParameters["CodePackageName"] = autorest.Encode("query", codePackageName)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetCodePackages", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDeployedCodePackageInfoListSender sends the GetDeployedCodePackageInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedCodePackageInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDeployedCodePackageInfoListResponder handles the response to the GetDeployedCodePackageInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedCodePackageInfoListResponder(resp *http.Response) (result ListDeployedCodePackageInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDeployedServicePackageHealth gets the information about health of service package for a specific application
// deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of
// HealthEvent objects reported on the deployed service package based on health state.
//
// nodeName is the name of the node. applicationID is the identity of the application. This is typically the full name
// of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited
// with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity
// would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions. servicePackageName is the name of the service
// package. eventsHealthStateFilter is allows filtering the collection of HealthEvent objects returned based on health
// state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a
// combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of
// the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. timeout is the server timeout for
// performing the operation in seconds. This specifies the time duration that the client is willing to wait for the
// requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetDeployedServicePackageHealth(ctx context.Context, nodeName string, applicationID string, servicePackageName string, eventsHealthStateFilter *int32, timeout *int64) (result DeployedServicePackageHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetDeployedServicePackageHealth")
	}

	req, err := client.GetDeployedServicePackageHealthPreparer(ctx, nodeName, applicationID, servicePackageName, eventsHealthStateFilter, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServicePackageHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedServicePackageHealthSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServicePackageHealth", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedServicePackageHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServicePackageHealth", resp, "Failure responding to request")
	}

	return
}

// GetDeployedServicePackageHealthPreparer prepares the GetDeployedServicePackageHealth request.
func (client BaseClient) GetDeployedServicePackageHealthPreparer(ctx context.Context, nodeName string, applicationID string, servicePackageName string, eventsHealthStateFilter *int32, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId":      applicationID,
		"nodeName":           autorest.Encode("path", nodeName),
		"servicePackageName": servicePackageName,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDeployedServicePackageHealthSender sends the GetDeployedServicePackageHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedServicePackageHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDeployedServicePackageHealthResponder handles the response to the GetDeployedServicePackageHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedServicePackageHealthResponder(resp *http.Response) (result DeployedServicePackageHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDeployedServicePackageHealthUsingPolicy gets the information about health of an service package for a specific
// application deployed on a Service Fabric node. using the specified policy. Use EventsHealthStateFilter to optionally
// filter for the collection of HealthEvent objects reported on the deployed service package based on health state. Use
// ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses
// 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating
// the health of the deployed service package.
//
// nodeName is the name of the node. applicationID is the identity of the application. This is typically the full name
// of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited
// with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity
// would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions. servicePackageName is the name of the service
// package. eventsHealthStateFilter is allows filtering the collection of HealthEvent objects returned based on health
// state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a
// combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of
// the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. applicationHealthPolicy is
// describes the health policies used to evaluate the health of an application or one of its children.
// If not present, the health evaluation uses the health policy from application manifest or the default health policy.
// timeout is the server timeout for performing the operation in seconds. This specifies the time duration that the
// client is willing to wait for the requested operation to complete. The default value for this parameter is 60
// seconds.
func (client BaseClient) GetDeployedServicePackageHealthUsingPolicy(ctx context.Context, nodeName string, applicationID string, servicePackageName string, eventsHealthStateFilter *int32, applicationHealthPolicy *ApplicationHealthPolicy, timeout *int64) (result DeployedServicePackageHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetDeployedServicePackageHealthUsingPolicy")
	}

	req, err := client.GetDeployedServicePackageHealthUsingPolicyPreparer(ctx, nodeName, applicationID, servicePackageName, eventsHealthStateFilter, applicationHealthPolicy, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServicePackageHealthUsingPolicy", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedServicePackageHealthUsingPolicySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServicePackageHealthUsingPolicy", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedServicePackageHealthUsingPolicyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServicePackageHealthUsingPolicy", resp, "Failure responding to request")
	}

	return
}

// GetDeployedServicePackageHealthUsingPolicyPreparer prepares the GetDeployedServicePackageHealthUsingPolicy request.
func (client BaseClient) GetDeployedServicePackageHealthUsingPolicyPreparer(ctx context.Context, nodeName string, applicationID string, servicePackageName string, eventsHealthStateFilter *int32, applicationHealthPolicy *ApplicationHealthPolicy, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId":      applicationID,
		"nodeName":           autorest.Encode("path", nodeName),
		"servicePackageName": servicePackageName,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if applicationHealthPolicy != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(applicationHealthPolicy))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDeployedServicePackageHealthUsingPolicySender sends the GetDeployedServicePackageHealthUsingPolicy request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedServicePackageHealthUsingPolicySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDeployedServicePackageHealthUsingPolicyResponder handles the response to the GetDeployedServicePackageHealthUsingPolicy request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedServicePackageHealthUsingPolicyResponder(resp *http.Response) (result DeployedServicePackageHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDeployedServicePackageInfoList returns the information about the service packages deployed on a Service Fabric
// node for the given application.
//
// nodeName is the name of the node. applicationID is the identity of the application. This is typically the full name
// of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited
// with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity
// would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions. timeout is the server timeout for performing
// the operation in seconds. This specifies the time duration that the client is willing to wait for the requested
// operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetDeployedServicePackageInfoList(ctx context.Context, nodeName string, applicationID string, timeout *int64) (result ListDeployedServicePackageInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetDeployedServicePackageInfoList")
	}

	req, err := client.GetDeployedServicePackageInfoListPreparer(ctx, nodeName, applicationID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServicePackageInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedServicePackageInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServicePackageInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedServicePackageInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServicePackageInfoList", resp, "Failure responding to request")
	}

	return
}

// GetDeployedServicePackageInfoListPreparer prepares the GetDeployedServicePackageInfoList request.
func (client BaseClient) GetDeployedServicePackageInfoListPreparer(ctx context.Context, nodeName string, applicationID string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
		"nodeName":      autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDeployedServicePackageInfoListSender sends the GetDeployedServicePackageInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedServicePackageInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDeployedServicePackageInfoListResponder handles the response to the GetDeployedServicePackageInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedServicePackageInfoListResponder(resp *http.Response) (result ListDeployedServicePackageInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDeployedServicePackageInfoListByName returns the information about the service packages deployed on a Service
// Fabric node for the given application. These results are of service packages whose name match exactly the service
// package name specified as the parameter.
//
// nodeName is the name of the node. applicationID is the identity of the application. This is typically the full name
// of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited
// with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity
// would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions. servicePackageName is the name of the service
// package. timeout is the server timeout for performing the operation in seconds. This specifies the time duration
// that the client is willing to wait for the requested operation to complete. The default value for this parameter is
// 60 seconds.
func (client BaseClient) GetDeployedServicePackageInfoListByName(ctx context.Context, nodeName string, applicationID string, servicePackageName string, timeout *int64) (result ListDeployedServicePackageInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetDeployedServicePackageInfoListByName")
	}

	req, err := client.GetDeployedServicePackageInfoListByNamePreparer(ctx, nodeName, applicationID, servicePackageName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServicePackageInfoListByName", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedServicePackageInfoListByNameSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServicePackageInfoListByName", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedServicePackageInfoListByNameResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServicePackageInfoListByName", resp, "Failure responding to request")
	}

	return
}

// GetDeployedServicePackageInfoListByNamePreparer prepares the GetDeployedServicePackageInfoListByName request.
func (client BaseClient) GetDeployedServicePackageInfoListByNamePreparer(ctx context.Context, nodeName string, applicationID string, servicePackageName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId":      applicationID,
		"nodeName":           autorest.Encode("path", nodeName),
		"servicePackageName": servicePackageName,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDeployedServicePackageInfoListByNameSender sends the GetDeployedServicePackageInfoListByName request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedServicePackageInfoListByNameSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDeployedServicePackageInfoListByNameResponder handles the response to the GetDeployedServicePackageInfoListByName request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedServicePackageInfoListByNameResponder(resp *http.Response) (result ListDeployedServicePackageInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDeployedServiceReplicaDetailInfo gets the details of the replica deployed on a Service Fabric node. The
// information include service kind, service name, current service operation, current service operation start date
// time, partition id, replica/instance id, reported load and other information.
//
// nodeName is the name of the node. partitionID is the identity of the partition. replicaID is the identifier of the
// replica. timeout is the server timeout for performing the operation in seconds. This specifies the time duration
// that the client is willing to wait for the requested operation to complete. The default value for this parameter is
// 60 seconds.
func (client BaseClient) GetDeployedServiceReplicaDetailInfo(ctx context.Context, nodeName string, partitionID uuid.UUID, replicaID string, timeout *int64) (result DeployedServiceReplicaDetailInfoModel, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetDeployedServiceReplicaDetailInfo")
	}

	req, err := client.GetDeployedServiceReplicaDetailInfoPreparer(ctx, nodeName, partitionID, replicaID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceReplicaDetailInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedServiceReplicaDetailInfoSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceReplicaDetailInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedServiceReplicaDetailInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceReplicaDetailInfo", resp, "Failure responding to request")
	}

	return
}

// GetDeployedServiceReplicaDetailInfoPreparer prepares the GetDeployedServiceReplicaDetailInfo request.
func (client BaseClient) GetDeployedServiceReplicaDetailInfoPreparer(ctx context.Context, nodeName string, partitionID uuid.UUID, replicaID string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName":    autorest.Encode("path", nodeName),
		"partitionId": partitionID,
		"replicaId":   replicaID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas/{replicaId}/$/GetDetail", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDeployedServiceReplicaDetailInfoSender sends the GetDeployedServiceReplicaDetailInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedServiceReplicaDetailInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDeployedServiceReplicaDetailInfoResponder handles the response to the GetDeployedServiceReplicaDetailInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedServiceReplicaDetailInfoResponder(resp *http.Response) (result DeployedServiceReplicaDetailInfoModel, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDeployedServiceReplicaDetailInfoByPartitionID gets the details of the replica deployed on a Service Fabric node.
// The information include service kind, service name, current service operation, current service operation start date
// time, partition id, replica/instance id, reported load and other information.
//
// nodeName is the name of the node. partitionID is the identity of the partition. timeout is the server timeout for
// performing the operation in seconds. This specifies the time duration that the client is willing to wait for the
// requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetDeployedServiceReplicaDetailInfoByPartitionID(ctx context.Context, nodeName string, partitionID uuid.UUID, timeout *int64) (result DeployedServiceReplicaDetailInfoModel, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetDeployedServiceReplicaDetailInfoByPartitionID")
	}

	req, err := client.GetDeployedServiceReplicaDetailInfoByPartitionIDPreparer(ctx, nodeName, partitionID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceReplicaDetailInfoByPartitionID", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedServiceReplicaDetailInfoByPartitionIDSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceReplicaDetailInfoByPartitionID", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedServiceReplicaDetailInfoByPartitionIDResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceReplicaDetailInfoByPartitionID", resp, "Failure responding to request")
	}

	return
}

// GetDeployedServiceReplicaDetailInfoByPartitionIDPreparer prepares the GetDeployedServiceReplicaDetailInfoByPartitionID request.
func (client BaseClient) GetDeployedServiceReplicaDetailInfoByPartitionIDPreparer(ctx context.Context, nodeName string, partitionID uuid.UUID, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName":    autorest.Encode("path", nodeName),
		"partitionId": partitionID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDeployedServiceReplicaDetailInfoByPartitionIDSender sends the GetDeployedServiceReplicaDetailInfoByPartitionID request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedServiceReplicaDetailInfoByPartitionIDSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDeployedServiceReplicaDetailInfoByPartitionIDResponder handles the response to the GetDeployedServiceReplicaDetailInfoByPartitionID request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedServiceReplicaDetailInfoByPartitionIDResponder(resp *http.Response) (result DeployedServiceReplicaDetailInfoModel, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDeployedServiceReplicaInfoList gets the list containing the information about replicas deployed on a Service
// Fabric node. The information include partition id, replica id, status of the replica, name of the service, name of
// the service type and other information. Use PartitionId or ServiceManifestName query parameters to return
// information about the deployed replicas matching the specified values for those parameters.
//
// nodeName is the name of the node. applicationID is the identity of the application. This is typically the full name
// of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited
// with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity
// would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions. partitionID is the identity of the partition.
// serviceManifestName is the name of a service manifest registered as part of an application type in a Service Fabric
// cluster. timeout is the server timeout for performing the operation in seconds. This specifies the time duration
// that the client is willing to wait for the requested operation to complete. The default value for this parameter is
// 60 seconds.
func (client BaseClient) GetDeployedServiceReplicaInfoList(ctx context.Context, nodeName string, applicationID string, partitionID *uuid.UUID, serviceManifestName string, timeout *int64) (result ListDeployedServiceReplicaInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetDeployedServiceReplicaInfoList")
	}

	req, err := client.GetDeployedServiceReplicaInfoListPreparer(ctx, nodeName, applicationID, partitionID, serviceManifestName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceReplicaInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedServiceReplicaInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceReplicaInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedServiceReplicaInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceReplicaInfoList", resp, "Failure responding to request")
	}

	return
}

// GetDeployedServiceReplicaInfoListPreparer prepares the GetDeployedServiceReplicaInfoList request.
func (client BaseClient) GetDeployedServiceReplicaInfoListPreparer(ctx context.Context, nodeName string, applicationID string, partitionID *uuid.UUID, serviceManifestName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
		"nodeName":      autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if partitionID != nil {
		queryParameters["PartitionId"] = autorest.Encode("query", *partitionID)
	}
	if len(serviceManifestName) > 0 {
		queryParameters["ServiceManifestName"] = autorest.Encode("query", serviceManifestName)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetReplicas", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDeployedServiceReplicaInfoListSender sends the GetDeployedServiceReplicaInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedServiceReplicaInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDeployedServiceReplicaInfoListResponder handles the response to the GetDeployedServiceReplicaInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedServiceReplicaInfoListResponder(resp *http.Response) (result ListDeployedServiceReplicaInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDeployedServiceTypeInfoByName gets the list containing the information about a specific service type from the
// applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its
// registration status, the code package that registered it and activation id of the service package. Each entry
// represents one activation of a service type, differentiated by the activation id.
//
// nodeName is the name of the node. applicationID is the identity of the application. This is typically the full name
// of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited
// with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity
// would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions. serviceTypeName is specifies the name of a
// Service Fabric service type. serviceManifestName is the name of the service manifest to filter the list of deployed
// service type information. If specified, the response will only contain the information about service types that are
// defined in this service manifest. timeout is the server timeout for performing the operation in seconds. This
// specifies the time duration that the client is willing to wait for the requested operation to complete. The default
// value for this parameter is 60 seconds.
func (client BaseClient) GetDeployedServiceTypeInfoByName(ctx context.Context, nodeName string, applicationID string, serviceTypeName string, serviceManifestName string, timeout *int64) (result ListDeployedServiceTypeInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetDeployedServiceTypeInfoByName")
	}

	req, err := client.GetDeployedServiceTypeInfoByNamePreparer(ctx, nodeName, applicationID, serviceTypeName, serviceManifestName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceTypeInfoByName", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedServiceTypeInfoByNameSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceTypeInfoByName", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedServiceTypeInfoByNameResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceTypeInfoByName", resp, "Failure responding to request")
	}

	return
}

// GetDeployedServiceTypeInfoByNamePreparer prepares the GetDeployedServiceTypeInfoByName request.
func (client BaseClient) GetDeployedServiceTypeInfoByNamePreparer(ctx context.Context, nodeName string, applicationID string, serviceTypeName string, serviceManifestName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId":   applicationID,
		"nodeName":        autorest.Encode("path", nodeName),
		"serviceTypeName": serviceTypeName,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(serviceManifestName) > 0 {
		queryParameters["ServiceManifestName"] = autorest.Encode("query", serviceManifestName)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServiceTypes/{serviceTypeName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDeployedServiceTypeInfoByNameSender sends the GetDeployedServiceTypeInfoByName request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedServiceTypeInfoByNameSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDeployedServiceTypeInfoByNameResponder handles the response to the GetDeployedServiceTypeInfoByName request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedServiceTypeInfoByNameResponder(resp *http.Response) (result ListDeployedServiceTypeInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDeployedServiceTypeInfoList gets the list containing the information about service types from the applications
// deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration
// status, the code package that registered it and activation id of the service package.
//
// nodeName is the name of the node. applicationID is the identity of the application. This is typically the full name
// of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited
// with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity
// would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions. serviceManifestName is the name of the service
// manifest to filter the list of deployed service type information. If specified, the response will only contain the
// information about service types that are defined in this service manifest. timeout is the server timeout for
// performing the operation in seconds. This specifies the time duration that the client is willing to wait for the
// requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetDeployedServiceTypeInfoList(ctx context.Context, nodeName string, applicationID string, serviceManifestName string, timeout *int64) (result ListDeployedServiceTypeInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetDeployedServiceTypeInfoList")
	}

	req, err := client.GetDeployedServiceTypeInfoListPreparer(ctx, nodeName, applicationID, serviceManifestName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceTypeInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedServiceTypeInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceTypeInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedServiceTypeInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceTypeInfoList", resp, "Failure responding to request")
	}

	return
}

// GetDeployedServiceTypeInfoListPreparer prepares the GetDeployedServiceTypeInfoList request.
func (client BaseClient) GetDeployedServiceTypeInfoListPreparer(ctx context.Context, nodeName string, applicationID string, serviceManifestName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
		"nodeName":      autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(serviceManifestName) > 0 {
		queryParameters["ServiceManifestName"] = autorest.Encode("query", serviceManifestName)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServiceTypes", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDeployedServiceTypeInfoListSender sends the GetDeployedServiceTypeInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedServiceTypeInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDeployedServiceTypeInfoListResponder handles the response to the GetDeployedServiceTypeInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedServiceTypeInfoListResponder(resp *http.Response) (result ListDeployedServiceTypeInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetFaultOperationList gets the a list of user-induced fault operations filtered by provided input.
//
// typeFilter is used to filter on OperationType for user-induced operations.
// 65535 - select all
// 1     - select PartitionDataLoss.
// 2     - select PartitionQuorumLoss.
// 4     - select PartitionRestart.
// 8     - select NodeTransition. stateFilter is used to filter on OperationState's for user-induced operations.
// 65535 - select All
// 1     - select Running
// 2     - select RollingBack
// 8     - select Completed
// 16    - select Faulted
// 32    - select Cancelled
// 64    - select ForceCancelled timeout is the server timeout for performing the operation in seconds. This specifies
// the time duration that the client is willing to wait for the requested operation to complete. The default value for
// this parameter is 60 seconds.
func (client BaseClient) GetFaultOperationList(ctx context.Context, typeFilter int32, stateFilter int32, timeout *int64) (result ListOperationStatus, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetFaultOperationList")
	}

	req, err := client.GetFaultOperationListPreparer(ctx, typeFilter, stateFilter, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetFaultOperationList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetFaultOperationListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetFaultOperationList", resp, "Failure sending request")
		return
	}

	result, err = client.GetFaultOperationListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetFaultOperationList", resp, "Failure responding to request")
	}

	return
}

// GetFaultOperationListPreparer prepares the GetFaultOperationList request.
func (client BaseClient) GetFaultOperationListPreparer(ctx context.Context, typeFilter int32, stateFilter int32, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"StateFilter": autorest.Encode("query", stateFilter),
		"TypeFilter":  autorest.Encode("query", typeFilter),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/Faults/"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetFaultOperationListSender sends the GetFaultOperationList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetFaultOperationListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetFaultOperationListResponder handles the response to the GetFaultOperationList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetFaultOperationListResponder(resp *http.Response) (result ListOperationStatus, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetImageStoreContent returns the information about the image store content at the specified contentPath relative to
// the root of the image store.
//
// contentPath is relative path to file or folder in the image store from its root. timeout is the server timeout for
// performing the operation in seconds. This specifies the time duration that the client is willing to wait for the
// requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetImageStoreContent(ctx context.Context, contentPath string, timeout *int64) (result ImageStoreContent, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetImageStoreContent")
	}

	req, err := client.GetImageStoreContentPreparer(ctx, contentPath, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetImageStoreContent", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetImageStoreContentSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetImageStoreContent", resp, "Failure sending request")
		return
	}

	result, err = client.GetImageStoreContentResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetImageStoreContent", resp, "Failure responding to request")
	}

	return
}

// GetImageStoreContentPreparer prepares the GetImageStoreContent request.
func (client BaseClient) GetImageStoreContentPreparer(ctx context.Context, contentPath string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"contentPath": autorest.Encode("path", contentPath),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ImageStore/{contentPath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetImageStoreContentSender sends the GetImageStoreContent request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetImageStoreContentSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetImageStoreContentResponder handles the response to the GetImageStoreContent request. The method always
// closes the http.Response Body.
func (client BaseClient) GetImageStoreContentResponder(resp *http.Response) (result ImageStoreContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetImageStoreRootContent returns the information about the image store content at the root of the image store.
//
// timeout is the server timeout for performing the operation in seconds. This specifies the time duration that the
// client is willing to wait for the requested operation to complete. The default value for this parameter is 60
// seconds.
func (client BaseClient) GetImageStoreRootContent(ctx context.Context, timeout *int64) (result ImageStoreContent, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetImageStoreRootContent")
	}

	req, err := client.GetImageStoreRootContentPreparer(ctx, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetImageStoreRootContent", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetImageStoreRootContentSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetImageStoreRootContent", resp, "Failure sending request")
		return
	}

	result, err = client.GetImageStoreRootContentResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetImageStoreRootContent", resp, "Failure responding to request")
	}

	return
}

// GetImageStoreRootContentPreparer prepares the GetImageStoreRootContent request.
func (client BaseClient) GetImageStoreRootContentPreparer(ctx context.Context, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/ImageStore"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetImageStoreRootContentSender sends the GetImageStoreRootContent request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetImageStoreRootContentSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetImageStoreRootContentResponder handles the response to the GetImageStoreRootContent request. The method always
// closes the http.Response Body.
func (client BaseClient) GetImageStoreRootContentResponder(resp *http.Response) (result ImageStoreContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetNameExistsInfo returns whether the specified Service Fabric name exists.
//
// nameID is the Service Fabric name, without the 'fabric:' URI scheme. timeout is the server timeout for performing
// the operation in seconds. This specifies the time duration that the client is willing to wait for the requested
// operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetNameExistsInfo(ctx context.Context, nameID string, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetNameExistsInfo")
	}

	req, err := client.GetNameExistsInfoPreparer(ctx, nameID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNameExistsInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNameExistsInfoSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNameExistsInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetNameExistsInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNameExistsInfo", resp, "Failure responding to request")
	}

	return
}

// GetNameExistsInfoPreparer prepares the GetNameExistsInfo request.
func (client BaseClient) GetNameExistsInfoPreparer(ctx context.Context, nameID string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nameId": nameID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Names/{nameId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetNameExistsInfoSender sends the GetNameExistsInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetNameExistsInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetNameExistsInfoResponder handles the response to the GetNameExistsInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetNameExistsInfoResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// GetNodeHealth gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of
// health events reported on the node based on the health state. If the node that you specify by name does not exist in
// the health store, this returns an error.
//
// nodeName is the name of the node. eventsHealthStateFilter is allows filtering the collection of HealthEvent objects
// returned based on health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a
// combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of
// the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. timeout is the server timeout for
// performing the operation in seconds. This specifies the time duration that the client is willing to wait for the
// requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetNodeHealth(ctx context.Context, nodeName string, eventsHealthStateFilter *int32, timeout *int64) (result NodeHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetNodeHealth")
	}

	req, err := client.GetNodeHealthPreparer(ctx, nodeName, eventsHealthStateFilter, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNodeHealthSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeHealth", resp, "Failure sending request")
		return
	}

	result, err = client.GetNodeHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeHealth", resp, "Failure responding to request")
	}

	return
}

// GetNodeHealthPreparer prepares the GetNodeHealth request.
func (client BaseClient) GetNodeHealthPreparer(ctx context.Context, nodeName string, eventsHealthStateFilter *int32, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetNodeHealthSender sends the GetNodeHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetNodeHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetNodeHealthResponder handles the response to the GetNodeHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) GetNodeHealthResponder(resp *http.Response) (result NodeHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetNodeHealthUsingPolicy gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the
// collection of health events reported on the node based on the health state. Use ClusterHealthPolicy in the POST body
// to override the health policies used to evaluate the health. If the node that you specify by name does not exist in
// the health store, this returns an error.
//
// nodeName is the name of the node. eventsHealthStateFilter is allows filtering the collection of HealthEvent objects
// returned based on health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a
// combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of
// the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. clusterHealthPolicy is describes
// the health policies used to evaluate the health of a cluster or node. If not present, the health evaluation uses the
// health policy from cluster manifest or the default health policy. timeout is the server timeout for performing the
// operation in seconds. This specifies the time duration that the client is willing to wait for the requested
// operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetNodeHealthUsingPolicy(ctx context.Context, nodeName string, eventsHealthStateFilter *int32, clusterHealthPolicy *ClusterHealthPolicy, timeout *int64) (result NodeHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetNodeHealthUsingPolicy")
	}

	req, err := client.GetNodeHealthUsingPolicyPreparer(ctx, nodeName, eventsHealthStateFilter, clusterHealthPolicy, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeHealthUsingPolicy", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNodeHealthUsingPolicySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeHealthUsingPolicy", resp, "Failure sending request")
		return
	}

	result, err = client.GetNodeHealthUsingPolicyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeHealthUsingPolicy", resp, "Failure responding to request")
	}

	return
}

// GetNodeHealthUsingPolicyPreparer prepares the GetNodeHealthUsingPolicy request.
func (client BaseClient) GetNodeHealthUsingPolicyPreparer(ctx context.Context, nodeName string, eventsHealthStateFilter *int32, clusterHealthPolicy *ClusterHealthPolicy, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if clusterHealthPolicy != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(clusterHealthPolicy))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetNodeHealthUsingPolicySender sends the GetNodeHealthUsingPolicy request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetNodeHealthUsingPolicySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetNodeHealthUsingPolicyResponder handles the response to the GetNodeHealthUsingPolicy request. The method always
// closes the http.Response Body.
func (client BaseClient) GetNodeHealthUsingPolicyResponder(resp *http.Response) (result NodeHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetNodeInfo gets the information about a specific node in the Service Fabric Cluster.The respons include the name,
// status, id, health, uptime and other details about the node.
//
// nodeName is the name of the node. timeout is the server timeout for performing the operation in seconds. This
// specifies the time duration that the client is willing to wait for the requested operation to complete. The default
// value for this parameter is 60 seconds.
func (client BaseClient) GetNodeInfo(ctx context.Context, nodeName string, timeout *int64) (result NodeInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetNodeInfo")
	}

	req, err := client.GetNodeInfoPreparer(ctx, nodeName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNodeInfoSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetNodeInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeInfo", resp, "Failure responding to request")
	}

	return
}

// GetNodeInfoPreparer prepares the GetNodeInfo request.
func (client BaseClient) GetNodeInfoPreparer(ctx context.Context, nodeName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetNodeInfoSender sends the GetNodeInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetNodeInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetNodeInfoResponder handles the response to the GetNodeInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetNodeInfoResponder(resp *http.Response) (result NodeInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetNodeInfoList the Nodes endpoint returns information about the nodes in the Service Fabric Cluster. The respons
// include the name, status, id, health, uptime and other details about the node.
//
// continuationToken is the continuation token parameter is used to obtain next set of results. A continuation token
// with a non empty value is included in the response of the API when the results from the system do not fit in a
// single response. When this value is passed to the next API call, the API returns next set of results. If there are
// no further results then the continuation token does not contain a value. The value of this parameter should not be
// URL encoded. nodeStatusFilter is allows filtering the nodes based on the NodeStatus. Only the nodes that are
// matching the specified filter value will be returned. The filter value can be one of the following.
//
// - default - This filter value will match all of the nodes excepts the ones with with status as Unknown or Removed.
// - all - This filter value will match all of the nodes.
// - up - This filter value will match nodes that are Up.
// - down - This filter value will match nodes that are Down.
// - enabling - This filter value will match nodes that are in the process of being enabled with status as Enabling.
// - disabling - This filter value will match nodes that are in the process of being disabled with status as Disabling.
// - disabled - This filter value will match nodes that are Disabled.
// - unknown - This filter value will match nodes whose status is Unknown. A node would be in Unknown state if Service
// Fabric does not have authoritative information about that node. This can happen if the system learns about a node at
// runtime.
// - removed - This filter value will match nodes whose status is Removed. These are the nodes that are removed from
// the cluster using the RemoveNodeState API. timeout is the server timeout for performing the operation in seconds.
// This specifies the time duration that the client is willing to wait for the requested operation to complete. The
// default value for this parameter is 60 seconds.
func (client BaseClient) GetNodeInfoList(ctx context.Context, continuationToken string, nodeStatusFilter string, timeout *int64) (result PagedNodeInfoList, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetNodeInfoList")
	}

	req, err := client.GetNodeInfoListPreparer(ctx, continuationToken, nodeStatusFilter, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNodeInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetNodeInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeInfoList", resp, "Failure responding to request")
	}

	return
}

// GetNodeInfoListPreparer prepares the GetNodeInfoList request.
func (client BaseClient) GetNodeInfoListPreparer(ctx context.Context, continuationToken string, nodeStatusFilter string, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(continuationToken) > 0 {
		queryParameters["ContinuationToken"] = continuationToken
	}
	if len(string(nodeStatusFilter)) > 0 {
		queryParameters["NodeStatusFilter"] = autorest.Encode("query", nodeStatusFilter)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/Nodes"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetNodeInfoListSender sends the GetNodeInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetNodeInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetNodeInfoListResponder handles the response to the GetNodeInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetNodeInfoListResponder(resp *http.Response) (result PagedNodeInfoList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetNodeLoadInfo gets the load information of a Service Fabric node.
//
// nodeName is the name of the node. timeout is the server timeout for performing the operation in seconds. This
// specifies the time duration that the client is willing to wait for the requested operation to complete. The default
// value for this parameter is 60 seconds.
func (client BaseClient) GetNodeLoadInfo(ctx context.Context, nodeName string, timeout *int64) (result NodeLoadInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetNodeLoadInfo")
	}

	req, err := client.GetNodeLoadInfoPreparer(ctx, nodeName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeLoadInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNodeLoadInfoSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeLoadInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetNodeLoadInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeLoadInfo", resp, "Failure responding to request")
	}

	return
}

// GetNodeLoadInfoPreparer prepares the GetNodeLoadInfo request.
func (client BaseClient) GetNodeLoadInfoPreparer(ctx context.Context, nodeName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetLoadInformation", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetNodeLoadInfoSender sends the GetNodeLoadInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetNodeLoadInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetNodeLoadInfoResponder handles the response to the GetNodeLoadInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetNodeLoadInfoResponder(resp *http.Response) (result NodeLoadInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetNodeTransitionProgress gets the progress of an operation started with StartNodeTransition using the provided
// OperationId.
//
// nodeName is the name of the node. operationID is a GUID that identifies a call of this API.  This is passed into the
// corresponding GetProgress API timeout is the server timeout for performing the operation in seconds. This specifies
// the time duration that the client is willing to wait for the requested operation to complete. The default value for
// this parameter is 60 seconds.
func (client BaseClient) GetNodeTransitionProgress(ctx context.Context, nodeName string, operationID uuid.UUID, timeout *int64) (result NodeTransitionProgress, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetNodeTransitionProgress")
	}

	req, err := client.GetNodeTransitionProgressPreparer(ctx, nodeName, operationID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeTransitionProgress", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNodeTransitionProgressSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeTransitionProgress", resp, "Failure sending request")
		return
	}

	result, err = client.GetNodeTransitionProgressResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeTransitionProgress", resp, "Failure responding to request")
	}

	return
}

// GetNodeTransitionProgressPreparer prepares the GetNodeTransitionProgress request.
func (client BaseClient) GetNodeTransitionProgressPreparer(ctx context.Context, nodeName string, operationID uuid.UUID, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"OperationId": autorest.Encode("query", operationID),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Faults/Nodes/{nodeName}/$/GetTransitionProgress", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetNodeTransitionProgressSender sends the GetNodeTransitionProgress request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetNodeTransitionProgressSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetNodeTransitionProgressResponder handles the response to the GetNodeTransitionProgress request. The method always
// closes the http.Response Body.
func (client BaseClient) GetNodeTransitionProgressResponder(resp *http.Response) (result NodeTransitionProgress, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetPartitionHealth gets the health information of the specified partition.
// Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health
// state.
// Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition.
// If you specify a partition that does not exist in the health store, this cmdlet returns an error.
//
// partitionID is the identity of the partition. eventsHealthStateFilter is allows filtering the collection of
// HealthEvent objects returned based on health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a
// combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of
// the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. replicasHealthStateFilter is
// allows filtering the collection of ReplicaHealthState objects on the partition. The value can be obtained from
// members or bitwise operations on members of HealthStateFilter. Only replicas that match the filter will be returned.
// All replicas will be used to evaluate the aggregated health state. If not specified, all entries will be
// returned.The state values are flag based enumeration, so the value could be a combination of these value obtained
// using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value
// of OK (2) and Warning (4) will be returned. The possible values for this parameter include integer value of one of
// the following health states.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. excludeHealthStatistics is
// indicates whether the health statistics should be returned as part of the query result. False by default.
// The statistics show the number of children entities in health state Ok, Warning, and Error. timeout is the server
// timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait
// for the requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetPartitionHealth(ctx context.Context, partitionID uuid.UUID, eventsHealthStateFilter *int32, replicasHealthStateFilter *int32, excludeHealthStatistics *bool, timeout *int64) (result PartitionHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetPartitionHealth")
	}

	req, err := client.GetPartitionHealthPreparer(ctx, partitionID, eventsHealthStateFilter, replicasHealthStateFilter, excludeHealthStatistics, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPartitionHealthSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionHealth", resp, "Failure sending request")
		return
	}

	result, err = client.GetPartitionHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionHealth", resp, "Failure responding to request")
	}

	return
}

// GetPartitionHealthPreparer prepares the GetPartitionHealth request.
func (client BaseClient) GetPartitionHealthPreparer(ctx context.Context, partitionID uuid.UUID, eventsHealthStateFilter *int32, replicasHealthStateFilter *int32, excludeHealthStatistics *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	}
	if replicasHealthStateFilter != nil {
		queryParameters["ReplicasHealthStateFilter"] = autorest.Encode("query", *replicasHealthStateFilter)
	}
	if excludeHealthStatistics != nil {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", *excludeHealthStatistics)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetPartitionHealthSender sends the GetPartitionHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetPartitionHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetPartitionHealthResponder handles the response to the GetPartitionHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) GetPartitionHealthResponder(resp *http.Response) (result PartitionHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetPartitionHealthUsingPolicy gets the health information of the specified partition.
// If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
// If the policy is not specified, the health evaluation uses the application health policy defined in the application
// manifest, or the default health policy, if no policy is defined in the manifest.
// Use EventsHealthStateFilter to filter the collection of health events reported on the partition based on the health
// state.
// Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition. Use
// ApplicationHealthPolicy in the POST body to override the health policies used to evaluate the health.
// If you specify a partition that does not exist in the health store, this cmdlet returns an error.
//
// partitionID is the identity of the partition. eventsHealthStateFilter is allows filtering the collection of
// HealthEvent objects returned based on health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a
// combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of
// the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. replicasHealthStateFilter is
// allows filtering the collection of ReplicaHealthState objects on the partition. The value can be obtained from
// members or bitwise operations on members of HealthStateFilter. Only replicas that match the filter will be returned.
// All replicas will be used to evaluate the aggregated health state. If not specified, all entries will be
// returned.The state values are flag based enumeration, so the value could be a combination of these value obtained
// using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value
// of OK (2) and Warning (4) will be returned. The possible values for this parameter include integer value of one of
// the following health states.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. applicationHealthPolicy is
// describes the health policies used to evaluate the health of an application or one of its children.
// If not present, the health evaluation uses the health policy from application manifest or the default health policy.
// excludeHealthStatistics is indicates whether the health statistics should be returned as part of the query result.
// False by default.
// The statistics show the number of children entities in health state Ok, Warning, and Error. timeout is the server
// timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait
// for the requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetPartitionHealthUsingPolicy(ctx context.Context, partitionID uuid.UUID, eventsHealthStateFilter *int32, replicasHealthStateFilter *int32, applicationHealthPolicy *ApplicationHealthPolicy, excludeHealthStatistics *bool, timeout *int64) (result PartitionHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetPartitionHealthUsingPolicy")
	}

	req, err := client.GetPartitionHealthUsingPolicyPreparer(ctx, partitionID, eventsHealthStateFilter, replicasHealthStateFilter, applicationHealthPolicy, excludeHealthStatistics, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionHealthUsingPolicy", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPartitionHealthUsingPolicySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionHealthUsingPolicy", resp, "Failure sending request")
		return
	}

	result, err = client.GetPartitionHealthUsingPolicyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionHealthUsingPolicy", resp, "Failure responding to request")
	}

	return
}

// GetPartitionHealthUsingPolicyPreparer prepares the GetPartitionHealthUsingPolicy request.
func (client BaseClient) GetPartitionHealthUsingPolicyPreparer(ctx context.Context, partitionID uuid.UUID, eventsHealthStateFilter *int32, replicasHealthStateFilter *int32, applicationHealthPolicy *ApplicationHealthPolicy, excludeHealthStatistics *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	}
	if replicasHealthStateFilter != nil {
		queryParameters["ReplicasHealthStateFilter"] = autorest.Encode("query", *replicasHealthStateFilter)
	}
	if excludeHealthStatistics != nil {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", *excludeHealthStatistics)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if applicationHealthPolicy != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(applicationHealthPolicy))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetPartitionHealthUsingPolicySender sends the GetPartitionHealthUsingPolicy request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetPartitionHealthUsingPolicySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetPartitionHealthUsingPolicyResponder handles the response to the GetPartitionHealthUsingPolicy request. The method always
// closes the http.Response Body.
func (client BaseClient) GetPartitionHealthUsingPolicyResponder(resp *http.Response) (result PartitionHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetPartitionInfo the Partitions endpoint returns information about the specified partition. The response include the
// partition id, partitioning scheme information, keys supported by the partition, status, health and other details
// about the partition.
//
// partitionID is the identity of the partition. timeout is the server timeout for performing the operation in seconds.
// This specifies the time duration that the client is willing to wait for the requested operation to complete. The
// default value for this parameter is 60 seconds.
func (client BaseClient) GetPartitionInfo(ctx context.Context, partitionID uuid.UUID, timeout *int64) (result ServicePartitionInfoModel, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetPartitionInfo")
	}

	req, err := client.GetPartitionInfoPreparer(ctx, partitionID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPartitionInfoSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetPartitionInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionInfo", resp, "Failure responding to request")
	}

	return
}

// GetPartitionInfoPreparer prepares the GetPartitionInfo request.
func (client BaseClient) GetPartitionInfoPreparer(ctx context.Context, partitionID uuid.UUID, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetPartitionInfoSender sends the GetPartitionInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetPartitionInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetPartitionInfoResponder handles the response to the GetPartitionInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetPartitionInfoResponder(resp *http.Response) (result ServicePartitionInfoModel, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetPartitionInfoList gets the list of partitions of a Service Fabric service. The response include the partition id,
// partitioning scheme information, keys supported by the partition, status, health and other details about the
// partition.
//
// serviceID is the identity of the service. This is typically the full name of the service without the 'fabric:' URI
// scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the
// service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and
// "myapp/app1/svc1" in previous versions. continuationToken is the continuation token parameter is used to obtain next
// set of results. A continuation token with a non empty value is included in the response of the API when the results
// from the system do not fit in a single response. When this value is passed to the next API call, the API returns
// next set of results. If there are no further results then the continuation token does not contain a value. The value
// of this parameter should not be URL encoded. timeout is the server timeout for performing the operation in seconds.
// This specifies the time duration that the client is willing to wait for the requested operation to complete. The
// default value for this parameter is 60 seconds.
func (client BaseClient) GetPartitionInfoList(ctx context.Context, serviceID string, continuationToken string, timeout *int64) (result PagedServicePartitionInfoList, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetPartitionInfoList")
	}

	req, err := client.GetPartitionInfoListPreparer(ctx, serviceID, continuationToken, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPartitionInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetPartitionInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionInfoList", resp, "Failure responding to request")
	}

	return
}

// GetPartitionInfoListPreparer prepares the GetPartitionInfoList request.
func (client BaseClient) GetPartitionInfoListPreparer(ctx context.Context, serviceID string, continuationToken string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"serviceId": serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(continuationToken) > 0 {
		queryParameters["ContinuationToken"] = continuationToken
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Services/{serviceId}/$/GetPartitions", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetPartitionInfoListSender sends the GetPartitionInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetPartitionInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetPartitionInfoListResponder handles the response to the GetPartitionInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetPartitionInfoListResponder(resp *http.Response) (result PagedServicePartitionInfoList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetPartitionLoadInformation returns information about the specified partition.
// The response includes a list of load information.
// Each information includes load metric name, value and last reported time in UTC.
//
// partitionID is the identity of the partition. timeout is the server timeout for performing the operation in seconds.
// This specifies the time duration that the client is willing to wait for the requested operation to complete. The
// default value for this parameter is 60 seconds.
func (client BaseClient) GetPartitionLoadInformation(ctx context.Context, partitionID uuid.UUID, timeout *int64) (result PartitionLoadInformation, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetPartitionLoadInformation")
	}

	req, err := client.GetPartitionLoadInformationPreparer(ctx, partitionID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionLoadInformation", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPartitionLoadInformationSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionLoadInformation", resp, "Failure sending request")
		return
	}

	result, err = client.GetPartitionLoadInformationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionLoadInformation", resp, "Failure responding to request")
	}

	return
}

// GetPartitionLoadInformationPreparer prepares the GetPartitionLoadInformation request.
func (client BaseClient) GetPartitionLoadInformationPreparer(ctx context.Context, partitionID uuid.UUID, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}/$/GetLoadInformation", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetPartitionLoadInformationSender sends the GetPartitionLoadInformation request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetPartitionLoadInformationSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetPartitionLoadInformationResponder handles the response to the GetPartitionLoadInformation request. The method always
// closes the http.Response Body.
func (client BaseClient) GetPartitionLoadInformationResponder(resp *http.Response) (result PartitionLoadInformation, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetPartitionRestartProgress gets the progress of a PartitionRestart started with StartPartitionRestart using the
// provided OperationId.
//
// serviceID is the identity of the service. This is typically the full name of the service without the 'fabric:' URI
// scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the
// service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and
// "myapp/app1/svc1" in previous versions. partitionID is the identity of the partition. operationID is a GUID that
// identifies a call of this API.  This is passed into the corresponding GetProgress API timeout is the server timeout
// for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the
// requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetPartitionRestartProgress(ctx context.Context, serviceID string, partitionID uuid.UUID, operationID uuid.UUID, timeout *int64) (result PartitionRestartProgress, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetPartitionRestartProgress")
	}

	req, err := client.GetPartitionRestartProgressPreparer(ctx, serviceID, partitionID, operationID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionRestartProgress", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPartitionRestartProgressSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionRestartProgress", resp, "Failure sending request")
		return
	}

	result, err = client.GetPartitionRestartProgressResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionRestartProgress", resp, "Failure responding to request")
	}

	return
}

// GetPartitionRestartProgressPreparer prepares the GetPartitionRestartProgress request.
func (client BaseClient) GetPartitionRestartProgressPreparer(ctx context.Context, serviceID string, partitionID uuid.UUID, operationID uuid.UUID, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
		"serviceId":   serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"OperationId": autorest.Encode("query", operationID),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/GetRestartProgress", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetPartitionRestartProgressSender sends the GetPartitionRestartProgress request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetPartitionRestartProgressSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetPartitionRestartProgressResponder handles the response to the GetPartitionRestartProgress request. The method always
// closes the http.Response Body.
func (client BaseClient) GetPartitionRestartProgressResponder(resp *http.Response) (result PartitionRestartProgress, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetPropertyInfo gets the specified Service Fabric property under a given name. This will always return both value
// and metadata.
//
// nameID is the Service Fabric name, without the 'fabric:' URI scheme. propertyName is specifies the name of the
// property to get. timeout is the server timeout for performing the operation in seconds. This specifies the time
// duration that the client is willing to wait for the requested operation to complete. The default value for this
// parameter is 60 seconds.
func (client BaseClient) GetPropertyInfo(ctx context.Context, nameID string, propertyName string, timeout *int64) (result PropertyInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetPropertyInfo")
	}

	req, err := client.GetPropertyInfoPreparer(ctx, nameID, propertyName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPropertyInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPropertyInfoSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPropertyInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetPropertyInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPropertyInfo", resp, "Failure responding to request")
	}

	return
}

// GetPropertyInfoPreparer prepares the GetPropertyInfo request.
func (client BaseClient) GetPropertyInfoPreparer(ctx context.Context, nameID string, propertyName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nameId": nameID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version":  APIVersion,
		"PropertyName": autorest.Encode("query", propertyName),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Names/{nameId}/$/GetProperty", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetPropertyInfoSender sends the GetPropertyInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetPropertyInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetPropertyInfoResponder handles the response to the GetPropertyInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetPropertyInfoResponder(resp *http.Response) (result PropertyInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetPropertyInfoList gets information on all Service Fabric properties under a given name.
//
// nameID is the Service Fabric name, without the 'fabric:' URI scheme. includeValues is allows specifying whether to
// include the values of the properties returned. True if values should be returned with the metadata; False to return
// only property metadata. continuationToken is the continuation token parameter is used to obtain next set of results.
// A continuation token with a non empty value is included in the response of the API when the results from the system
// do not fit in a single response. When this value is passed to the next API call, the API returns next set of
// results. If there are no further results then the continuation token does not contain a value. The value of this
// parameter should not be URL encoded. timeout is the server timeout for performing the operation in seconds. This
// specifies the time duration that the client is willing to wait for the requested operation to complete. The default
// value for this parameter is 60 seconds.
func (client BaseClient) GetPropertyInfoList(ctx context.Context, nameID string, includeValues *bool, continuationToken string, timeout *int64) (result PagedPropertyInfoList, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetPropertyInfoList")
	}

	req, err := client.GetPropertyInfoListPreparer(ctx, nameID, includeValues, continuationToken, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPropertyInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPropertyInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPropertyInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetPropertyInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPropertyInfoList", resp, "Failure responding to request")
	}

	return
}

// GetPropertyInfoListPreparer prepares the GetPropertyInfoList request.
func (client BaseClient) GetPropertyInfoListPreparer(ctx context.Context, nameID string, includeValues *bool, continuationToken string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nameId": nameID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if includeValues != nil {
		queryParameters["IncludeValues"] = autorest.Encode("query", *includeValues)
	}
	if len(continuationToken) > 0 {
		queryParameters["ContinuationToken"] = continuationToken
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Names/{nameId}/$/GetProperties", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetPropertyInfoListSender sends the GetPropertyInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetPropertyInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetPropertyInfoListResponder handles the response to the GetPropertyInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetPropertyInfoListResponder(resp *http.Response) (result PagedPropertyInfoList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetProvisionedFabricCodeVersionInfoList gets a list of information about fabric code versions that are provisioned
// in the cluster. The parameter CodeVersion can be used to optionally filter the output to only that particular
// version.
//
// codeVersion is the product version of Service Fabric. timeout is the server timeout for performing the operation in
// seconds. This specifies the time duration that the client is willing to wait for the requested operation to
// complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetProvisionedFabricCodeVersionInfoList(ctx context.Context, codeVersion string, timeout *int64) (result ListFabricCodeVersionInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetProvisionedFabricCodeVersionInfoList")
	}

	req, err := client.GetProvisionedFabricCodeVersionInfoListPreparer(ctx, codeVersion, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetProvisionedFabricCodeVersionInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetProvisionedFabricCodeVersionInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetProvisionedFabricCodeVersionInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetProvisionedFabricCodeVersionInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetProvisionedFabricCodeVersionInfoList", resp, "Failure responding to request")
	}

	return
}

// GetProvisionedFabricCodeVersionInfoListPreparer prepares the GetProvisionedFabricCodeVersionInfoList request.
func (client BaseClient) GetProvisionedFabricCodeVersionInfoListPreparer(ctx context.Context, codeVersion string, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(codeVersion) > 0 {
		queryParameters["CodeVersion"] = autorest.Encode("query", codeVersion)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/GetProvisionedCodeVersions"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetProvisionedFabricCodeVersionInfoListSender sends the GetProvisionedFabricCodeVersionInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetProvisionedFabricCodeVersionInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetProvisionedFabricCodeVersionInfoListResponder handles the response to the GetProvisionedFabricCodeVersionInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetProvisionedFabricCodeVersionInfoListResponder(resp *http.Response) (result ListFabricCodeVersionInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetProvisionedFabricConfigVersionInfoList gets a list of information about fabric config versions that are
// provisioned in the cluster. The parameter ConfigVersion can be used to optionally filter the output to only that
// particular version.
//
// configVersion is the config version of Service Fabric. timeout is the server timeout for performing the operation in
// seconds. This specifies the time duration that the client is willing to wait for the requested operation to
// complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetProvisionedFabricConfigVersionInfoList(ctx context.Context, configVersion string, timeout *int64) (result ListFabricConfigVersionInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetProvisionedFabricConfigVersionInfoList")
	}

	req, err := client.GetProvisionedFabricConfigVersionInfoListPreparer(ctx, configVersion, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetProvisionedFabricConfigVersionInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetProvisionedFabricConfigVersionInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetProvisionedFabricConfigVersionInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetProvisionedFabricConfigVersionInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetProvisionedFabricConfigVersionInfoList", resp, "Failure responding to request")
	}

	return
}

// GetProvisionedFabricConfigVersionInfoListPreparer prepares the GetProvisionedFabricConfigVersionInfoList request.
func (client BaseClient) GetProvisionedFabricConfigVersionInfoListPreparer(ctx context.Context, configVersion string, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(configVersion) > 0 {
		queryParameters["ConfigVersion"] = autorest.Encode("query", configVersion)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/GetProvisionedConfigVersions"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetProvisionedFabricConfigVersionInfoListSender sends the GetProvisionedFabricConfigVersionInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetProvisionedFabricConfigVersionInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetProvisionedFabricConfigVersionInfoListResponder handles the response to the GetProvisionedFabricConfigVersionInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetProvisionedFabricConfigVersionInfoListResponder(resp *http.Response) (result ListFabricConfigVersionInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetQuorumLossProgress gets the progress of a quorum loss operation started with StartQuorumLoss, using the provided
// OperationId.
//
// serviceID is the identity of the service. This is typically the full name of the service without the 'fabric:' URI
// scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the
// service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and
// "myapp/app1/svc1" in previous versions. partitionID is the identity of the partition. operationID is a GUID that
// identifies a call of this API.  This is passed into the corresponding GetProgress API timeout is the server timeout
// for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the
// requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetQuorumLossProgress(ctx context.Context, serviceID string, partitionID uuid.UUID, operationID uuid.UUID, timeout *int64) (result PartitionQuorumLossProgress, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetQuorumLossProgress")
	}

	req, err := client.GetQuorumLossProgressPreparer(ctx, serviceID, partitionID, operationID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetQuorumLossProgress", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetQuorumLossProgressSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetQuorumLossProgress", resp, "Failure sending request")
		return
	}

	result, err = client.GetQuorumLossProgressResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetQuorumLossProgress", resp, "Failure responding to request")
	}

	return
}

// GetQuorumLossProgressPreparer prepares the GetQuorumLossProgress request.
func (client BaseClient) GetQuorumLossProgressPreparer(ctx context.Context, serviceID string, partitionID uuid.UUID, operationID uuid.UUID, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
		"serviceId":   serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"OperationId": autorest.Encode("query", operationID),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/GetQuorumLossProgress", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetQuorumLossProgressSender sends the GetQuorumLossProgress request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetQuorumLossProgressSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetQuorumLossProgressResponder handles the response to the GetQuorumLossProgress request. The method always
// closes the http.Response Body.
func (client BaseClient) GetQuorumLossProgressResponder(resp *http.Response) (result PartitionQuorumLossProgress, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetRepairTaskList this API supports the Service Fabric platform; it is not meant to be used directly from your code.
//
// taskIDFilter is the repair task ID prefix to be matched. stateFilter is a bitwise-OR of the following values,
// specifying which task states should be included in the result list.
// - 1 - Created
// - 2 - Claimed
// - 4 - Preparing
// - 8 - Approved
// - 16 - Executing
// - 32 - Restoring
// - 64 - Completed executorFilter is the name of the repair executor whose claimed tasks should be included in the
// list.
func (client BaseClient) GetRepairTaskList(ctx context.Context, taskIDFilter string, stateFilter *int32, executorFilter string) (result ListRepairTask, err error) {
	req, err := client.GetRepairTaskListPreparer(ctx, taskIDFilter, stateFilter, executorFilter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetRepairTaskList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetRepairTaskListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetRepairTaskList", resp, "Failure sending request")
		return
	}

	result, err = client.GetRepairTaskListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetRepairTaskList", resp, "Failure responding to request")
	}

	return
}

// GetRepairTaskListPreparer prepares the GetRepairTaskList request.
func (client BaseClient) GetRepairTaskListPreparer(ctx context.Context, taskIDFilter string, stateFilter *int32, executorFilter string) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(taskIDFilter) > 0 {
		queryParameters["TaskIdFilter"] = autorest.Encode("query", taskIDFilter)
	}
	if stateFilter != nil {
		queryParameters["StateFilter"] = autorest.Encode("query", *stateFilter)
	}
	if len(executorFilter) > 0 {
		queryParameters["ExecutorFilter"] = autorest.Encode("query", executorFilter)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/GetRepairTaskList"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetRepairTaskListSender sends the GetRepairTaskList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetRepairTaskListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetRepairTaskListResponder handles the response to the GetRepairTaskList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetRepairTaskListResponder(resp *http.Response) (result ListRepairTask, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetReplicaHealth gets the health of a Service Fabric replica.
// Use EventsHealthStateFilter to filter the collection of health events reported on the replica based on the health
// state.
//
// partitionID is the identity of the partition. replicaID is the identifier of the replica. eventsHealthStateFilter is
// allows filtering the collection of HealthEvent objects returned based on health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a
// combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of
// the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. timeout is the server timeout for
// performing the operation in seconds. This specifies the time duration that the client is willing to wait for the
// requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetReplicaHealth(ctx context.Context, partitionID uuid.UUID, replicaID string, eventsHealthStateFilter *int32, timeout *int64) (result ReplicaHealthModel, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetReplicaHealth")
	}

	req, err := client.GetReplicaHealthPreparer(ctx, partitionID, replicaID, eventsHealthStateFilter, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetReplicaHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetReplicaHealthSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetReplicaHealth", resp, "Failure sending request")
		return
	}

	result, err = client.GetReplicaHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetReplicaHealth", resp, "Failure responding to request")
	}

	return
}

// GetReplicaHealthPreparer prepares the GetReplicaHealth request.
func (client BaseClient) GetReplicaHealthPreparer(ctx context.Context, partitionID uuid.UUID, replicaID string, eventsHealthStateFilter *int32, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
		"replicaId":   replicaID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}/$/GetReplicas/{replicaId}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetReplicaHealthSender sends the GetReplicaHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetReplicaHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetReplicaHealthResponder handles the response to the GetReplicaHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) GetReplicaHealthResponder(resp *http.Response) (result ReplicaHealthModel, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetReplicaHealthUsingPolicy gets the health of a Service Fabric stateful service replica or stateless service
// instance.
// Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health
// state.
// Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only
// uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while
// evaluating the health of the replica.
//
// partitionID is the identity of the partition. replicaID is the identifier of the replica. eventsHealthStateFilter is
// allows filtering the collection of HealthEvent objects returned based on health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a
// combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of
// the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. applicationHealthPolicy is
// describes the health policies used to evaluate the health of an application or one of its children.
// If not present, the health evaluation uses the health policy from application manifest or the default health policy.
// timeout is the server timeout for performing the operation in seconds. This specifies the time duration that the
// client is willing to wait for the requested operation to complete. The default value for this parameter is 60
// seconds.
func (client BaseClient) GetReplicaHealthUsingPolicy(ctx context.Context, partitionID uuid.UUID, replicaID string, eventsHealthStateFilter *int32, applicationHealthPolicy *ApplicationHealthPolicy, timeout *int64) (result ReplicaHealthModel, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetReplicaHealthUsingPolicy")
	}

	req, err := client.GetReplicaHealthUsingPolicyPreparer(ctx, partitionID, replicaID, eventsHealthStateFilter, applicationHealthPolicy, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetReplicaHealthUsingPolicy", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetReplicaHealthUsingPolicySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetReplicaHealthUsingPolicy", resp, "Failure sending request")
		return
	}

	result, err = client.GetReplicaHealthUsingPolicyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetReplicaHealthUsingPolicy", resp, "Failure responding to request")
	}

	return
}

// GetReplicaHealthUsingPolicyPreparer prepares the GetReplicaHealthUsingPolicy request.
func (client BaseClient) GetReplicaHealthUsingPolicyPreparer(ctx context.Context, partitionID uuid.UUID, replicaID string, eventsHealthStateFilter *int32, applicationHealthPolicy *ApplicationHealthPolicy, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
		"replicaId":   replicaID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}/$/GetReplicas/{replicaId}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if applicationHealthPolicy != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(applicationHealthPolicy))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetReplicaHealthUsingPolicySender sends the GetReplicaHealthUsingPolicy request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetReplicaHealthUsingPolicySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetReplicaHealthUsingPolicyResponder handles the response to the GetReplicaHealthUsingPolicy request. The method always
// closes the http.Response Body.
func (client BaseClient) GetReplicaHealthUsingPolicyResponder(resp *http.Response) (result ReplicaHealthModel, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetReplicaInfo the respons include the id, role, status, health, node name, uptime, and other details about the
// replica.
//
// partitionID is the identity of the partition. replicaID is the identifier of the replica. continuationToken is the
// continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is
// included in the response of the API when the results from the system do not fit in a single response. When this
// value is passed to the next API call, the API returns next set of results. If there are no further results then the
// continuation token does not contain a value. The value of this parameter should not be URL encoded. timeout is the
// server timeout for performing the operation in seconds. This specifies the time duration that the client is willing
// to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetReplicaInfo(ctx context.Context, partitionID uuid.UUID, replicaID string, continuationToken string, timeout *int64) (result ReplicaInfoModel, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetReplicaInfo")
	}

	req, err := client.GetReplicaInfoPreparer(ctx, partitionID, replicaID, continuationToken, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetReplicaInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetReplicaInfoSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetReplicaInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetReplicaInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetReplicaInfo", resp, "Failure responding to request")
	}

	return
}

// GetReplicaInfoPreparer prepares the GetReplicaInfo request.
func (client BaseClient) GetReplicaInfoPreparer(ctx context.Context, partitionID uuid.UUID, replicaID string, continuationToken string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
		"replicaId":   replicaID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(continuationToken) > 0 {
		queryParameters["ContinuationToken"] = continuationToken
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}/$/GetReplicas/{replicaId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetReplicaInfoSender sends the GetReplicaInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetReplicaInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetReplicaInfoResponder handles the response to the GetReplicaInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetReplicaInfoResponder(resp *http.Response) (result ReplicaInfoModel, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetReplicaInfoList the GetReplicas endpoint returns information about the replicas of the specified partition. The
// respons include the id, role, status, health, node name, uptime, and other details about the replica.
//
// partitionID is the identity of the partition. continuationToken is the continuation token parameter is used to
// obtain next set of results. A continuation token with a non empty value is included in the response of the API when
// the results from the system do not fit in a single response. When this value is passed to the next API call, the API
// returns next set of results. If there are no further results then the continuation token does not contain a value.
// The value of this parameter should not be URL encoded. timeout is the server timeout for performing the operation in
// seconds. This specifies the time duration that the client is willing to wait for the requested operation to
// complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetReplicaInfoList(ctx context.Context, partitionID uuid.UUID, continuationToken string, timeout *int64) (result PagedReplicaInfoList, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetReplicaInfoList")
	}

	req, err := client.GetReplicaInfoListPreparer(ctx, partitionID, continuationToken, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetReplicaInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetReplicaInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetReplicaInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetReplicaInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetReplicaInfoList", resp, "Failure responding to request")
	}

	return
}

// GetReplicaInfoListPreparer prepares the GetReplicaInfoList request.
func (client BaseClient) GetReplicaInfoListPreparer(ctx context.Context, partitionID uuid.UUID, continuationToken string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(continuationToken) > 0 {
		queryParameters["ContinuationToken"] = continuationToken
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}/$/GetReplicas", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetReplicaInfoListSender sends the GetReplicaInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetReplicaInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetReplicaInfoListResponder handles the response to the GetReplicaInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetReplicaInfoListResponder(resp *http.Response) (result PagedReplicaInfoList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetServiceDescription gets the description of an existing Service Fabric service. A service must be created before
// its description can be obtained.
//
// serviceID is the identity of the service. This is typically the full name of the service without the 'fabric:' URI
// scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the
// service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and
// "myapp/app1/svc1" in previous versions. timeout is the server timeout for performing the operation in seconds. This
// specifies the time duration that the client is willing to wait for the requested operation to complete. The default
// value for this parameter is 60 seconds.
func (client BaseClient) GetServiceDescription(ctx context.Context, serviceID string, timeout *int64) (result ServiceDescriptionModel, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetServiceDescription")
	}

	req, err := client.GetServiceDescriptionPreparer(ctx, serviceID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceDescription", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetServiceDescriptionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceDescription", resp, "Failure sending request")
		return
	}

	result, err = client.GetServiceDescriptionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceDescription", resp, "Failure responding to request")
	}

	return
}

// GetServiceDescriptionPreparer prepares the GetServiceDescription request.
func (client BaseClient) GetServiceDescriptionPreparer(ctx context.Context, serviceID string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"serviceId": serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Services/{serviceId}/$/GetDescription", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetServiceDescriptionSender sends the GetServiceDescription request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetServiceDescriptionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetServiceDescriptionResponder handles the response to the GetServiceDescription request. The method always
// closes the http.Response Body.
func (client BaseClient) GetServiceDescriptionResponder(resp *http.Response) (result ServiceDescriptionModel, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetServiceHealth gets the health information of the specified service.
// Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health
// state.
// Use PartitionsHealthStateFilter to filter the collection of partitions returned.
// If you specify a service that does not exist in the health store, this cmdlet returns an error.
//
// serviceID is the identity of the service. This is typically the full name of the service without the 'fabric:' URI
// scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the
// service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and
// "myapp/app1/svc1" in previous versions. eventsHealthStateFilter is allows filtering the collection of HealthEvent
// objects returned based on health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a
// combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of
// the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. partitionsHealthStateFilter is
// allows filtering of the partitions health state objects returned in the result of service health query based on
// their health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only partitions that match the filter are returned. All partitions are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a
// combination of these value
// obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of partitions with
// HealthState value of OK (2) and Warning (4) will be returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. excludeHealthStatistics is
// indicates whether the health statistics should be returned as part of the query result. False by default.
// The statistics show the number of children entities in health state Ok, Warning, and Error. timeout is the server
// timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait
// for the requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetServiceHealth(ctx context.Context, serviceID string, eventsHealthStateFilter *int32, partitionsHealthStateFilter *int32, excludeHealthStatistics *bool, timeout *int64) (result ServiceHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetServiceHealth")
	}

	req, err := client.GetServiceHealthPreparer(ctx, serviceID, eventsHealthStateFilter, partitionsHealthStateFilter, excludeHealthStatistics, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetServiceHealthSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceHealth", resp, "Failure sending request")
		return
	}

	result, err = client.GetServiceHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceHealth", resp, "Failure responding to request")
	}

	return
}

// GetServiceHealthPreparer prepares the GetServiceHealth request.
func (client BaseClient) GetServiceHealthPreparer(ctx context.Context, serviceID string, eventsHealthStateFilter *int32, partitionsHealthStateFilter *int32, excludeHealthStatistics *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"serviceId": serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	}
	if partitionsHealthStateFilter != nil {
		queryParameters["PartitionsHealthStateFilter"] = autorest.Encode("query", *partitionsHealthStateFilter)
	}
	if excludeHealthStatistics != nil {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", *excludeHealthStatistics)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Services/{serviceId}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetServiceHealthSender sends the GetServiceHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetServiceHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetServiceHealthResponder handles the response to the GetServiceHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) GetServiceHealthResponder(resp *http.Response) (result ServiceHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetServiceHealthUsingPolicy gets the health information of the specified service.
// If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
// If the policy is not specified, the health evaluation uses the application health policy defined in the application
// manifest, or the default health policy, if no policy is defined in the manifest.
// Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health
// state.
// Use PartitionsHealthStateFilter to filter the collection of partitions returned.
// If you specify a service that does not exist in the health store, this cmdlet returns an error.
//
// serviceID is the identity of the service. This is typically the full name of the service without the 'fabric:' URI
// scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the
// service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and
// "myapp/app1/svc1" in previous versions. eventsHealthStateFilter is allows filtering the collection of HealthEvent
// objects returned based on health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a
// combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of
// the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. partitionsHealthStateFilter is
// allows filtering of the partitions health state objects returned in the result of service health query based on
// their health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only partitions that match the filter are returned. All partitions are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a
// combination of these value
// obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of partitions with
// HealthState value of OK (2) and Warning (4) will be returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection
// of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535. applicationHealthPolicy is
// describes the health policies used to evaluate the health of an application or one of its children.
// If not present, the health evaluation uses the health policy from application manifest or the default health policy.
// excludeHealthStatistics is indicates whether the health statistics should be returned as part of the query result.
// False by default.
// The statistics show the number of children entities in health state Ok, Warning, and Error. timeout is the server
// timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait
// for the requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetServiceHealthUsingPolicy(ctx context.Context, serviceID string, eventsHealthStateFilter *int32, partitionsHealthStateFilter *int32, applicationHealthPolicy *ApplicationHealthPolicy, excludeHealthStatistics *bool, timeout *int64) (result ServiceHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetServiceHealthUsingPolicy")
	}

	req, err := client.GetServiceHealthUsingPolicyPreparer(ctx, serviceID, eventsHealthStateFilter, partitionsHealthStateFilter, applicationHealthPolicy, excludeHealthStatistics, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceHealthUsingPolicy", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetServiceHealthUsingPolicySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceHealthUsingPolicy", resp, "Failure sending request")
		return
	}

	result, err = client.GetServiceHealthUsingPolicyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceHealthUsingPolicy", resp, "Failure responding to request")
	}

	return
}

// GetServiceHealthUsingPolicyPreparer prepares the GetServiceHealthUsingPolicy request.
func (client BaseClient) GetServiceHealthUsingPolicyPreparer(ctx context.Context, serviceID string, eventsHealthStateFilter *int32, partitionsHealthStateFilter *int32, applicationHealthPolicy *ApplicationHealthPolicy, excludeHealthStatistics *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"serviceId": serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	}
	if partitionsHealthStateFilter != nil {
		queryParameters["PartitionsHealthStateFilter"] = autorest.Encode("query", *partitionsHealthStateFilter)
	}
	if excludeHealthStatistics != nil {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", *excludeHealthStatistics)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Services/{serviceId}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if applicationHealthPolicy != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(applicationHealthPolicy))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetServiceHealthUsingPolicySender sends the GetServiceHealthUsingPolicy request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetServiceHealthUsingPolicySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetServiceHealthUsingPolicyResponder handles the response to the GetServiceHealthUsingPolicy request. The method always
// closes the http.Response Body.
func (client BaseClient) GetServiceHealthUsingPolicyResponder(resp *http.Response) (result ServiceHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetServiceInfo returns the information about specified service belonging to the specified Service Fabric
// application.
//
// applicationID is the identity of the application. This is typically the full name of the application without the
// 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For
// example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+
// and "myapp/app1" in previous versions. serviceID is the identity of the service. This is typically the full name of
// the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the
// "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be
// "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions. timeout is the server timeout for performing
// the operation in seconds. This specifies the time duration that the client is willing to wait for the requested
// operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) GetServiceInfo(ctx context.Context, applicationID string, serviceID string, timeout *int64) (result ServiceInfoModel, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetServiceInfo")
	}

	req, err := client.GetServiceInfoPreparer(ctx, applicationID, serviceID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetServiceInfoSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetServiceInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceInfo", resp, "Failure responding to request")
	}

	return
}

// GetServiceInfoPreparer prepares the GetServiceInfo request.
func (client BaseClient) GetServiceInfoPreparer(ctx context.Context, applicationID string, serviceID string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
		"serviceId":     serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/GetServices/{serviceId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetServiceInfoSender sends the GetServiceInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetServiceInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetServiceInfoResponder handles the response to the GetServiceInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetServiceInfoResponder(resp *http.Response) (result ServiceInfoModel, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetServiceInfoList returns the information about all services belonging to the application specified by the
// application id.
//
// applicationID is the identity of the application. This is typically the full name of the application without the
// 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For
// example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+
// and "myapp/app1" in previous versions. serviceTypeName is the service type name used to filter the services to query
// for. continuationToken is the continuation token parameter is used to obtain next set of results. A continuation
// token with a non empty value is included in the response of the API when the results from the system do not fit in a
// single response. When this value is passed to the next API call, the API returns next set of results. If there are
// no further results then the continuation token does not contain a value. The value of this parameter should not be
// URL encoded. timeout is the server timeout for performing the operation in seconds. This specifies the time duration
// that the client is willing to wait for the requested operation to complete. The default value for this parameter is
// 60 seconds.
func (client BaseClient) GetServiceInfoList(ctx context.Context, applicationID string, serviceTypeName string, continuationToken string, timeout *int64) (result PagedServiceInfoList, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetServiceInfoList")
	}

	req, err := client.GetServiceInfoListPreparer(ctx, applicationID, serviceTypeName, continuationToken, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetServiceInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetServiceInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceInfoList", resp, "Failure responding to request")
	}

	return
}

// GetServiceInfoListPreparer prepares the GetServiceInfoList request.
func (client BaseClient) GetServiceInfoListPreparer(ctx context.Context, applicationID string, serviceTypeName string, continuationToken string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(serviceTypeName) > 0 {
		queryParameters["ServiceTypeName"] = autorest.Encode("query", serviceTypeName)
	}
	if len(continuationToken) > 0 {
		queryParameters["ContinuationToken"] = continuationToken
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/GetServices", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetServiceInfoListSender sends the GetServiceInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetServiceInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetServiceInfoListResponder handles the response to the GetServiceInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetServiceInfoListResponder(resp *http.Response) (result PagedServiceInfoList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetServiceManifest gets the manifest describing a service type. The response contains the service manifest XML as a
// string.
//
// applicationTypeName is the name of the application type. applicationTypeVersion is the version of the application
// type. serviceManifestName is the name of a service manifest registered as part of an application type in a Service
// Fabric cluster. timeout is the server timeout for performing the operation in seconds. This specifies the time
// duration that the client is willing to wait for the requested operation to complete. The default value for this
// parameter is 60 seconds.
func (client BaseClient) GetServiceManifest(ctx context.Context, applicationTypeName string, applicationTypeVersion string, serviceManifestName string, timeout *int64) (result ServiceTypeManifest, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetServiceManifest")
	}

	req, err := client.GetServiceManifestPreparer(ctx, applicationTypeName, applicationTypeVersion, serviceManifestName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceManifest", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetServiceManifestSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceManifest", resp, "Failure sending request")
		return
	}

	result, err = client.GetServiceManifestResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceManifest", resp, "Failure responding to request")
	}

	return
}

// GetServiceManifestPreparer prepares the GetServiceManifest request.
func (client BaseClient) GetServiceManifestPreparer(ctx context.Context, applicationTypeName string, applicationTypeVersion string, serviceManifestName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationTypeName": autorest.Encode("path", applicationTypeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version":            APIVersion,
		"ApplicationTypeVersion": autorest.Encode("query", applicationTypeVersion),
		"ServiceManifestName":    autorest.Encode("query", serviceManifestName),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ApplicationTypes/{applicationTypeName}/$/GetServiceManifest", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetServiceManifestSender sends the GetServiceManifest request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetServiceManifestSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetServiceManifestResponder handles the response to the GetServiceManifest request. The method always
// closes the http.Response Body.
func (client BaseClient) GetServiceManifestResponder(resp *http.Response) (result ServiceTypeManifest, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetServiceNameInfo the GetServiceName endpoint returns the name of the service for the specified partition.
//
// partitionID is the identity of the partition. timeout is the server timeout for performing the operation in seconds.
// This specifies the time duration that the client is willing to wait for the requested operation to complete. The
// default value for this parameter is 60 seconds.
func (client BaseClient) GetServiceNameInfo(ctx context.Context, partitionID uuid.UUID, timeout *int64) (result ServiceNameInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetServiceNameInfo")
	}

	req, err := client.GetServiceNameInfoPreparer(ctx, partitionID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceNameInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetServiceNameInfoSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceNameInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetServiceNameInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceNameInfo", resp, "Failure responding to request")
	}

	return
}

// GetServiceNameInfoPreparer prepares the GetServiceNameInfo request.
func (client BaseClient) GetServiceNameInfoPreparer(ctx context.Context, partitionID uuid.UUID, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}/$/GetServiceName", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetServiceNameInfoSender sends the GetServiceNameInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetServiceNameInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetServiceNameInfoResponder handles the response to the GetServiceNameInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetServiceNameInfoResponder(resp *http.Response) (result ServiceNameInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetServiceTypeInfoList gets the list containing the information about service types that are supported by a
// provisioned application type in a Service Fabric cluster. The response includes the name of the service type, the
// name and version of the service manifest the type is defined in, kind (stateless or stateless) of the service type
// and other information about it.
//
// applicationTypeName is the name of the application type. applicationTypeVersion is the version of the application
// type. timeout is the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter is 60
// seconds.
func (client BaseClient) GetServiceTypeInfoList(ctx context.Context, applicationTypeName string, applicationTypeVersion string, timeout *int64) (result ListServiceTypeInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetServiceTypeInfoList")
	}

	req, err := client.GetServiceTypeInfoListPreparer(ctx, applicationTypeName, applicationTypeVersion, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceTypeInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetServiceTypeInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceTypeInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetServiceTypeInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceTypeInfoList", resp, "Failure responding to request")
	}

	return
}

// GetServiceTypeInfoListPreparer prepares the GetServiceTypeInfoList request.
func (client BaseClient) GetServiceTypeInfoListPreparer(ctx context.Context, applicationTypeName string, applicationTypeVersion string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationTypeName": autorest.Encode("path", applicationTypeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version":            APIVersion,
		"ApplicationTypeVersion": autorest.Encode("query", applicationTypeVersion),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ApplicationTypes/{applicationTypeName}/$/GetServiceTypes", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetServiceTypeInfoListSender sends the GetServiceTypeInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetServiceTypeInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetServiceTypeInfoListResponder handles the response to the GetServiceTypeInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetServiceTypeInfoListResponder(resp *http.Response) (result ListServiceTypeInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSubNameInfoList enumerates all the Service Fabric names under a given name. If the subnames do not fit in a page,
// one page of results is returned as well as a continuation token which can be used to get the next page. Querying a
// name that doesn't exist will fail.
//
// nameID is the Service Fabric name, without the 'fabric:' URI scheme. recursive is allows specifying that the search
// performed should be recursive. continuationToken is the continuation token parameter is used to obtain next set of
// results. A continuation token with a non empty value is included in the response of the API when the results from
// the system do not fit in a single response. When this value is passed to the next API call, the API returns next set
// of results. If there are no further results then the continuation token does not contain a value. The value of this
// parameter should not be URL encoded. timeout is the server timeout for performing the operation in seconds. This
// specifies the time duration that the client is willing to wait for the requested operation to complete. The default
// value for this parameter is 60 seconds.
func (client BaseClient) GetSubNameInfoList(ctx context.Context, nameID string, recursive *bool, continuationToken string, timeout *int64) (result PagedSubNameInfoList, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "GetSubNameInfoList")
	}

	req, err := client.GetSubNameInfoListPreparer(ctx, nameID, recursive, continuationToken, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetSubNameInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSubNameInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetSubNameInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetSubNameInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetSubNameInfoList", resp, "Failure responding to request")
	}

	return
}

// GetSubNameInfoListPreparer prepares the GetSubNameInfoList request.
func (client BaseClient) GetSubNameInfoListPreparer(ctx context.Context, nameID string, recursive *bool, continuationToken string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nameId": nameID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if recursive != nil {
		queryParameters["Recursive"] = autorest.Encode("query", *recursive)
	}
	if len(continuationToken) > 0 {
		queryParameters["ContinuationToken"] = continuationToken
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Names/{nameId}/$/GetSubNames", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSubNameInfoListSender sends the GetSubNameInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetSubNameInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetSubNameInfoListResponder handles the response to the GetSubNameInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetSubNameInfoListResponder(resp *http.Response) (result PagedSubNameInfoList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// InvokeInfrastructureCommand for clusters that have one or more instances of the Infrastructure Service configured,
// this API provides a way to send infrastructure-specific commands to a particular
// instance of the Infrastructure Service.
//
// Available commands and their corresponding response formats vary depending upon
// the infrastructure on which the cluster is running.
//
// This API supports the Service Fabric platform; it is not meant to be used directly from your code.
//
// command is the text of the command to be invoked. The content of the command is infrastructure-specific. serviceID
// is the identity of the infrastructure service. This is  the full name of the infrastructure service without the
// 'fabric:' URI scheme. This parameter required only for the cluster that have more than one instance of
// infrastructure service running. timeout is the server timeout for performing the operation in seconds. This
// specifies the time duration that the client is willing to wait for the requested operation to complete. The default
// value for this parameter is 60 seconds.
func (client BaseClient) InvokeInfrastructureCommand(ctx context.Context, command string, serviceID string, timeout *int64) (result String, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "InvokeInfrastructureCommand")
	}

	req, err := client.InvokeInfrastructureCommandPreparer(ctx, command, serviceID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "InvokeInfrastructureCommand", nil, "Failure preparing request")
		return
	}

	resp, err := client.InvokeInfrastructureCommandSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "InvokeInfrastructureCommand", resp, "Failure sending request")
		return
	}

	result, err = client.InvokeInfrastructureCommandResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "InvokeInfrastructureCommand", resp, "Failure responding to request")
	}

	return
}

// InvokeInfrastructureCommandPreparer prepares the InvokeInfrastructureCommand request.
func (client BaseClient) InvokeInfrastructureCommandPreparer(ctx context.Context, command string, serviceID string, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"Command":     autorest.Encode("query", command),
	}
	if len(serviceID) > 0 {
		queryParameters["ServiceId"] = autorest.Encode("query", serviceID)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/InvokeInfrastructureCommand"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// InvokeInfrastructureCommandSender sends the InvokeInfrastructureCommand request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) InvokeInfrastructureCommandSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// InvokeInfrastructureCommandResponder handles the response to the InvokeInfrastructureCommand request. The method always
// closes the http.Response Body.
func (client BaseClient) InvokeInfrastructureCommandResponder(resp *http.Response) (result String, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// InvokeInfrastructureQuery for clusters that have one or more instances of the Infrastructure Service configured,
// this API provides a way to send infrastructure-specific queries to a particular
// instance of the Infrastructure Service.
//
// Available commands and their corresponding response formats vary depending upon
// the infrastructure on which the cluster is running.
//
// This API supports the Service Fabric platform; it is not meant to be used directly from your code.
//
// command is the text of the command to be invoked. The content of the command is infrastructure-specific. serviceID
// is the identity of the infrastructure service. This is  the full name of the infrastructure service without the
// 'fabric:' URI scheme. This parameter required only for the cluster that have more than one instance of
// infrastructure service running. timeout is the server timeout for performing the operation in seconds. This
// specifies the time duration that the client is willing to wait for the requested operation to complete. The default
// value for this parameter is 60 seconds.
func (client BaseClient) InvokeInfrastructureQuery(ctx context.Context, command string, serviceID string, timeout *int64) (result String, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "InvokeInfrastructureQuery")
	}

	req, err := client.InvokeInfrastructureQueryPreparer(ctx, command, serviceID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "InvokeInfrastructureQuery", nil, "Failure preparing request")
		return
	}

	resp, err := client.InvokeInfrastructureQuerySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "InvokeInfrastructureQuery", resp, "Failure sending request")
		return
	}

	result, err = client.InvokeInfrastructureQueryResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "InvokeInfrastructureQuery", resp, "Failure responding to request")
	}

	return
}

// InvokeInfrastructureQueryPreparer prepares the InvokeInfrastructureQuery request.
func (client BaseClient) InvokeInfrastructureQueryPreparer(ctx context.Context, command string, serviceID string, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"Command":     autorest.Encode("query", command),
	}
	if len(serviceID) > 0 {
		queryParameters["ServiceId"] = autorest.Encode("query", serviceID)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/InvokeInfrastructureQuery"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// InvokeInfrastructureQuerySender sends the InvokeInfrastructureQuery request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) InvokeInfrastructureQuerySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// InvokeInfrastructureQueryResponder handles the response to the InvokeInfrastructureQuery request. The method always
// closes the http.Response Body.
func (client BaseClient) InvokeInfrastructureQueryResponder(resp *http.Response) (result String, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ProvisionApplicationType provisions or registers a Service Fabric application type with the cluster. This is
// required before any new applications can be instantiated.
//
// applicationTypeImageStorePath is the relative path for the application package in the image store specified during
// the prior copy operation. timeout is the server timeout for performing the operation in seconds. This specifies the
// time duration that the client is willing to wait for the requested operation to complete. The default value for this
// parameter is 60 seconds.
func (client BaseClient) ProvisionApplicationType(ctx context.Context, applicationTypeImageStorePath ApplicationTypeImageStorePath, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: applicationTypeImageStorePath,
			Constraints: []validation.Constraint{{Target: "applicationTypeImageStorePath.ApplicationTypeBuildPath", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "ProvisionApplicationType")
	}

	req, err := client.ProvisionApplicationTypePreparer(ctx, applicationTypeImageStorePath, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ProvisionApplicationType", nil, "Failure preparing request")
		return
	}

	resp, err := client.ProvisionApplicationTypeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ProvisionApplicationType", resp, "Failure sending request")
		return
	}

	result, err = client.ProvisionApplicationTypeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ProvisionApplicationType", resp, "Failure responding to request")
	}

	return
}

// ProvisionApplicationTypePreparer prepares the ProvisionApplicationType request.
func (client BaseClient) ProvisionApplicationTypePreparer(ctx context.Context, applicationTypeImageStorePath ApplicationTypeImageStorePath, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/ApplicationTypes/$/Provision"),
		autorest.WithJSON(applicationTypeImageStorePath),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ProvisionApplicationTypeSender sends the ProvisionApplicationType request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ProvisionApplicationTypeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ProvisionApplicationTypeResponder handles the response to the ProvisionApplicationType request. The method always
// closes the http.Response Body.
func (client BaseClient) ProvisionApplicationTypeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ProvisionCluster validate and provision the code or configuration packages of a Service Fabric cluster.
//
// provisionFabricDescription is describes the parameters for provisioning a cluster. timeout is the server timeout for
// performing the operation in seconds. This specifies the time duration that the client is willing to wait for the
// requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) ProvisionCluster(ctx context.Context, provisionFabricDescription ProvisionFabricDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "ProvisionCluster")
	}

	req, err := client.ProvisionClusterPreparer(ctx, provisionFabricDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ProvisionCluster", nil, "Failure preparing request")
		return
	}

	resp, err := client.ProvisionClusterSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ProvisionCluster", resp, "Failure sending request")
		return
	}

	result, err = client.ProvisionClusterResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ProvisionCluster", resp, "Failure responding to request")
	}

	return
}

// ProvisionClusterPreparer prepares the ProvisionCluster request.
func (client BaseClient) ProvisionClusterPreparer(ctx context.Context, provisionFabricDescription ProvisionFabricDescription, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/Provision"),
		autorest.WithJSON(provisionFabricDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ProvisionClusterSender sends the ProvisionCluster request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ProvisionClusterSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ProvisionClusterResponder handles the response to the ProvisionCluster request. The method always
// closes the http.Response Body.
func (client BaseClient) ProvisionClusterResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// PutProperty creates or updates the specified Service Fabric property under a given name.
//
// nameID is the Service Fabric name, without the 'fabric:' URI scheme. propertyDescription is describes the Service
// Fabric property to be created. timeout is the server timeout for performing the operation in seconds. This specifies
// the time duration that the client is willing to wait for the requested operation to complete. The default value for
// this parameter is 60 seconds.
func (client BaseClient) PutProperty(ctx context.Context, nameID string, propertyDescription PropertyDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: propertyDescription,
			Constraints: []validation.Constraint{{Target: "propertyDescription.PropertyName", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "propertyDescription.Value", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "PutProperty")
	}

	req, err := client.PutPropertyPreparer(ctx, nameID, propertyDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "PutProperty", nil, "Failure preparing request")
		return
	}

	resp, err := client.PutPropertySender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "PutProperty", resp, "Failure sending request")
		return
	}

	result, err = client.PutPropertyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "PutProperty", resp, "Failure responding to request")
	}

	return
}

// PutPropertyPreparer prepares the PutProperty request.
func (client BaseClient) PutPropertyPreparer(ctx context.Context, nameID string, propertyDescription PropertyDescription, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nameId": nameID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Names/{nameId}/$/GetProperty", pathParameters),
		autorest.WithJSON(propertyDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PutPropertySender sends the PutProperty request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) PutPropertySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// PutPropertyResponder handles the response to the PutProperty request. The method always
// closes the http.Response Body.
func (client BaseClient) PutPropertyResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RecoverAllPartitions indicates to the Service Fabric cluster that it should attempt to recover any services
// (including system services) which are currently stuck in quorum loss. This operation should only be performed if it
// is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data
// loss.
//
// timeout is the server timeout for performing the operation in seconds. This specifies the time duration that the
// client is willing to wait for the requested operation to complete. The default value for this parameter is 60
// seconds.
func (client BaseClient) RecoverAllPartitions(ctx context.Context, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "RecoverAllPartitions")
	}

	req, err := client.RecoverAllPartitionsPreparer(ctx, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RecoverAllPartitions", nil, "Failure preparing request")
		return
	}

	resp, err := client.RecoverAllPartitionsSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RecoverAllPartitions", resp, "Failure sending request")
		return
	}

	result, err = client.RecoverAllPartitionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RecoverAllPartitions", resp, "Failure responding to request")
	}

	return
}

// RecoverAllPartitionsPreparer prepares the RecoverAllPartitions request.
func (client BaseClient) RecoverAllPartitionsPreparer(ctx context.Context, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/RecoverAllPartitions"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RecoverAllPartitionsSender sends the RecoverAllPartitions request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RecoverAllPartitionsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// RecoverAllPartitionsResponder handles the response to the RecoverAllPartitions request. The method always
// closes the http.Response Body.
func (client BaseClient) RecoverAllPartitionsResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RecoverPartition indicates to the Service Fabric cluster that it should attempt to recover a specific partition
// which is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas
// that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
//
// partitionID is the identity of the partition. timeout is the server timeout for performing the operation in seconds.
// This specifies the time duration that the client is willing to wait for the requested operation to complete. The
// default value for this parameter is 60 seconds.
func (client BaseClient) RecoverPartition(ctx context.Context, partitionID uuid.UUID, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "RecoverPartition")
	}

	req, err := client.RecoverPartitionPreparer(ctx, partitionID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RecoverPartition", nil, "Failure preparing request")
		return
	}

	resp, err := client.RecoverPartitionSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RecoverPartition", resp, "Failure sending request")
		return
	}

	result, err = client.RecoverPartitionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RecoverPartition", resp, "Failure responding to request")
	}

	return
}

// RecoverPartitionPreparer prepares the RecoverPartition request.
func (client BaseClient) RecoverPartitionPreparer(ctx context.Context, partitionID uuid.UUID, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}/$/Recover", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RecoverPartitionSender sends the RecoverPartition request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RecoverPartitionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// RecoverPartitionResponder handles the response to the RecoverPartition request. The method always
// closes the http.Response Body.
func (client BaseClient) RecoverPartitionResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RecoverServicePartitions indicates to the Service Fabric cluster that it should attempt to recover the specified
// service which is currently stuck in quorum loss. This operation should only be performed if it is known that the
// replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
//
// serviceID is the identity of the service. This is typically the full name of the service without the 'fabric:' URI
// scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the
// service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and
// "myapp/app1/svc1" in previous versions. timeout is the server timeout for performing the operation in seconds. This
// specifies the time duration that the client is willing to wait for the requested operation to complete. The default
// value for this parameter is 60 seconds.
func (client BaseClient) RecoverServicePartitions(ctx context.Context, serviceID string, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "RecoverServicePartitions")
	}

	req, err := client.RecoverServicePartitionsPreparer(ctx, serviceID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RecoverServicePartitions", nil, "Failure preparing request")
		return
	}

	resp, err := client.RecoverServicePartitionsSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RecoverServicePartitions", resp, "Failure sending request")
		return
	}

	result, err = client.RecoverServicePartitionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RecoverServicePartitions", resp, "Failure responding to request")
	}

	return
}

// RecoverServicePartitionsPreparer prepares the RecoverServicePartitions request.
func (client BaseClient) RecoverServicePartitionsPreparer(ctx context.Context, serviceID string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"serviceId": serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Services/$/{serviceId}/$/GetPartitions/$/Recover", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RecoverServicePartitionsSender sends the RecoverServicePartitions request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RecoverServicePartitionsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// RecoverServicePartitionsResponder handles the response to the RecoverServicePartitions request. The method always
// closes the http.Response Body.
func (client BaseClient) RecoverServicePartitionsResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RecoverSystemPartitions indicates to the Service Fabric cluster that it should attempt to recover the system
// services which are currently stuck in quorum loss. This operation should only be performed if it is known that the
// replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
//
// timeout is the server timeout for performing the operation in seconds. This specifies the time duration that the
// client is willing to wait for the requested operation to complete. The default value for this parameter is 60
// seconds.
func (client BaseClient) RecoverSystemPartitions(ctx context.Context, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "RecoverSystemPartitions")
	}

	req, err := client.RecoverSystemPartitionsPreparer(ctx, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RecoverSystemPartitions", nil, "Failure preparing request")
		return
	}

	resp, err := client.RecoverSystemPartitionsSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RecoverSystemPartitions", resp, "Failure sending request")
		return
	}

	result, err = client.RecoverSystemPartitionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RecoverSystemPartitions", resp, "Failure responding to request")
	}

	return
}

// RecoverSystemPartitionsPreparer prepares the RecoverSystemPartitions request.
func (client BaseClient) RecoverSystemPartitionsPreparer(ctx context.Context, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/RecoverSystemPartitions"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RecoverSystemPartitionsSender sends the RecoverSystemPartitions request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RecoverSystemPartitionsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// RecoverSystemPartitionsResponder handles the response to the RecoverSystemPartitions request. The method always
// closes the http.Response Body.
func (client BaseClient) RecoverSystemPartitionsResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RemoveComposeDeployment deletes an existing Service Fabric compose deployment.
//
// deploymentName is the identity of the deployment. timeout is the server timeout for performing the operation in
// seconds. This specifies the time duration that the client is willing to wait for the requested operation to
// complete. The default value for this parameter is 60 seconds.
func (client BaseClient) RemoveComposeDeployment(ctx context.Context, deploymentName string, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "RemoveComposeDeployment")
	}

	req, err := client.RemoveComposeDeploymentPreparer(ctx, deploymentName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RemoveComposeDeployment", nil, "Failure preparing request")
		return
	}

	resp, err := client.RemoveComposeDeploymentSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RemoveComposeDeployment", resp, "Failure sending request")
		return
	}

	result, err = client.RemoveComposeDeploymentResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RemoveComposeDeployment", resp, "Failure responding to request")
	}

	return
}

// RemoveComposeDeploymentPreparer prepares the RemoveComposeDeployment request.
func (client BaseClient) RemoveComposeDeploymentPreparer(ctx context.Context, deploymentName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"deploymentName": deploymentName,
	}

	const APIVersion = "6.0-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ComposeDeployments/{deploymentName}/$/Delete", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RemoveComposeDeploymentSender sends the RemoveComposeDeployment request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RemoveComposeDeploymentSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// RemoveComposeDeploymentResponder handles the response to the RemoveComposeDeployment request. The method always
// closes the http.Response Body.
func (client BaseClient) RemoveComposeDeploymentResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RemoveNodeState notifies Service Fabric that the persisted state on a node has been permanently removed or lost.
// This implies that it is not possible to recover the persisted state of that node. This generally happens if a hard
// disk has been wiped clean, or if a hard disk crashes. The node has to be down for this operation to be successful.
// This operation lets Service Fabric know that the replicas on that node no longer exist, and that Service Fabric
// should stop waiting for those replicas to come back up. Do not run this cmdlet if the state on the node has not been
// removed and the node can comes back up with its state intact.
//
// nodeName is the name of the node. timeout is the server timeout for performing the operation in seconds. This
// specifies the time duration that the client is willing to wait for the requested operation to complete. The default
// value for this parameter is 60 seconds.
func (client BaseClient) RemoveNodeState(ctx context.Context, nodeName string, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "RemoveNodeState")
	}

	req, err := client.RemoveNodeStatePreparer(ctx, nodeName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RemoveNodeState", nil, "Failure preparing request")
		return
	}

	resp, err := client.RemoveNodeStateSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RemoveNodeState", resp, "Failure sending request")
		return
	}

	result, err = client.RemoveNodeStateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RemoveNodeState", resp, "Failure responding to request")
	}

	return
}

// RemoveNodeStatePreparer prepares the RemoveNodeState request.
func (client BaseClient) RemoveNodeStatePreparer(ctx context.Context, nodeName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/RemoveNodeState", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RemoveNodeStateSender sends the RemoveNodeState request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RemoveNodeStateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// RemoveNodeStateResponder handles the response to the RemoveNodeState request. The method always
// closes the http.Response Body.
func (client BaseClient) RemoveNodeStateResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RemoveReplica this API simulates a Service Fabric replica failure by removing a replica from a Service Fabric
// cluster. The removal closes the replica, transitions the replica to the role None, and then removes all of the state
// information of the replica from the cluster. This API tests the replica state removal path, and simulates the report
// fault permanent path through client APIs. Warning - There are no safety checks performed when this API is used.
// Incorrect use of this API can lead to data loss for stateful services.In addition, the forceRemove flag impacts all
// other replicas hosted in the same process.
//
// nodeName is the name of the node. partitionID is the identity of the partition. replicaID is the identifier of the
// replica. forceRemove is remove a Service Fabric application or service forcefully without going through the graceful
// shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is
// timing out due to issues in the service code that prevents graceful close of replicas. timeout is the server timeout
// for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the
// requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) RemoveReplica(ctx context.Context, nodeName string, partitionID uuid.UUID, replicaID string, forceRemove *bool, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "RemoveReplica")
	}

	req, err := client.RemoveReplicaPreparer(ctx, nodeName, partitionID, replicaID, forceRemove, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RemoveReplica", nil, "Failure preparing request")
		return
	}

	resp, err := client.RemoveReplicaSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RemoveReplica", resp, "Failure sending request")
		return
	}

	result, err = client.RemoveReplicaResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RemoveReplica", resp, "Failure responding to request")
	}

	return
}

// RemoveReplicaPreparer prepares the RemoveReplica request.
func (client BaseClient) RemoveReplicaPreparer(ctx context.Context, nodeName string, partitionID uuid.UUID, replicaID string, forceRemove *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName":    autorest.Encode("path", nodeName),
		"partitionId": partitionID,
		"replicaId":   replicaID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if forceRemove != nil {
		queryParameters["ForceRemove"] = autorest.Encode("query", *forceRemove)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas/{replicaId}/$/Delete", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RemoveReplicaSender sends the RemoveReplica request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RemoveReplicaSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// RemoveReplicaResponder handles the response to the RemoveReplica request. The method always
// closes the http.Response Body.
func (client BaseClient) RemoveReplicaResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ReportApplicationHealth reports health state of the specified Service Fabric application. The report must contain
// the information about the source of the health report and property on which it is reported.
// The report is sent to a Service Fabric gateway Application, which forwards to the health store.
// The report may be accepted by the gateway, but rejected by the health store after extra validation.
// For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
// To see whether the report was applied in the health store, get application health and check that the report appears
// in the HealthEvents section.
//
// applicationID is the identity of the application. This is typically the full name of the application without the
// 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For
// example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+
// and "myapp/app1" in previous versions. healthInformation is describes the health information for the health report.
// This information needs to be present in all of the health reports sent to the health manager. immediate is a flag
// which indicates whether the report should be sent immediately.
// A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
// If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the
// fabric client settings that the Http Gateway Application is using.
// This is useful for critical reports that should be sent as soon as possible.
// Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is
// closed or the message doesn't reach the Gateway.
// If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway.
// Therefore, it will be batched according to the HealthReportSendInterval configuration.
// This is the recommended setting because it allows the health client to optimize health reporting messages to health
// store as well as health report processing.
// By default, reports are not sent immediately. timeout is the server timeout for performing the operation in seconds.
// This specifies the time duration that the client is willing to wait for the requested operation to complete. The
// default value for this parameter is 60 seconds.
func (client BaseClient) ReportApplicationHealth(ctx context.Context, applicationID string, healthInformation HealthInformation, immediate *bool, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: healthInformation,
			Constraints: []validation.Constraint{{Target: "healthInformation.SourceID", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "healthInformation.Property", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "ReportApplicationHealth")
	}

	req, err := client.ReportApplicationHealthPreparer(ctx, applicationID, healthInformation, immediate, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportApplicationHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.ReportApplicationHealthSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportApplicationHealth", resp, "Failure sending request")
		return
	}

	result, err = client.ReportApplicationHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportApplicationHealth", resp, "Failure responding to request")
	}

	return
}

// ReportApplicationHealthPreparer prepares the ReportApplicationHealth request.
func (client BaseClient) ReportApplicationHealthPreparer(ctx context.Context, applicationID string, healthInformation HealthInformation, immediate *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if immediate != nil {
		queryParameters["Immediate"] = autorest.Encode("query", *immediate)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/ReportHealth", pathParameters),
		autorest.WithJSON(healthInformation),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ReportApplicationHealthSender sends the ReportApplicationHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ReportApplicationHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ReportApplicationHealthResponder handles the response to the ReportApplicationHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) ReportApplicationHealthResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ReportClusterHealth sends a health report on a Service Fabric cluster. The report must contain the information about
// the source of the health report and property on which it is reported.
// The report is sent to a Service Fabric gateway node, which forwards to the health store.
// The report may be accepted by the gateway, but rejected by the health store after extra validation.
// For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
// To see whether the report was applied in the health store, run GetClusterHealth and check that the report appears in
// the HealthEvents section.
//
// healthInformation is describes the health information for the health report. This information needs to be present in
// all of the health reports sent to the health manager. immediate is a flag which indicates whether the report should
// be sent immediately.
// A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
// If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the
// fabric client settings that the Http Gateway Application is using.
// This is useful for critical reports that should be sent as soon as possible.
// Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is
// closed or the message doesn't reach the Gateway.
// If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway.
// Therefore, it will be batched according to the HealthReportSendInterval configuration.
// This is the recommended setting because it allows the health client to optimize health reporting messages to health
// store as well as health report processing.
// By default, reports are not sent immediately. timeout is the server timeout for performing the operation in seconds.
// This specifies the time duration that the client is willing to wait for the requested operation to complete. The
// default value for this parameter is 60 seconds.
func (client BaseClient) ReportClusterHealth(ctx context.Context, healthInformation HealthInformation, immediate *bool, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: healthInformation,
			Constraints: []validation.Constraint{{Target: "healthInformation.SourceID", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "healthInformation.Property", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "ReportClusterHealth")
	}

	req, err := client.ReportClusterHealthPreparer(ctx, healthInformation, immediate, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportClusterHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.ReportClusterHealthSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportClusterHealth", resp, "Failure sending request")
		return
	}

	result, err = client.ReportClusterHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportClusterHealth", resp, "Failure responding to request")
	}

	return
}

// ReportClusterHealthPreparer prepares the ReportClusterHealth request.
func (client BaseClient) ReportClusterHealthPreparer(ctx context.Context, healthInformation HealthInformation, immediate *bool, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if immediate != nil {
		queryParameters["Immediate"] = autorest.Encode("query", *immediate)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/ReportClusterHealth"),
		autorest.WithJSON(healthInformation),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ReportClusterHealthSender sends the ReportClusterHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ReportClusterHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ReportClusterHealthResponder handles the response to the ReportClusterHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) ReportClusterHealthResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ReportDeployedApplicationHealth reports health state of the application deployed on a Service Fabric node. The
// report must contain the information about the source of the health report and property on which it is reported.
// The report is sent to a Service Fabric gateway Service, which forwards to the health store.
// The report may be accepted by the gateway, but rejected by the health store after extra validation.
// For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
// To see whether the report was applied in the health store, get deployed application health and check that the report
// appears in the HealthEvents section.
//
// nodeName is the name of the node. applicationID is the identity of the application. This is typically the full name
// of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited
// with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity
// would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions. healthInformation is describes the health
// information for the health report. This information needs to be present in all of the health reports sent to the
// health manager. immediate is a flag which indicates whether the report should be sent immediately.
// A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
// If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the
// fabric client settings that the Http Gateway Application is using.
// This is useful for critical reports that should be sent as soon as possible.
// Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is
// closed or the message doesn't reach the Gateway.
// If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway.
// Therefore, it will be batched according to the HealthReportSendInterval configuration.
// This is the recommended setting because it allows the health client to optimize health reporting messages to health
// store as well as health report processing.
// By default, reports are not sent immediately. timeout is the server timeout for performing the operation in seconds.
// This specifies the time duration that the client is willing to wait for the requested operation to complete. The
// default value for this parameter is 60 seconds.
func (client BaseClient) ReportDeployedApplicationHealth(ctx context.Context, nodeName string, applicationID string, healthInformation HealthInformation, immediate *bool, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: healthInformation,
			Constraints: []validation.Constraint{{Target: "healthInformation.SourceID", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "healthInformation.Property", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "ReportDeployedApplicationHealth")
	}

	req, err := client.ReportDeployedApplicationHealthPreparer(ctx, nodeName, applicationID, healthInformation, immediate, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportDeployedApplicationHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.ReportDeployedApplicationHealthSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportDeployedApplicationHealth", resp, "Failure sending request")
		return
	}

	result, err = client.ReportDeployedApplicationHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportDeployedApplicationHealth", resp, "Failure responding to request")
	}

	return
}

// ReportDeployedApplicationHealthPreparer prepares the ReportDeployedApplicationHealth request.
func (client BaseClient) ReportDeployedApplicationHealthPreparer(ctx context.Context, nodeName string, applicationID string, healthInformation HealthInformation, immediate *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
		"nodeName":      autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if immediate != nil {
		queryParameters["Immediate"] = autorest.Encode("query", *immediate)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/ReportHealth", pathParameters),
		autorest.WithJSON(healthInformation),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ReportDeployedApplicationHealthSender sends the ReportDeployedApplicationHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ReportDeployedApplicationHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ReportDeployedApplicationHealthResponder handles the response to the ReportDeployedApplicationHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) ReportDeployedApplicationHealthResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ReportDeployedServicePackageHealth reports health state of the service package of the application deployed on a
// Service Fabric node. The report must contain the information about the source of the health report and property on
// which it is reported.
// The report is sent to a Service Fabric gateway Service, which forwards to the health store.
// The report may be accepted by the gateway, but rejected by the health store after extra validation.
// For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
// To see whether the report was applied in the health store, get deployed service package health and check that the
// report appears in the HealthEvents section.
//
// nodeName is the name of the node. applicationID is the identity of the application. This is typically the full name
// of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited
// with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity
// would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions. servicePackageName is the name of the service
// package. healthInformation is describes the health information for the health report. This information needs to be
// present in all of the health reports sent to the health manager. immediate is a flag which indicates whether the
// report should be sent immediately.
// A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
// If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the
// fabric client settings that the Http Gateway Application is using.
// This is useful for critical reports that should be sent as soon as possible.
// Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is
// closed or the message doesn't reach the Gateway.
// If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway.
// Therefore, it will be batched according to the HealthReportSendInterval configuration.
// This is the recommended setting because it allows the health client to optimize health reporting messages to health
// store as well as health report processing.
// By default, reports are not sent immediately. timeout is the server timeout for performing the operation in seconds.
// This specifies the time duration that the client is willing to wait for the requested operation to complete. The
// default value for this parameter is 60 seconds.
func (client BaseClient) ReportDeployedServicePackageHealth(ctx context.Context, nodeName string, applicationID string, servicePackageName string, healthInformation HealthInformation, immediate *bool, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: healthInformation,
			Constraints: []validation.Constraint{{Target: "healthInformation.SourceID", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "healthInformation.Property", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "ReportDeployedServicePackageHealth")
	}

	req, err := client.ReportDeployedServicePackageHealthPreparer(ctx, nodeName, applicationID, servicePackageName, healthInformation, immediate, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportDeployedServicePackageHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.ReportDeployedServicePackageHealthSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportDeployedServicePackageHealth", resp, "Failure sending request")
		return
	}

	result, err = client.ReportDeployedServicePackageHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportDeployedServicePackageHealth", resp, "Failure responding to request")
	}

	return
}

// ReportDeployedServicePackageHealthPreparer prepares the ReportDeployedServicePackageHealth request.
func (client BaseClient) ReportDeployedServicePackageHealthPreparer(ctx context.Context, nodeName string, applicationID string, servicePackageName string, healthInformation HealthInformation, immediate *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId":      applicationID,
		"nodeName":           autorest.Encode("path", nodeName),
		"servicePackageName": servicePackageName,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if immediate != nil {
		queryParameters["Immediate"] = autorest.Encode("query", *immediate)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}/$/ReportHealth", pathParameters),
		autorest.WithJSON(healthInformation),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ReportDeployedServicePackageHealthSender sends the ReportDeployedServicePackageHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ReportDeployedServicePackageHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ReportDeployedServicePackageHealthResponder handles the response to the ReportDeployedServicePackageHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) ReportDeployedServicePackageHealthResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ReportNodeHealth reports health state of the specified Service Fabric node. The report must contain the information
// about the source of the health report and property on which it is reported.
// The report is sent to a Service Fabric gateway node, which forwards to the health store.
// The report may be accepted by the gateway, but rejected by the health store after extra validation.
// For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
// To see whether the report was applied in the health store, run GetNodeHealth and check that the report appears in
// the HealthEvents section.
//
// nodeName is the name of the node. healthInformation is describes the health information for the health report. This
// information needs to be present in all of the health reports sent to the health manager. immediate is a flag which
// indicates whether the report should be sent immediately.
// A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
// If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the
// fabric client settings that the Http Gateway Application is using.
// This is useful for critical reports that should be sent as soon as possible.
// Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is
// closed or the message doesn't reach the Gateway.
// If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway.
// Therefore, it will be batched according to the HealthReportSendInterval configuration.
// This is the recommended setting because it allows the health client to optimize health reporting messages to health
// store as well as health report processing.
// By default, reports are not sent immediately. timeout is the server timeout for performing the operation in seconds.
// This specifies the time duration that the client is willing to wait for the requested operation to complete. The
// default value for this parameter is 60 seconds.
func (client BaseClient) ReportNodeHealth(ctx context.Context, nodeName string, healthInformation HealthInformation, immediate *bool, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: healthInformation,
			Constraints: []validation.Constraint{{Target: "healthInformation.SourceID", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "healthInformation.Property", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "ReportNodeHealth")
	}

	req, err := client.ReportNodeHealthPreparer(ctx, nodeName, healthInformation, immediate, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportNodeHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.ReportNodeHealthSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportNodeHealth", resp, "Failure sending request")
		return
	}

	result, err = client.ReportNodeHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportNodeHealth", resp, "Failure responding to request")
	}

	return
}

// ReportNodeHealthPreparer prepares the ReportNodeHealth request.
func (client BaseClient) ReportNodeHealthPreparer(ctx context.Context, nodeName string, healthInformation HealthInformation, immediate *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if immediate != nil {
		queryParameters["Immediate"] = autorest.Encode("query", *immediate)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/ReportHealth", pathParameters),
		autorest.WithJSON(healthInformation),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ReportNodeHealthSender sends the ReportNodeHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ReportNodeHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ReportNodeHealthResponder handles the response to the ReportNodeHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) ReportNodeHealthResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ReportPartitionHealth reports health state of the specified Service Fabric partition. The report must contain the
// information about the source of the health report and property on which it is reported.
// The report is sent to a Service Fabric gateway Partition, which forwards to the health store.
// The report may be accepted by the gateway, but rejected by the health store after extra validation.
// For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
// To see whether the report was applied in the health store, run GetPartitionHealth and check that the report appears
// in the HealthEvents section.
//
// partitionID is the identity of the partition. healthInformation is describes the health information for the health
// report. This information needs to be present in all of the health reports sent to the health manager. immediate is a
// flag which indicates whether the report should be sent immediately.
// A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
// If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the
// fabric client settings that the Http Gateway Application is using.
// This is useful for critical reports that should be sent as soon as possible.
// Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is
// closed or the message doesn't reach the Gateway.
// If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway.
// Therefore, it will be batched according to the HealthReportSendInterval configuration.
// This is the recommended setting because it allows the health client to optimize health reporting messages to health
// store as well as health report processing.
// By default, reports are not sent immediately. timeout is the server timeout for performing the operation in seconds.
// This specifies the time duration that the client is willing to wait for the requested operation to complete. The
// default value for this parameter is 60 seconds.
func (client BaseClient) ReportPartitionHealth(ctx context.Context, partitionID uuid.UUID, healthInformation HealthInformation, immediate *bool, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: healthInformation,
			Constraints: []validation.Constraint{{Target: "healthInformation.SourceID", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "healthInformation.Property", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "ReportPartitionHealth")
	}

	req, err := client.ReportPartitionHealthPreparer(ctx, partitionID, healthInformation, immediate, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportPartitionHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.ReportPartitionHealthSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportPartitionHealth", resp, "Failure sending request")
		return
	}

	result, err = client.ReportPartitionHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportPartitionHealth", resp, "Failure responding to request")
	}

	return
}

// ReportPartitionHealthPreparer prepares the ReportPartitionHealth request.
func (client BaseClient) ReportPartitionHealthPreparer(ctx context.Context, partitionID uuid.UUID, healthInformation HealthInformation, immediate *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if immediate != nil {
		queryParameters["Immediate"] = autorest.Encode("query", *immediate)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}/$/ReportHealth", pathParameters),
		autorest.WithJSON(healthInformation),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ReportPartitionHealthSender sends the ReportPartitionHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ReportPartitionHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ReportPartitionHealthResponder handles the response to the ReportPartitionHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) ReportPartitionHealthResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ReportReplicaHealth reports health state of the specified Service Fabric replica. The report must contain the
// information about the source of the health report and property on which it is reported.
// The report is sent to a Service Fabric gateway Replica, which forwards to the health store.
// The report may be accepted by the gateway, but rejected by the health store after extra validation.
// For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
// To see whether the report was applied in the health store, run GetReplicaHealth and check that the report appears in
// the HealthEvents section.
//
// partitionID is the identity of the partition. replicaID is the identifier of the replica. serviceKind is the kind of
// service replica (Stateless or Stateful) for which the health is being reported. Following are the possible values.
// - Stateless - Does not use Service Fabric to make its state highly available or reliable. The value is 1
// - Stateful - Uses Service Fabric to make its state or part of its state highly available and reliable. The value is
// 2. healthInformation is describes the health information for the health report. This information needs to be present
// in all of the health reports sent to the health manager. immediate is a flag which indicates whether the report
// should be sent immediately.
// A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
// If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the
// fabric client settings that the Http Gateway Application is using.
// This is useful for critical reports that should be sent as soon as possible.
// Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is
// closed or the message doesn't reach the Gateway.
// If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway.
// Therefore, it will be batched according to the HealthReportSendInterval configuration.
// This is the recommended setting because it allows the health client to optimize health reporting messages to health
// store as well as health report processing.
// By default, reports are not sent immediately. timeout is the server timeout for performing the operation in seconds.
// This specifies the time duration that the client is willing to wait for the requested operation to complete. The
// default value for this parameter is 60 seconds.
func (client BaseClient) ReportReplicaHealth(ctx context.Context, partitionID uuid.UUID, replicaID string, serviceKind string, healthInformation HealthInformation, immediate *bool, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: healthInformation,
			Constraints: []validation.Constraint{{Target: "healthInformation.SourceID", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "healthInformation.Property", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "ReportReplicaHealth")
	}

	req, err := client.ReportReplicaHealthPreparer(ctx, partitionID, replicaID, serviceKind, healthInformation, immediate, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportReplicaHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.ReportReplicaHealthSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportReplicaHealth", resp, "Failure sending request")
		return
	}

	result, err = client.ReportReplicaHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportReplicaHealth", resp, "Failure responding to request")
	}

	return
}

// ReportReplicaHealthPreparer prepares the ReportReplicaHealth request.
func (client BaseClient) ReportReplicaHealthPreparer(ctx context.Context, partitionID uuid.UUID, replicaID string, serviceKind string, healthInformation HealthInformation, immediate *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
		"replicaId":   replicaID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"ServiceKind": autorest.Encode("query", serviceKind),
	}
	if immediate != nil {
		queryParameters["Immediate"] = autorest.Encode("query", *immediate)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}/$/GetReplicas/{replicaId}/$/ReportHealth", pathParameters),
		autorest.WithJSON(healthInformation),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ReportReplicaHealthSender sends the ReportReplicaHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ReportReplicaHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ReportReplicaHealthResponder handles the response to the ReportReplicaHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) ReportReplicaHealthResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ReportServiceHealth reports health state of the specified Service Fabric service. The report must contain the
// information about the source of the health report and property on which it is reported.
// The report is sent to a Service Fabric gateway Service, which forwards to the health store.
// The report may be accepted by the gateway, but rejected by the health store after extra validation.
// For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
// To see whether the report was applied in the health store, run GetServiceHealth and check that the report appears in
// the HealthEvents section.
//
// serviceID is the identity of the service. This is typically the full name of the service without the 'fabric:' URI
// scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the
// service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and
// "myapp/app1/svc1" in previous versions. healthInformation is describes the health information for the health report.
// This information needs to be present in all of the health reports sent to the health manager. immediate is a flag
// which indicates whether the report should be sent immediately.
// A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
// If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the
// fabric client settings that the Http Gateway Application is using.
// This is useful for critical reports that should be sent as soon as possible.
// Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is
// closed or the message doesn't reach the Gateway.
// If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway.
// Therefore, it will be batched according to the HealthReportSendInterval configuration.
// This is the recommended setting because it allows the health client to optimize health reporting messages to health
// store as well as health report processing.
// By default, reports are not sent immediately. timeout is the server timeout for performing the operation in seconds.
// This specifies the time duration that the client is willing to wait for the requested operation to complete. The
// default value for this parameter is 60 seconds.
func (client BaseClient) ReportServiceHealth(ctx context.Context, serviceID string, healthInformation HealthInformation, immediate *bool, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: healthInformation,
			Constraints: []validation.Constraint{{Target: "healthInformation.SourceID", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "healthInformation.Property", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "ReportServiceHealth")
	}

	req, err := client.ReportServiceHealthPreparer(ctx, serviceID, healthInformation, immediate, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportServiceHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.ReportServiceHealthSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportServiceHealth", resp, "Failure sending request")
		return
	}

	result, err = client.ReportServiceHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportServiceHealth", resp, "Failure responding to request")
	}

	return
}

// ReportServiceHealthPreparer prepares the ReportServiceHealth request.
func (client BaseClient) ReportServiceHealthPreparer(ctx context.Context, serviceID string, healthInformation HealthInformation, immediate *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"serviceId": serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if immediate != nil {
		queryParameters["Immediate"] = autorest.Encode("query", *immediate)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Services/{serviceId}/$/ReportHealth", pathParameters),
		autorest.WithJSON(healthInformation),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ReportServiceHealthSender sends the ReportServiceHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ReportServiceHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ReportServiceHealthResponder handles the response to the ReportServiceHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) ReportServiceHealthResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ResetPartitionLoad resets the current load of a Service Fabric partition to the default load for the service.
//
// partitionID is the identity of the partition. timeout is the server timeout for performing the operation in seconds.
// This specifies the time duration that the client is willing to wait for the requested operation to complete. The
// default value for this parameter is 60 seconds.
func (client BaseClient) ResetPartitionLoad(ctx context.Context, partitionID uuid.UUID, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "ResetPartitionLoad")
	}

	req, err := client.ResetPartitionLoadPreparer(ctx, partitionID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ResetPartitionLoad", nil, "Failure preparing request")
		return
	}

	resp, err := client.ResetPartitionLoadSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ResetPartitionLoad", resp, "Failure sending request")
		return
	}

	result, err = client.ResetPartitionLoadResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ResetPartitionLoad", resp, "Failure responding to request")
	}

	return
}

// ResetPartitionLoadPreparer prepares the ResetPartitionLoad request.
func (client BaseClient) ResetPartitionLoadPreparer(ctx context.Context, partitionID uuid.UUID, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}/$/ResetLoad", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ResetPartitionLoadSender sends the ResetPartitionLoad request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ResetPartitionLoadSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ResetPartitionLoadResponder handles the response to the ResetPartitionLoad request. The method always
// closes the http.Response Body.
func (client BaseClient) ResetPartitionLoadResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ResolveService resolve a Service Fabric service partition, to get the endpoints of the service replicas.
//
// serviceID is the identity of the service. This is typically the full name of the service without the 'fabric:' URI
// scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the
// service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and
// "myapp/app1/svc1" in previous versions. partitionKeyType is key type for the partition. This parameter is required
// if the partition scheme for the service is Int64Range or Named. The possible values are following.
// - None (1) - Indicates that the the PartitionKeyValue parameter is not specified. This is valid for the partitions
// with partitioning scheme as Singleton. This is the default value. The value is 1.
// - Int64Range (2) - Indicates that the the PartitionKeyValue parameter is an int64 partition key. This is valid for
// the partitions with partitioning scheme as Int64Range. The value is 2.
// - Named (3) - Indicates that the the PartitionKeyValue parameter is a name of the partition. This is valid for the
// partitions with partitioning scheme as Named. The value is 3. partitionKeyValue is partition key. This is required
// if the partition scheme for the service is Int64Range or Named. previousRspVersion is the value in the Version field
// of the response that was received previously. This is required if the user knows that the result that was got
// previously is stale. timeout is the server timeout for performing the operation in seconds. This specifies the time
// duration that the client is willing to wait for the requested operation to complete. The default value for this
// parameter is 60 seconds.
func (client BaseClient) ResolveService(ctx context.Context, serviceID string, partitionKeyType *int32, partitionKeyValue string, previousRspVersion string, timeout *int64) (result ResolvedServicePartition, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "ResolveService")
	}

	req, err := client.ResolveServicePreparer(ctx, serviceID, partitionKeyType, partitionKeyValue, previousRspVersion, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ResolveService", nil, "Failure preparing request")
		return
	}

	resp, err := client.ResolveServiceSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ResolveService", resp, "Failure sending request")
		return
	}

	result, err = client.ResolveServiceResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ResolveService", resp, "Failure responding to request")
	}

	return
}

// ResolveServicePreparer prepares the ResolveService request.
func (client BaseClient) ResolveServicePreparer(ctx context.Context, serviceID string, partitionKeyType *int32, partitionKeyValue string, previousRspVersion string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"serviceId": serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if partitionKeyType != nil {
		queryParameters["PartitionKeyType"] = autorest.Encode("query", *partitionKeyType)
	}
	if len(partitionKeyValue) > 0 {
		queryParameters["PartitionKeyValue"] = partitionKeyValue
	}
	if len(previousRspVersion) > 0 {
		queryParameters["PreviousRspVersion"] = previousRspVersion
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Services/{serviceId}/$/ResolvePartition", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ResolveServiceSender sends the ResolveService request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ResolveServiceSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ResolveServiceResponder handles the response to the ResolveService request. The method always
// closes the http.Response Body.
func (client BaseClient) ResolveServiceResponder(resp *http.Response) (result ResolvedServicePartition, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// RestartDeployedCodePackage restarts a code package deployed on a Service Fabric node in a cluster. This aborts the
// code package process, which will restart all the user service replicas hosted in that process.
//
// nodeName is the name of the node. applicationID is the identity of the application. This is typically the full name
// of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited
// with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity
// would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions. restartDeployedCodePackageDescription is
// describes the deployed code package on Service Fabric node to restart. timeout is the server timeout for performing
// the operation in seconds. This specifies the time duration that the client is willing to wait for the requested
// operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) RestartDeployedCodePackage(ctx context.Context, nodeName string, applicationID string, restartDeployedCodePackageDescription RestartDeployedCodePackageDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: restartDeployedCodePackageDescription,
			Constraints: []validation.Constraint{{Target: "restartDeployedCodePackageDescription.ServiceManifestName", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "restartDeployedCodePackageDescription.CodePackageName", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "restartDeployedCodePackageDescription.CodePackageInstanceID", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "RestartDeployedCodePackage")
	}

	req, err := client.RestartDeployedCodePackagePreparer(ctx, nodeName, applicationID, restartDeployedCodePackageDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RestartDeployedCodePackage", nil, "Failure preparing request")
		return
	}

	resp, err := client.RestartDeployedCodePackageSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RestartDeployedCodePackage", resp, "Failure sending request")
		return
	}

	result, err = client.RestartDeployedCodePackageResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RestartDeployedCodePackage", resp, "Failure responding to request")
	}

	return
}

// RestartDeployedCodePackagePreparer prepares the RestartDeployedCodePackage request.
func (client BaseClient) RestartDeployedCodePackagePreparer(ctx context.Context, nodeName string, applicationID string, restartDeployedCodePackageDescription RestartDeployedCodePackageDescription, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
		"nodeName":      autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetCodePackages/$/Restart", pathParameters),
		autorest.WithJSON(restartDeployedCodePackageDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RestartDeployedCodePackageSender sends the RestartDeployedCodePackage request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RestartDeployedCodePackageSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// RestartDeployedCodePackageResponder handles the response to the RestartDeployedCodePackage request. The method always
// closes the http.Response Body.
func (client BaseClient) RestartDeployedCodePackageResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RestartNode restarts a Service Fabric cluster node that is already started.
//
// nodeName is the name of the node. restartNodeDescription is the instance of the node to be restarted and a flag
// indicating the need to take dump of the fabric process. timeout is the server timeout for performing the operation
// in seconds. This specifies the time duration that the client is willing to wait for the requested operation to
// complete. The default value for this parameter is 60 seconds.
func (client BaseClient) RestartNode(ctx context.Context, nodeName string, restartNodeDescription RestartNodeDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: restartNodeDescription,
			Constraints: []validation.Constraint{{Target: "restartNodeDescription.NodeInstanceID", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "RestartNode")
	}

	req, err := client.RestartNodePreparer(ctx, nodeName, restartNodeDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RestartNode", nil, "Failure preparing request")
		return
	}

	resp, err := client.RestartNodeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RestartNode", resp, "Failure sending request")
		return
	}

	result, err = client.RestartNodeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RestartNode", resp, "Failure responding to request")
	}

	return
}

// RestartNodePreparer prepares the RestartNode request.
func (client BaseClient) RestartNodePreparer(ctx context.Context, nodeName string, restartNodeDescription RestartNodeDescription, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/Restart", pathParameters),
		autorest.WithJSON(restartNodeDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RestartNodeSender sends the RestartNode request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RestartNodeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// RestartNodeResponder handles the response to the RestartNode request. The method always
// closes the http.Response Body.
func (client BaseClient) RestartNodeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RestartReplica restarts a service replica of a persisted service running on a node. Warning - There are no safety
// checks performed when this API is used. Incorrect use of this API can lead to availability loss for stateful
// services.
//
// nodeName is the name of the node. partitionID is the identity of the partition. replicaID is the identifier of the
// replica. timeout is the server timeout for performing the operation in seconds. This specifies the time duration
// that the client is willing to wait for the requested operation to complete. The default value for this parameter is
// 60 seconds.
func (client BaseClient) RestartReplica(ctx context.Context, nodeName string, partitionID uuid.UUID, replicaID string, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "RestartReplica")
	}

	req, err := client.RestartReplicaPreparer(ctx, nodeName, partitionID, replicaID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RestartReplica", nil, "Failure preparing request")
		return
	}

	resp, err := client.RestartReplicaSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RestartReplica", resp, "Failure sending request")
		return
	}

	result, err = client.RestartReplicaResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RestartReplica", resp, "Failure responding to request")
	}

	return
}

// RestartReplicaPreparer prepares the RestartReplica request.
func (client BaseClient) RestartReplicaPreparer(ctx context.Context, nodeName string, partitionID uuid.UUID, replicaID string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName":    autorest.Encode("path", nodeName),
		"partitionId": partitionID,
		"replicaId":   replicaID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas/{replicaId}/$/Restart", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RestartReplicaSender sends the RestartReplica request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RestartReplicaSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// RestartReplicaResponder handles the response to the RestartReplica request. The method always
// closes the http.Response Body.
func (client BaseClient) RestartReplicaResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ResumeApplicationUpgrade resumes an unmonitored manual Service Fabric application upgrade. Service Fabric upgrades
// one upgrade domain at a time. For unmonitored manual upgrades, after Service Fabric finishes an upgrade domain, it
// waits for you to call this API before proceeding to the next upgrade domain.
//
// applicationID is the identity of the application. This is typically the full name of the application without the
// 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For
// example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+
// and "myapp/app1" in previous versions. resumeApplicationUpgradeDescription is describes the parameters for resuming
// an application upgrade. timeout is the server timeout for performing the operation in seconds. This specifies the
// time duration that the client is willing to wait for the requested operation to complete. The default value for this
// parameter is 60 seconds.
func (client BaseClient) ResumeApplicationUpgrade(ctx context.Context, applicationID string, resumeApplicationUpgradeDescription ResumeApplicationUpgradeDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resumeApplicationUpgradeDescription,
			Constraints: []validation.Constraint{{Target: "resumeApplicationUpgradeDescription.UpgradeDomainName", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "ResumeApplicationUpgrade")
	}

	req, err := client.ResumeApplicationUpgradePreparer(ctx, applicationID, resumeApplicationUpgradeDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ResumeApplicationUpgrade", nil, "Failure preparing request")
		return
	}

	resp, err := client.ResumeApplicationUpgradeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ResumeApplicationUpgrade", resp, "Failure sending request")
		return
	}

	result, err = client.ResumeApplicationUpgradeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ResumeApplicationUpgrade", resp, "Failure responding to request")
	}

	return
}

// ResumeApplicationUpgradePreparer prepares the ResumeApplicationUpgrade request.
func (client BaseClient) ResumeApplicationUpgradePreparer(ctx context.Context, applicationID string, resumeApplicationUpgradeDescription ResumeApplicationUpgradeDescription, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/MoveToNextUpgradeDomain", pathParameters),
		autorest.WithJSON(resumeApplicationUpgradeDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ResumeApplicationUpgradeSender sends the ResumeApplicationUpgrade request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ResumeApplicationUpgradeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ResumeApplicationUpgradeResponder handles the response to the ResumeApplicationUpgrade request. The method always
// closes the http.Response Body.
func (client BaseClient) ResumeApplicationUpgradeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ResumeClusterUpgrade make the cluster upgrade move on to the next upgrade domain.
//
// resumeClusterUpgradeDescription is describes the parameters for resuming a cluster upgrade. timeout is the server
// timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait
// for the requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) ResumeClusterUpgrade(ctx context.Context, resumeClusterUpgradeDescription ResumeClusterUpgradeDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resumeClusterUpgradeDescription,
			Constraints: []validation.Constraint{{Target: "resumeClusterUpgradeDescription.UpgradeDomain", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "ResumeClusterUpgrade")
	}

	req, err := client.ResumeClusterUpgradePreparer(ctx, resumeClusterUpgradeDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ResumeClusterUpgrade", nil, "Failure preparing request")
		return
	}

	resp, err := client.ResumeClusterUpgradeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ResumeClusterUpgrade", resp, "Failure sending request")
		return
	}

	result, err = client.ResumeClusterUpgradeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ResumeClusterUpgrade", resp, "Failure responding to request")
	}

	return
}

// ResumeClusterUpgradePreparer prepares the ResumeClusterUpgrade request.
func (client BaseClient) ResumeClusterUpgradePreparer(ctx context.Context, resumeClusterUpgradeDescription ResumeClusterUpgradeDescription, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/MoveToNextUpgradeDomain"),
		autorest.WithJSON(resumeClusterUpgradeDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ResumeClusterUpgradeSender sends the ResumeClusterUpgrade request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ResumeClusterUpgradeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ResumeClusterUpgradeResponder handles the response to the ResumeClusterUpgrade request. The method always
// closes the http.Response Body.
func (client BaseClient) ResumeClusterUpgradeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RollbackApplicationUpgrade starts rolling back the current application upgrade to the previous version. This API can
// only be used to rollback the current in-progress upgrade that is rolling forward to new version. If the application
// is not currently being upgraded use StartApplicationUpgrade API to upgrade it to desired version including rolling
// back to a previous version.
//
// applicationID is the identity of the application. This is typically the full name of the application without the
// 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For
// example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+
// and "myapp/app1" in previous versions. timeout is the server timeout for performing the operation in seconds. This
// specifies the time duration that the client is willing to wait for the requested operation to complete. The default
// value for this parameter is 60 seconds.
func (client BaseClient) RollbackApplicationUpgrade(ctx context.Context, applicationID string, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "RollbackApplicationUpgrade")
	}

	req, err := client.RollbackApplicationUpgradePreparer(ctx, applicationID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RollbackApplicationUpgrade", nil, "Failure preparing request")
		return
	}

	resp, err := client.RollbackApplicationUpgradeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RollbackApplicationUpgrade", resp, "Failure sending request")
		return
	}

	result, err = client.RollbackApplicationUpgradeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RollbackApplicationUpgrade", resp, "Failure responding to request")
	}

	return
}

// RollbackApplicationUpgradePreparer prepares the RollbackApplicationUpgrade request.
func (client BaseClient) RollbackApplicationUpgradePreparer(ctx context.Context, applicationID string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/RollbackUpgrade", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RollbackApplicationUpgradeSender sends the RollbackApplicationUpgrade request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RollbackApplicationUpgradeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// RollbackApplicationUpgradeResponder handles the response to the RollbackApplicationUpgrade request. The method always
// closes the http.Response Body.
func (client BaseClient) RollbackApplicationUpgradeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RollbackClusterUpgrade rollback the upgrade of a Service Fabric cluster.
//
// timeout is the server timeout for performing the operation in seconds. This specifies the time duration that the
// client is willing to wait for the requested operation to complete. The default value for this parameter is 60
// seconds.
func (client BaseClient) RollbackClusterUpgrade(ctx context.Context, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "RollbackClusterUpgrade")
	}

	req, err := client.RollbackClusterUpgradePreparer(ctx, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RollbackClusterUpgrade", nil, "Failure preparing request")
		return
	}

	resp, err := client.RollbackClusterUpgradeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RollbackClusterUpgrade", resp, "Failure sending request")
		return
	}

	result, err = client.RollbackClusterUpgradeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RollbackClusterUpgrade", resp, "Failure responding to request")
	}

	return
}

// RollbackClusterUpgradePreparer prepares the RollbackClusterUpgrade request.
func (client BaseClient) RollbackClusterUpgradePreparer(ctx context.Context, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/RollbackUpgrade"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RollbackClusterUpgradeSender sends the RollbackClusterUpgrade request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RollbackClusterUpgradeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// RollbackClusterUpgradeResponder handles the response to the RollbackClusterUpgrade request. The method always
// closes the http.Response Body.
func (client BaseClient) RollbackClusterUpgradeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// StartApplicationUpgrade validates the supplied application upgrade parameters and starts upgrading the application
// if the parameters are valid.
//
// applicationID is the identity of the application. This is typically the full name of the application without the
// 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For
// example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+
// and "myapp/app1" in previous versions. applicationUpgradeDescription is parameters for an application upgrade.
// timeout is the server timeout for performing the operation in seconds. This specifies the time duration that the
// client is willing to wait for the requested operation to complete. The default value for this parameter is 60
// seconds.
func (client BaseClient) StartApplicationUpgrade(ctx context.Context, applicationID string, applicationUpgradeDescription ApplicationUpgradeDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: applicationUpgradeDescription,
			Constraints: []validation.Constraint{{Target: "applicationUpgradeDescription.Name", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "applicationUpgradeDescription.TargetApplicationTypeVersion", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "applicationUpgradeDescription.Parameters", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "StartApplicationUpgrade")
	}

	req, err := client.StartApplicationUpgradePreparer(ctx, applicationID, applicationUpgradeDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartApplicationUpgrade", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartApplicationUpgradeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartApplicationUpgrade", resp, "Failure sending request")
		return
	}

	result, err = client.StartApplicationUpgradeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartApplicationUpgrade", resp, "Failure responding to request")
	}

	return
}

// StartApplicationUpgradePreparer prepares the StartApplicationUpgrade request.
func (client BaseClient) StartApplicationUpgradePreparer(ctx context.Context, applicationID string, applicationUpgradeDescription ApplicationUpgradeDescription, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/Upgrade", pathParameters),
		autorest.WithJSON(applicationUpgradeDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StartApplicationUpgradeSender sends the StartApplicationUpgrade request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) StartApplicationUpgradeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// StartApplicationUpgradeResponder handles the response to the StartApplicationUpgrade request. The method always
// closes the http.Response Body.
func (client BaseClient) StartApplicationUpgradeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// StartChaos if Chaos is not already running in the cluster, it starts Chaos with the passed in Chaos parameters.
// If Chaos is already running when this call is made, the call fails with the error code
// FABRIC_E_CHAOS_ALREADY_RUNNING.
// Please refer to the article [Induce controlled Chaos in Service Fabric
// clusters](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-controlled-chaos) for more details.
//
// chaosParameters is describes all the parameters to configure a Chaos run. timeout is the server timeout for
// performing the operation in seconds. This specifies the time duration that the client is willing to wait for the
// requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) StartChaos(ctx context.Context, chaosParameters ChaosParameters, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: chaosParameters,
			Constraints: []validation.Constraint{{Target: "chaosParameters.MaxClusterStabilizationTimeoutInSeconds", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "chaosParameters.MaxClusterStabilizationTimeoutInSeconds", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "chaosParameters.MaxClusterStabilizationTimeoutInSeconds", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil},
				}},
				{Target: "chaosParameters.MaxConcurrentFaults", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "chaosParameters.MaxConcurrentFaults", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
						{Target: "chaosParameters.MaxConcurrentFaults", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil},
					}},
				{Target: "chaosParameters.WaitTimeBetweenFaultsInSeconds", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "chaosParameters.WaitTimeBetweenFaultsInSeconds", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
						{Target: "chaosParameters.WaitTimeBetweenFaultsInSeconds", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil},
					}},
				{Target: "chaosParameters.WaitTimeBetweenIterationsInSeconds", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "chaosParameters.WaitTimeBetweenIterationsInSeconds", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
						{Target: "chaosParameters.WaitTimeBetweenIterationsInSeconds", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil},
					}}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "StartChaos")
	}

	req, err := client.StartChaosPreparer(ctx, chaosParameters, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartChaos", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartChaosSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartChaos", resp, "Failure sending request")
		return
	}

	result, err = client.StartChaosResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartChaos", resp, "Failure responding to request")
	}

	return
}

// StartChaosPreparer prepares the StartChaos request.
func (client BaseClient) StartChaosPreparer(ctx context.Context, chaosParameters ChaosParameters, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/Tools/Chaos/$/Start"),
		autorest.WithJSON(chaosParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StartChaosSender sends the StartChaos request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) StartChaosSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// StartChaosResponder handles the response to the StartChaos request. The method always
// closes the http.Response Body.
func (client BaseClient) StartChaosResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// StartClusterConfigurationUpgrade validate the supplied configuration upgrade parameters and start upgrading the
// cluster configuration if the parameters are valid.
//
// clusterConfigurationUpgradeDescription is parameters for a standalone cluster configuration upgrade. timeout is the
// server timeout for performing the operation in seconds. This specifies the time duration that the client is willing
// to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) StartClusterConfigurationUpgrade(ctx context.Context, clusterConfigurationUpgradeDescription ClusterConfigurationUpgradeDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: clusterConfigurationUpgradeDescription,
			Constraints: []validation.Constraint{{Target: "clusterConfigurationUpgradeDescription.ClusterConfig", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "StartClusterConfigurationUpgrade")
	}

	req, err := client.StartClusterConfigurationUpgradePreparer(ctx, clusterConfigurationUpgradeDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartClusterConfigurationUpgrade", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartClusterConfigurationUpgradeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartClusterConfigurationUpgrade", resp, "Failure sending request")
		return
	}

	result, err = client.StartClusterConfigurationUpgradeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartClusterConfigurationUpgrade", resp, "Failure responding to request")
	}

	return
}

// StartClusterConfigurationUpgradePreparer prepares the StartClusterConfigurationUpgrade request.
func (client BaseClient) StartClusterConfigurationUpgradePreparer(ctx context.Context, clusterConfigurationUpgradeDescription ClusterConfigurationUpgradeDescription, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/StartClusterConfigurationUpgrade"),
		autorest.WithJSON(clusterConfigurationUpgradeDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StartClusterConfigurationUpgradeSender sends the StartClusterConfigurationUpgrade request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) StartClusterConfigurationUpgradeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// StartClusterConfigurationUpgradeResponder handles the response to the StartClusterConfigurationUpgrade request. The method always
// closes the http.Response Body.
func (client BaseClient) StartClusterConfigurationUpgradeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// StartClusterUpgrade validate the supplied upgrade parameters and start upgrading the code or configuration version
// of a Service Fabric cluster if the parameters are valid.
//
// startClusterUpgradeDescription is describes the parameters for starting a cluster upgrade. timeout is the server
// timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait
// for the requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) StartClusterUpgrade(ctx context.Context, startClusterUpgradeDescription StartClusterUpgradeDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: startClusterUpgradeDescription,
			Constraints: []validation.Constraint{{Target: "startClusterUpgradeDescription.ClusterUpgradeHealthPolicy", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "startClusterUpgradeDescription.ClusterUpgradeHealthPolicy.MaxPercentDeltaUnhealthyNodes", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "startClusterUpgradeDescription.ClusterUpgradeHealthPolicy.MaxPercentDeltaUnhealthyNodes", Name: validation.InclusiveMaximum, Rule: 100, Chain: nil},
						{Target: "startClusterUpgradeDescription.ClusterUpgradeHealthPolicy.MaxPercentDeltaUnhealthyNodes", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil},
					}},
					{Target: "startClusterUpgradeDescription.ClusterUpgradeHealthPolicy.MaxPercentUpgradeDomainDeltaUnhealthyNodes", Name: validation.Null, Rule: false,
						Chain: []validation.Constraint{{Target: "startClusterUpgradeDescription.ClusterUpgradeHealthPolicy.MaxPercentUpgradeDomainDeltaUnhealthyNodes", Name: validation.InclusiveMaximum, Rule: 100, Chain: nil},
							{Target: "startClusterUpgradeDescription.ClusterUpgradeHealthPolicy.MaxPercentUpgradeDomainDeltaUnhealthyNodes", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil},
						}},
				}}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "StartClusterUpgrade")
	}

	req, err := client.StartClusterUpgradePreparer(ctx, startClusterUpgradeDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartClusterUpgrade", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartClusterUpgradeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartClusterUpgrade", resp, "Failure sending request")
		return
	}

	result, err = client.StartClusterUpgradeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartClusterUpgrade", resp, "Failure responding to request")
	}

	return
}

// StartClusterUpgradePreparer prepares the StartClusterUpgrade request.
func (client BaseClient) StartClusterUpgradePreparer(ctx context.Context, startClusterUpgradeDescription StartClusterUpgradeDescription, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/Upgrade"),
		autorest.WithJSON(startClusterUpgradeDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StartClusterUpgradeSender sends the StartClusterUpgrade request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) StartClusterUpgradeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// StartClusterUpgradeResponder handles the response to the StartClusterUpgrade request. The method always
// closes the http.Response Body.
func (client BaseClient) StartClusterUpgradeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// StartComposeDeploymentUpgrade validates the supplied upgrade parameters and starts upgrading the deployment if the
// parameters are valid.
//
// deploymentName is the identity of the deployment. composeDeploymentUpgradeDescription is parameters for upgrading
// compose deployment. timeout is the server timeout for performing the operation in seconds. This specifies the time
// duration that the client is willing to wait for the requested operation to complete. The default value for this
// parameter is 60 seconds.
func (client BaseClient) StartComposeDeploymentUpgrade(ctx context.Context, deploymentName string, composeDeploymentUpgradeDescription ComposeDeploymentUpgradeDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: composeDeploymentUpgradeDescription,
			Constraints: []validation.Constraint{{Target: "composeDeploymentUpgradeDescription.DeploymentName", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "composeDeploymentUpgradeDescription.ComposeFileContent", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "StartComposeDeploymentUpgrade")
	}

	req, err := client.StartComposeDeploymentUpgradePreparer(ctx, deploymentName, composeDeploymentUpgradeDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartComposeDeploymentUpgrade", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartComposeDeploymentUpgradeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartComposeDeploymentUpgrade", resp, "Failure sending request")
		return
	}

	result, err = client.StartComposeDeploymentUpgradeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartComposeDeploymentUpgrade", resp, "Failure responding to request")
	}

	return
}

// StartComposeDeploymentUpgradePreparer prepares the StartComposeDeploymentUpgrade request.
func (client BaseClient) StartComposeDeploymentUpgradePreparer(ctx context.Context, deploymentName string, composeDeploymentUpgradeDescription ComposeDeploymentUpgradeDescription, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"deploymentName": deploymentName,
	}

	const APIVersion = "6.0-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ComposeDeployments/{deploymentName}/$/Upgrade", pathParameters),
		autorest.WithJSON(composeDeploymentUpgradeDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StartComposeDeploymentUpgradeSender sends the StartComposeDeploymentUpgrade request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) StartComposeDeploymentUpgradeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// StartComposeDeploymentUpgradeResponder handles the response to the StartComposeDeploymentUpgrade request. The method always
// closes the http.Response Body.
func (client BaseClient) StartComposeDeploymentUpgradeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// StartDataLoss this API will induce data loss for the specified partition. It will trigger a call to the OnDataLoss
// API of the partition.
// Actual data loss will depend on the specified DataLossMode
// PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is triggered for the partition but actual
// data loss depends on the presence of in-flight replication.
// FullDataLoss - All replicas are removed hence all data is lost and OnDataLoss is triggered.
//
// This API should only be called with a stateful service as the target.
//
// Calling this API with a system service as the target is not advised.
//
// Note:  Once this API has been called, it cannot be reversed. Calling CancelOperation will only stop execution and
// clean up internal system state.
// It will not restore data if the command has progressed far enough to cause data loss.
//
// Call the GetDataLossProgress API with the same OperationId to return information on the operation started with this
// API.
//
// serviceID is the identity of the service. This is typically the full name of the service without the 'fabric:' URI
// scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the
// service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and
// "myapp/app1/svc1" in previous versions. partitionID is the identity of the partition. operationID is a GUID that
// identifies a call of this API.  This is passed into the corresponding GetProgress API dataLossMode is this enum is
// passed to the StartDataLoss API to indicate what type of data loss to induce.
// - Invalid - Reserved.  Do not pass into API.
// - PartialDataLoss - PartialDataLoss option will cause a quorum of replicas to go down, triggering an OnDataLoss
// event in the system for the given partition.
// - FullDataLoss - FullDataLoss option will drop all the replicas which means that all the data will be lost. timeout
// is the server timeout for performing the operation in seconds. This specifies the time duration that the client is
// willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) StartDataLoss(ctx context.Context, serviceID string, partitionID uuid.UUID, operationID uuid.UUID, dataLossMode string, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "StartDataLoss")
	}

	req, err := client.StartDataLossPreparer(ctx, serviceID, partitionID, operationID, dataLossMode, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartDataLoss", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartDataLossSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartDataLoss", resp, "Failure sending request")
		return
	}

	result, err = client.StartDataLossResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartDataLoss", resp, "Failure responding to request")
	}

	return
}

// StartDataLossPreparer prepares the StartDataLoss request.
func (client BaseClient) StartDataLossPreparer(ctx context.Context, serviceID string, partitionID uuid.UUID, operationID uuid.UUID, dataLossMode string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
		"serviceId":   serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version":  APIVersion,
		"DataLossMode": autorest.Encode("query", dataLossMode),
		"OperationId":  autorest.Encode("query", operationID),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/StartDataLoss", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StartDataLossSender sends the StartDataLoss request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) StartDataLossSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// StartDataLossResponder handles the response to the StartDataLoss request. The method always
// closes the http.Response Body.
func (client BaseClient) StartDataLossResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// StartNodeTransition starts or stops a cluster node.  A cluster node is a process, not the OS instance itself.  To
// start a node, pass in "Start" for the NodeTransitionType parameter.
// To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This API starts the operation - when the API
// returns the node may not have finished transitioning yet.
// Call GetNodeTransitionProgress with the same OperationId to get the progress of the operation.
//
// nodeName is the name of the node. operationID is a GUID that identifies a call of this API.  This is passed into the
// corresponding GetProgress API nodeTransitionType is indicates the type of transition to perform.
// NodeTransitionType.Start will start a stopped node.  NodeTransitionType.Stop will stop a node that is up.
// - Invalid - Reserved.  Do not pass into API.
// - Start - Transition a stopped node to up.
// - Stop - Transition an up node to stopped. nodeInstanceID is the node instance ID of the target node.  This can be
// determined through GetNodeInfo API. stopDurationInSeconds is the duration, in seconds, to keep the node stopped.
// The minimum value is 600, the maximum is 14400.  After this time expires, the node will automatically come back up.
// timeout is the server timeout for performing the operation in seconds. This specifies the time duration that the
// client is willing to wait for the requested operation to complete. The default value for this parameter is 60
// seconds.
func (client BaseClient) StartNodeTransition(ctx context.Context, nodeName string, operationID uuid.UUID, nodeTransitionType string, nodeInstanceID string, stopDurationInSeconds int32, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: stopDurationInSeconds,
			Constraints: []validation.Constraint{{Target: "stopDurationInSeconds", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "StartNodeTransition")
	}

	req, err := client.StartNodeTransitionPreparer(ctx, nodeName, operationID, nodeTransitionType, nodeInstanceID, stopDurationInSeconds, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartNodeTransition", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartNodeTransitionSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartNodeTransition", resp, "Failure sending request")
		return
	}

	result, err = client.StartNodeTransitionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartNodeTransition", resp, "Failure responding to request")
	}

	return
}

// StartNodeTransitionPreparer prepares the StartNodeTransition request.
func (client BaseClient) StartNodeTransitionPreparer(ctx context.Context, nodeName string, operationID uuid.UUID, nodeTransitionType string, nodeInstanceID string, stopDurationInSeconds int32, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version":           APIVersion,
		"NodeInstanceId":        autorest.Encode("query", nodeInstanceID),
		"NodeTransitionType":    autorest.Encode("query", nodeTransitionType),
		"OperationId":           autorest.Encode("query", operationID),
		"StopDurationInSeconds": autorest.Encode("query", stopDurationInSeconds),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Faults/Nodes/{nodeName}/$/StartTransition/", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StartNodeTransitionSender sends the StartNodeTransition request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) StartNodeTransitionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// StartNodeTransitionResponder handles the response to the StartNodeTransition request. The method always
// closes the http.Response Body.
func (client BaseClient) StartNodeTransitionResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// StartPartitionRestart this API is useful for testing failover.
//
// If used to target a stateless service partition, RestartPartitionMode must be AllReplicasOrInstances.
//
// Call the GetPartitionRestartProgress API using the same OperationId to get the progress.
//
// serviceID is the identity of the service. This is typically the full name of the service without the 'fabric:' URI
// scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the
// service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and
// "myapp/app1/svc1" in previous versions. partitionID is the identity of the partition. operationID is a GUID that
// identifies a call of this API.  This is passed into the corresponding GetProgress API restartPartitionMode is -
// Invalid - Reserved.  Do not pass into API.
// - AllReplicasOrInstances - All replicas or instances in the partition are restarted at once.
// - OnlyActiveSecondaries - Only the secondary replicas are restarted. timeout is the server timeout for performing
// the operation in seconds. This specifies the time duration that the client is willing to wait for the requested
// operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) StartPartitionRestart(ctx context.Context, serviceID string, partitionID uuid.UUID, operationID uuid.UUID, restartPartitionMode string, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "StartPartitionRestart")
	}

	req, err := client.StartPartitionRestartPreparer(ctx, serviceID, partitionID, operationID, restartPartitionMode, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartPartitionRestart", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartPartitionRestartSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartPartitionRestart", resp, "Failure sending request")
		return
	}

	result, err = client.StartPartitionRestartResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartPartitionRestart", resp, "Failure responding to request")
	}

	return
}

// StartPartitionRestartPreparer prepares the StartPartitionRestart request.
func (client BaseClient) StartPartitionRestartPreparer(ctx context.Context, serviceID string, partitionID uuid.UUID, operationID uuid.UUID, restartPartitionMode string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
		"serviceId":   serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version":          APIVersion,
		"OperationId":          autorest.Encode("query", operationID),
		"RestartPartitionMode": autorest.Encode("query", restartPartitionMode),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/StartRestart", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StartPartitionRestartSender sends the StartPartitionRestart request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) StartPartitionRestartSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// StartPartitionRestartResponder handles the response to the StartPartitionRestart request. The method always
// closes the http.Response Body.
func (client BaseClient) StartPartitionRestartResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// StartQuorumLoss induces quorum loss for a given stateful service partition.  This API is useful for a temporary
// quorum loss situation on your service.
//
// Call the GetQuorumLossProgress API with the same OperationId to return information on the operation started with
// this API.
//
// This can only be called on stateful persisted (HasPersistedState==true) services.  Do not use this API on stateless
// services or stateful in-memory only services.
//
// serviceID is the identity of the service. This is typically the full name of the service without the 'fabric:' URI
// scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the
// service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and
// "myapp/app1/svc1" in previous versions. partitionID is the identity of the partition. operationID is a GUID that
// identifies a call of this API.  This is passed into the corresponding GetProgress API quorumLossMode is this enum is
// passed to the StartQuorumLoss API to indicate what type of quorum loss to induce.
// - Invalid - Reserved.  Do not pass into API.
// - QuorumReplicas - Partial Quorum loss mode : Minimum number of replicas for a partition will be down that will
// cause a quorum loss.
// - AllReplicas- Full Quorum loss mode : All replicas for a partition will be down that will cause a quorum loss.
// quorumLossDuration is the amount of time for which the partition will be kept in quorum loss.  This must be
// specified in seconds. timeout is the server timeout for performing the operation in seconds. This specifies the time
// duration that the client is willing to wait for the requested operation to complete. The default value for this
// parameter is 60 seconds.
func (client BaseClient) StartQuorumLoss(ctx context.Context, serviceID string, partitionID uuid.UUID, operationID uuid.UUID, quorumLossMode string, quorumLossDuration int32, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "StartQuorumLoss")
	}

	req, err := client.StartQuorumLossPreparer(ctx, serviceID, partitionID, operationID, quorumLossMode, quorumLossDuration, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartQuorumLoss", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartQuorumLossSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartQuorumLoss", resp, "Failure sending request")
		return
	}

	result, err = client.StartQuorumLossResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartQuorumLoss", resp, "Failure responding to request")
	}

	return
}

// StartQuorumLossPreparer prepares the StartQuorumLoss request.
func (client BaseClient) StartQuorumLossPreparer(ctx context.Context, serviceID string, partitionID uuid.UUID, operationID uuid.UUID, quorumLossMode string, quorumLossDuration int32, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
		"serviceId":   serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version":        APIVersion,
		"OperationId":        autorest.Encode("query", operationID),
		"QuorumLossDuration": autorest.Encode("query", quorumLossDuration),
		"QuorumLossMode":     autorest.Encode("query", quorumLossMode),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/StartQuorumLoss", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StartQuorumLossSender sends the StartQuorumLoss request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) StartQuorumLossSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// StartQuorumLossResponder handles the response to the StartQuorumLoss request. The method always
// closes the http.Response Body.
func (client BaseClient) StartQuorumLossResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// StopChaos stops Chaos from scheduling further faults; but, the in-flight faults are not affected.
//
// timeout is the server timeout for performing the operation in seconds. This specifies the time duration that the
// client is willing to wait for the requested operation to complete. The default value for this parameter is 60
// seconds.
func (client BaseClient) StopChaos(ctx context.Context, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "StopChaos")
	}

	req, err := client.StopChaosPreparer(ctx, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StopChaos", nil, "Failure preparing request")
		return
	}

	resp, err := client.StopChaosSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StopChaos", resp, "Failure sending request")
		return
	}

	result, err = client.StopChaosResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StopChaos", resp, "Failure responding to request")
	}

	return
}

// StopChaosPreparer prepares the StopChaos request.
func (client BaseClient) StopChaosPreparer(ctx context.Context, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/Tools/Chaos/$/Stop"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StopChaosSender sends the StopChaos request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) StopChaosSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// StopChaosResponder handles the response to the StopChaos request. The method always
// closes the http.Response Body.
func (client BaseClient) StopChaosResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// SubmitPropertyBatch submits a batch of property operations. Either all or none of the operations will be committed.
//
// nameID is the Service Fabric name, without the 'fabric:' URI scheme. propertyBatchDescriptionList is describes the
// property batch operations to be submitted. timeout is the server timeout for performing the operation in seconds.
// This specifies the time duration that the client is willing to wait for the requested operation to complete. The
// default value for this parameter is 60 seconds.
func (client BaseClient) SubmitPropertyBatch(ctx context.Context, nameID string, propertyBatchDescriptionList PropertyBatchDescriptionList, timeout *int64) (result PropertyBatchInfoModel, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "SubmitPropertyBatch")
	}

	req, err := client.SubmitPropertyBatchPreparer(ctx, nameID, propertyBatchDescriptionList, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "SubmitPropertyBatch", nil, "Failure preparing request")
		return
	}

	resp, err := client.SubmitPropertyBatchSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "SubmitPropertyBatch", resp, "Failure sending request")
		return
	}

	result, err = client.SubmitPropertyBatchResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "SubmitPropertyBatch", resp, "Failure responding to request")
	}

	return
}

// SubmitPropertyBatchPreparer prepares the SubmitPropertyBatch request.
func (client BaseClient) SubmitPropertyBatchPreparer(ctx context.Context, nameID string, propertyBatchDescriptionList PropertyBatchDescriptionList, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nameId": nameID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Names/{nameId}/$/GetProperties/$/SubmitBatch", pathParameters),
		autorest.WithJSON(propertyBatchDescriptionList),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// SubmitPropertyBatchSender sends the SubmitPropertyBatch request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) SubmitPropertyBatchSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// SubmitPropertyBatchResponder handles the response to the SubmitPropertyBatch request. The method always
// closes the http.Response Body.
func (client BaseClient) SubmitPropertyBatchResponder(resp *http.Response) (result PropertyBatchInfoModel, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusConflict),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UnprovisionApplicationType removes or unregisters a Service Fabric application type from the cluster. This operation
// can only be performed if all application instance of the application type has been deleted. Once the application
// type is unregistered, no new application instance can be created for this particular application type.
//
// applicationTypeName is the name of the application type. applicationTypeImageStoreVersion is the version of the
// application type in the image store. timeout is the server timeout for performing the operation in seconds. This
// specifies the time duration that the client is willing to wait for the requested operation to complete. The default
// value for this parameter is 60 seconds.
func (client BaseClient) UnprovisionApplicationType(ctx context.Context, applicationTypeName string, applicationTypeImageStoreVersion ApplicationTypeImageStoreVersion, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: applicationTypeImageStoreVersion,
			Constraints: []validation.Constraint{{Target: "applicationTypeImageStoreVersion.ApplicationTypeVersion", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "UnprovisionApplicationType")
	}

	req, err := client.UnprovisionApplicationTypePreparer(ctx, applicationTypeName, applicationTypeImageStoreVersion, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UnprovisionApplicationType", nil, "Failure preparing request")
		return
	}

	resp, err := client.UnprovisionApplicationTypeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UnprovisionApplicationType", resp, "Failure sending request")
		return
	}

	result, err = client.UnprovisionApplicationTypeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UnprovisionApplicationType", resp, "Failure responding to request")
	}

	return
}

// UnprovisionApplicationTypePreparer prepares the UnprovisionApplicationType request.
func (client BaseClient) UnprovisionApplicationTypePreparer(ctx context.Context, applicationTypeName string, applicationTypeImageStoreVersion ApplicationTypeImageStoreVersion, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationTypeName": autorest.Encode("path", applicationTypeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ApplicationTypes/{applicationTypeName}/$/Unprovision", pathParameters),
		autorest.WithJSON(applicationTypeImageStoreVersion),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UnprovisionApplicationTypeSender sends the UnprovisionApplicationType request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UnprovisionApplicationTypeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UnprovisionApplicationTypeResponder handles the response to the UnprovisionApplicationType request. The method always
// closes the http.Response Body.
func (client BaseClient) UnprovisionApplicationTypeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// UnprovisionCluster unprovision the code or configuration packages of a Service Fabric cluster.
//
// unprovisionFabricDescription is describes the parameters for unprovisioning a cluster. timeout is the server timeout
// for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the
// requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) UnprovisionCluster(ctx context.Context, unprovisionFabricDescription UnprovisionFabricDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "UnprovisionCluster")
	}

	req, err := client.UnprovisionClusterPreparer(ctx, unprovisionFabricDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UnprovisionCluster", nil, "Failure preparing request")
		return
	}

	resp, err := client.UnprovisionClusterSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UnprovisionCluster", resp, "Failure sending request")
		return
	}

	result, err = client.UnprovisionClusterResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UnprovisionCluster", resp, "Failure responding to request")
	}

	return
}

// UnprovisionClusterPreparer prepares the UnprovisionCluster request.
func (client BaseClient) UnprovisionClusterPreparer(ctx context.Context, unprovisionFabricDescription UnprovisionFabricDescription, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/Unprovision"),
		autorest.WithJSON(unprovisionFabricDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UnprovisionClusterSender sends the UnprovisionCluster request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UnprovisionClusterSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UnprovisionClusterResponder handles the response to the UnprovisionCluster request. The method always
// closes the http.Response Body.
func (client BaseClient) UnprovisionClusterResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// UpdateApplicationUpgrade updates the parameters of an ongoing application upgrade from the ones specified at the
// time of starting the application upgrade. This may be required to mitigate stuck application upgrades due to
// incorrect parameters or issues in the application to make progress.
//
// applicationID is the identity of the application. This is typically the full name of the application without the
// 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For
// example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+
// and "myapp/app1" in previous versions. applicationUpgradeUpdateDescription is parameters for updating an existing
// application upgrade. timeout is the server timeout for performing the operation in seconds. This specifies the time
// duration that the client is willing to wait for the requested operation to complete. The default value for this
// parameter is 60 seconds.
func (client BaseClient) UpdateApplicationUpgrade(ctx context.Context, applicationID string, applicationUpgradeUpdateDescription ApplicationUpgradeUpdateDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: applicationUpgradeUpdateDescription,
			Constraints: []validation.Constraint{{Target: "applicationUpgradeUpdateDescription.Name", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "UpdateApplicationUpgrade")
	}

	req, err := client.UpdateApplicationUpgradePreparer(ctx, applicationID, applicationUpgradeUpdateDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateApplicationUpgrade", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateApplicationUpgradeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateApplicationUpgrade", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateApplicationUpgradeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateApplicationUpgrade", resp, "Failure responding to request")
	}

	return
}

// UpdateApplicationUpgradePreparer prepares the UpdateApplicationUpgrade request.
func (client BaseClient) UpdateApplicationUpgradePreparer(ctx context.Context, applicationID string, applicationUpgradeUpdateDescription ApplicationUpgradeUpdateDescription, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/UpdateUpgrade", pathParameters),
		autorest.WithJSON(applicationUpgradeUpdateDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateApplicationUpgradeSender sends the UpdateApplicationUpgrade request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateApplicationUpgradeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateApplicationUpgradeResponder handles the response to the UpdateApplicationUpgrade request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateApplicationUpgradeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// UpdateClusterUpgrade update the upgrade parameters of a Service Fabric cluster upgrade.
//
// updateClusterUpgradeDescription is parameters for updating a cluster upgrade. timeout is the server timeout for
// performing the operation in seconds. This specifies the time duration that the client is willing to wait for the
// requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) UpdateClusterUpgrade(ctx context.Context, updateClusterUpgradeDescription UpdateClusterUpgradeDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: updateClusterUpgradeDescription,
			Constraints: []validation.Constraint{{Target: "updateClusterUpgradeDescription.ClusterUpgradeHealthPolicy", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "updateClusterUpgradeDescription.ClusterUpgradeHealthPolicy.MaxPercentDeltaUnhealthyNodes", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "updateClusterUpgradeDescription.ClusterUpgradeHealthPolicy.MaxPercentDeltaUnhealthyNodes", Name: validation.InclusiveMaximum, Rule: 100, Chain: nil},
						{Target: "updateClusterUpgradeDescription.ClusterUpgradeHealthPolicy.MaxPercentDeltaUnhealthyNodes", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil},
					}},
					{Target: "updateClusterUpgradeDescription.ClusterUpgradeHealthPolicy.MaxPercentUpgradeDomainDeltaUnhealthyNodes", Name: validation.Null, Rule: false,
						Chain: []validation.Constraint{{Target: "updateClusterUpgradeDescription.ClusterUpgradeHealthPolicy.MaxPercentUpgradeDomainDeltaUnhealthyNodes", Name: validation.InclusiveMaximum, Rule: 100, Chain: nil},
							{Target: "updateClusterUpgradeDescription.ClusterUpgradeHealthPolicy.MaxPercentUpgradeDomainDeltaUnhealthyNodes", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil},
						}},
				}}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "UpdateClusterUpgrade")
	}

	req, err := client.UpdateClusterUpgradePreparer(ctx, updateClusterUpgradeDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateClusterUpgrade", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateClusterUpgradeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateClusterUpgrade", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateClusterUpgradeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateClusterUpgrade", resp, "Failure responding to request")
	}

	return
}

// UpdateClusterUpgradePreparer prepares the UpdateClusterUpgrade request.
func (client BaseClient) UpdateClusterUpgradePreparer(ctx context.Context, updateClusterUpgradeDescription UpdateClusterUpgradeDescription, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/UpdateUpgrade"),
		autorest.WithJSON(updateClusterUpgradeDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateClusterUpgradeSender sends the UpdateClusterUpgrade request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateClusterUpgradeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateClusterUpgradeResponder handles the response to the UpdateClusterUpgrade request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateClusterUpgradeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// UpdateRepairExecutionState this API supports the Service Fabric platform; it is not meant to be used directly from
// your code.
//
// repairTask is describes the repair task to be created or updated.
func (client BaseClient) UpdateRepairExecutionState(ctx context.Context, repairTask RepairTask) (result RepairTaskUpdateInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: repairTask,
			Constraints: []validation.Constraint{{Target: "repairTask.TaskID", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "repairTask.Action", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "UpdateRepairExecutionState")
	}

	req, err := client.UpdateRepairExecutionStatePreparer(ctx, repairTask)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateRepairExecutionState", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateRepairExecutionStateSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateRepairExecutionState", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateRepairExecutionStateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateRepairExecutionState", resp, "Failure responding to request")
	}

	return
}

// UpdateRepairExecutionStatePreparer prepares the UpdateRepairExecutionState request.
func (client BaseClient) UpdateRepairExecutionStatePreparer(ctx context.Context, repairTask RepairTask) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/UpdateRepairExecutionState"),
		autorest.WithJSON(repairTask),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateRepairExecutionStateSender sends the UpdateRepairExecutionState request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateRepairExecutionStateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateRepairExecutionStateResponder handles the response to the UpdateRepairExecutionState request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateRepairExecutionStateResponder(resp *http.Response) (result RepairTaskUpdateInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateRepairTaskHealthPolicy this API supports the Service Fabric platform; it is not meant to be used directly from
// your code.
//
// repairTaskUpdateHealthPolicyDescription is describes the repair task healthy policy to be updated.
func (client BaseClient) UpdateRepairTaskHealthPolicy(ctx context.Context, repairTaskUpdateHealthPolicyDescription RepairTaskUpdateHealthPolicyDescription) (result RepairTaskUpdateInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: repairTaskUpdateHealthPolicyDescription,
			Constraints: []validation.Constraint{{Target: "repairTaskUpdateHealthPolicyDescription.TaskID", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "UpdateRepairTaskHealthPolicy")
	}

	req, err := client.UpdateRepairTaskHealthPolicyPreparer(ctx, repairTaskUpdateHealthPolicyDescription)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateRepairTaskHealthPolicy", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateRepairTaskHealthPolicySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateRepairTaskHealthPolicy", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateRepairTaskHealthPolicyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateRepairTaskHealthPolicy", resp, "Failure responding to request")
	}

	return
}

// UpdateRepairTaskHealthPolicyPreparer prepares the UpdateRepairTaskHealthPolicy request.
func (client BaseClient) UpdateRepairTaskHealthPolicyPreparer(ctx context.Context, repairTaskUpdateHealthPolicyDescription RepairTaskUpdateHealthPolicyDescription) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/UpdateRepairTaskHealthPolicy"),
		autorest.WithJSON(repairTaskUpdateHealthPolicyDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateRepairTaskHealthPolicySender sends the UpdateRepairTaskHealthPolicy request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateRepairTaskHealthPolicySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateRepairTaskHealthPolicyResponder handles the response to the UpdateRepairTaskHealthPolicy request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateRepairTaskHealthPolicyResponder(resp *http.Response) (result RepairTaskUpdateInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateService updates the specified service using the given update description.
//
// serviceID is the identity of the service. This is typically the full name of the service without the 'fabric:' URI
// scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the
// service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and
// "myapp/app1/svc1" in previous versions. serviceUpdateDescription is the information necessary to update a service.
// timeout is the server timeout for performing the operation in seconds. This specifies the time duration that the
// client is willing to wait for the requested operation to complete. The default value for this parameter is 60
// seconds.
func (client BaseClient) UpdateService(ctx context.Context, serviceID string, serviceUpdateDescription BasicServiceUpdateDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "UpdateService")
	}

	req, err := client.UpdateServicePreparer(ctx, serviceID, serviceUpdateDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateService", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateServiceSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateService", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateServiceResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateService", resp, "Failure responding to request")
	}

	return
}

// UpdateServicePreparer prepares the UpdateService request.
func (client BaseClient) UpdateServicePreparer(ctx context.Context, serviceID string, serviceUpdateDescription BasicServiceUpdateDescription, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"serviceId": serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Services/{serviceId}/$/Update", pathParameters),
		autorest.WithJSON(serviceUpdateDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateServiceSender sends the UpdateService request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateServiceSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateServiceResponder handles the response to the UpdateService request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateServiceResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// UploadFile uploads contents of the file to the image store. Use this API if the file is small enough to upload again
// if the connection fails. The file's data needs to be added to the request body. The contents will be uploaded to the
// specified path. Image store service uses a mark file to indicate the availability of the folder. The mark file is an
// empty file named "_.dir". The mark file is generated by the image store service when all files in a folder are
// uploaded. When using File-by-File approach to upload application package in REST, the image store service isn't
// aware of the file hierarchy of the application package; you need to create a mark file per folder and upload it
// last, to let the image store service know that the folder is complete.
//
// contentPath is relative path to file or folder in the image store from its root. timeout is the server timeout for
// performing the operation in seconds. This specifies the time duration that the client is willing to wait for the
// requested operation to complete. The default value for this parameter is 60 seconds.
func (client BaseClient) UploadFile(ctx context.Context, contentPath string, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: 4294967295, Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "servicefabric.BaseClient", "UploadFile")
	}

	req, err := client.UploadFilePreparer(ctx, contentPath, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UploadFile", nil, "Failure preparing request")
		return
	}

	resp, err := client.UploadFileSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UploadFile", resp, "Failure sending request")
		return
	}

	result, err = client.UploadFileResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UploadFile", resp, "Failure responding to request")
	}

	return
}

// UploadFilePreparer prepares the UploadFile request.
func (client BaseClient) UploadFilePreparer(ctx context.Context, contentPath string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"contentPath": autorest.Encode("path", contentPath),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ImageStore/{contentPath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UploadFileSender sends the UploadFile request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UploadFileSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UploadFileResponder handles the response to the UploadFile request. The method always
// closes the http.Response Body.
func (client BaseClient) UploadFileResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}
