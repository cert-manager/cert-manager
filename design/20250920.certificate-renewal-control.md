# Proposal: Certificate Renewal Control (windows + disable)

**Author:** Erik (draft) **Status:** Draft **Date:** 2025-09-20

## Summary

Add a small, backward-compatible extension to the `Certificate` API that
allows users to:

1.  Define **renewal windows** --- time ranges when cert-manager is
    allowed to attempt automatic renewals.
2.  **Disable** automatic renewal entirely for a given Certificate
    resource.

The goal is to give cluster operators and application owners better
operational control over when certificate renewals happen (to avoid
renewal during business hours, maintenance windows, or restricted
network availability), while making the behavior explicit and
discoverable in `status` and safe-by-default.

------------------------------------------------------------------------

## Motivation

Current cert-manager behavior: certificates are renewed automatically
based on `duration` and `renewBefore`. There are valid real-world
situations where users want to control *when* renewal attempts are
performed:

-   Renewals that contact external ACME endpoints should be scheduled
    during off-peak windows to limit impact to rate limits or network
    egress costs.
-   Stateful applications may want to coordinate rolling restarts with
    certificate replacement; ops teams may only want renewals during
    maintenance windows.
-   For test environments the user might want to disable renewal
    entirely to test expiry behavior.

Providing a first-class API for these requirements improves transparency
and reduces reliance on out-of-band tooling (cronjobs, custom
controllers) to gate renewals.

------------------------------------------------------------------------

## Goals

-   Minimal, intuitive API extension to `Certificate` that is easy to
    reason about.
-   Backwards compatible: absence of fields implies existing behavior.
-   Clear observability: `status.conditions` show why a renewal is
    deferred or disabled.
-   Safe defaults: do not cause unexpected certificate expiries
    silently.

Non-goals: - Replace complex external scheduling systems. - Implement
full calendar/scheduling language (e.g., cron expressions) --- initially
keep windows simple.

------------------------------------------------------------------------

## Proposed API

Add a new `renewal` block to `CertificateSpec` with two child fields:
`disabled` and `windows`.

### CRD snippet (conceptual)

``` yaml
spec:
  renewPolicy:
    # If true, certificate will not be renewed automatically by cert-manager.
    # Default: false
    disabled: false

    # Optional. If provided, renewal may only happen during one of the listed windows.
    # If empty or omitted, renewals may occur at any time.
    windows:
      - daysOfWeek: ["Monday","Tuesday","Wednesday","Thursday","Friday"]
        start: "23:00"       # 24-hour local format (see timezone below)
        end: "05:00"         # allows next-day rollover
      - daysOfWeek: ["Saturday","Sunday"]
        start: "00:00"
        end: "23:59"
```

### Field definitions

-   `renewPolicy.disabled` (boolean, optional): when `true`,
    cert-manager will not perform automatic renewals for the
    Certificate. Manual interventions (user-initiated approvals or
    `kubectl cert-manager renew ...`) are still possible. Default
    `false`.

-   `renewPolicy.windows` (array of `RenewWindow`, optional): defines
    one or more allowed renewal windows. If omitted, renewal can happen
    at any time (existing behavior).

`RenewWindow`: - `daysOfWeek` (`[]string`, optional): allowed days
(e.g. `"Monday"`, `"Tuesday"`, ...). If omitted, the window applies
every day. - `start` (string, required): local time in `HH:MM` 24-hour
format for window start. - `end` (string, required): local time in
`HH:MM` 24-hour format for window end. If `end` is earlier than `start`,
the window is considered to roll over to the next day (e.g., `23:00` -
`05:00`). - `timezone` (string, optional): IANA timezone name
(e.g. `Europe/Oslo`). If omitted, defaults to `UTC` or cluster-level
default (see later).

Notes: - `disabled` and `windows` are mutually compatible:
`disabled=true` takes precedence and `windows` will be ignored with a
status condition explaining this. - Multiple windows are ORed: if
current time is inside any window, renewal is allowed.

------------------------------------------------------------------------

## Timezones

We must decide whether times are interpreted as UTC or allow a timezone:

Options: 1. **UTC-only** (simpler): `start`/`end` are always UTC. Less
surprising across clusters. 2. **Timezone per-window**: allow `timezone`
field per window with an IANA location. This is more expressive but
introduces complexity and potential misconfiguration. 3. **Cluster
default timezone**: add a config option to cert-manager controller
(e.g., a CLI flag) to set default timezone.

Recommendation: support optional per-window `timezone` using IANA names.
If omitted, default to `UTC` for determinism. Document guidance to use
`UTC` unless local business-hours semantics are explicitly required.

------------------------------------------------------------------------

## Controller logic (high level)

### When cert-manager currently schedules renewal

Cert-manager typically schedules a renewal event when the certificate's
`NotAfter` minus `renewBefore` is reached (or earlier, depending on
internal jitter and queueing). The controller reconciles Certificates
and triggers issuers.

### Updated behavior

1.  On reconcile, compute `desiredRenewalTime` using existing logic
    (expiry - `renewBefore`).
2.  If `renewPolicy.disabled == true`:
    -   Do not schedule renewal operations.
    -   Set a `RenewalDisabled` condition in status with a helpful
        message and the `observedGeneration` when it was last observed.
3.  Else if `windows` is provided:
    -   Check whether the current time is in any allowed window.
    -   If yes: proceed with renewal as normal (trigger Issuer/ACME
        flow).
    -   If no: postpone the renewal attempt and set a `RenewalDeferred`
        condition in `status` with the next allowed window start time
        computed and included in the message.
4.  **Fail-safe**: If current time is *past* `NotAfter` (certificate
    already expired) and renewal has not been performed due to windows,
    then:
    -   Two options: (A) Strict: respect the windows and allow cert to
        remain expired. (B) Fail-safe: attempt renewal immediately to
        prevent outage.

Recommendation: implement a **configurable fail-safe policy** with
default of "fail-safe for critical expiry". Specifically, if
`now + safetyMargin > NotAfter` (e.g., safetyMargin = 24h), attempt
renewal even if outside windows and emit a `RenewalWindowBypassed`
condition explaining why. Allow cluster operators to toggle this
behavior with a `--renewal-window-strict=false|true` controller flag.

### Scheduling

-   If `desiredRenewalTime` occurs outside of an allowed window, the
    controller should requeue the Certificate to reconcile at the next
    allowed window start (or a short time before that to handle jitter).
    Use `workqueue.AddAfter(...)` with a computed duration.
-   If multiple windows are defined, find the earliest next start time
    \> now.

### Edge cases

-   If `renewBefore` is larger than certificate `duration` leading to
    immediate desiredRenewalTime in the past: behavior remains unchanged
    but the window logic still applies.
-   If windows are misconfigured (invalid timezone, invalid time
    string), set a `RenewalConfigInvalid` condition and **do not**
    schedule renewals until corrected.

------------------------------------------------------------------------

## Status changes & Conditions

Add the following conditions to `status.conditions` (semantic, not
replacing existing Ready/Issued):

-   `RenewalDisabled` (True/False)
    -   Reason: `UserConfigured`.
    -   Message:
        `Automatic renewal disabled by spec.renewPolicy.disabled=true`.
-   `RenewalDeferred` (True/False)
    -   Reason: `OutsideAllowedWindow`.
    -   Message example:
        `Next allowed renewal window starts at 2025-09-21T23:00:00Z (Europe/Oslo)`.
-   `RenewalWindowBypassed` (True/False)
    -   Reason: `ExpiryImminent`.
    -   Message:
        `Certificate expiring at 2025-09-22T01:00:00Z; attempting renewal despite outside configured windows to prevent service outage`.
-   `RenewalConfigInvalid` (True/False)
    -   Reason: `InvalidTimezone` / `InvalidTimeFormat` /
        `EmptyStartEnd`.
    -   Message: explanatory.

When a renewal is attempted or completed, existing issuance conditions
(e.g., `Issuing`, `Ready`) still apply.

------------------------------------------------------------------------

## API examples

### 1) Disable renewal completely

``` yaml
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: no-renewal-cert
spec:
  secretName: no-renewal
  dnsNames: ["test.example.com"]
  renewPolicy:
    disabled: true
```

### 2) Allow renewals only during nightly window in Europe/Oslo

``` yaml
spec:
  renewPolicy:
    windows:
      - daysOfWeek: ["Monday","Tuesday","Wednesday","Thursday","Friday"]
        start: "23:00"
        end: "05:00"
        timezone: "Europe/Oslo"
      - daysOfWeek: ["Saturday","Sunday"]
        start: "00:00"
        end: "23:59"
        timezone: "Europe/Oslo"
```

------------------------------------------------------------------------

## Interactions with other features

-   **ACME rate limits**: By allowing windows, users may unintentionally
    bunch renewal attempts into smaller time periods. Document guidance
    about rate limits and encourage staggered windows for many
    Certificates.
-   **Certificate controllers / Reloader / Pod restarts**: If another
    controller watches secret updates and triggers restarts, users
    should ensure windows align with maintenance windows. This feature
    intentionally provides that control.
-   **Manual renewal**: `kubectl cert-manager renew` (or similar manual
    actions) should continue to work irrespective of `disabled` or
    windows because those are meant to affect automatic renewal
    only---**unless** the user explicitly requests that manual
    operations be blocked (not proposed here).

------------------------------------------------------------------------

## Safety and UX considerations

-   Make `disabled` explicit and require no special RBAC.
-   For any configuration parsing error, surface the problem in a
    `RenewalConfigInvalid` status to avoid silent misbehavior.
-   Provide helpful CLI/`kubectl` hints in messages where appropriate
    (e.g. `To renew manually: kubectl cert-manager renew certificate/no-renewal-cert`).

------------------------------------------------------------------------

## Implementation plan (rough)

1.  Update API types (Go structs) and CRD YAML. Add unit tests for
    validation parsing (time, timezone correctness).
2.  Add status condition types and helper methods.
3.  Extend the Certificate reconciler to evaluate `renewPolicy`:
    -   Validate `renewPolicy` early in reconcile.
    -   Compute next allowed window.
    -   Requeue reconcile for next allowed start when necessary.
    -   Implement fail-safe logic governed by a controller flag.
4.  Add e2e tests that simulate time progression (using fake clocks or
    test helpers) to verify:
    -   Renewal occurs inside windows.
    -   Renewal deferred outside windows and `RenewalDeferred` is set.
    -   `disabled` prevents automatic renewal but manual renew works.
    -   Fail-safe bypass occurs when expiry close.
5.  Documentation: user guide, examples, migration notes.

------------------------------------------------------------------------

## Validation and Admission

-   No admission webhook required for initial iteration. CRD validation
    should constrain `start`/`end` format using regex and optionally
    validate `timezone` strings against known IANA list (best-effort,
    since full validation requires lookups --- a simple regex for
    `^([A-Za-z_]+/[A-Za-z_+-]+)$` may suffice and invalid values will be
    caught at runtime with `RenewalConfigInvalid`).

------------------------------------------------------------------------

## RBAC & Security

-   No new API groups or verbs required. Controller will need to read
    `Certificate` spec as usual.
-   No sensitive data stored.

------------------------------------------------------------------------

## Metrics and Monitoring

Suggested metrics additions: -
`certmanager_certificate_renewal_deferred_total{reason="outside_window"}` -
`certmanager_certificate_renewal_bypassed_total{reason="expiry_imminent"}`

Document that operators should alert on many `renewal_deferred` events
for certificates approaching expiry.

------------------------------------------------------------------------

## Alternatives considered

1.  **Cron-like schedule field**: More expressive (cron expression) but
    increases complexity for users and parsing.
2.  **External scheduler integration**: Leave renewal control to an
    external controller. This keeps core simpler but adds operational
    burden.
3.  **Per-issuer scheduling**: Instead of per-Certificate, allow Issuers
    to be configured with windows. This reduces per-certificate
    flexibility.

We opted for per-Certificate windows for fine-grained control and
simplicity of the API.

------------------------------------------------------------------------

## Migration story

-   Old Certificates without `renewPolicy` behave exactly as today.
-   Adding `renewPolicy` is opt-in.
-   No existing certificates are changed.

------------------------------------------------------------------------

## Open Questions

-   Default timezone: should we default to cluster-local timezone
    instead of UTC?
-   Fail-safe policy default: strict vs permissive. Current
    recommendation: permissive (try to renew if expiry is imminent) and
    make this toggleable.
-   Validation strictness for timezone strings: how strict should CRD
    validation be?
-   Should `disabled` be reversible? (Yes; if user toggles to `false`,
    reconcile should re-evaluate immediately.)

------------------------------------------------------------------------

## Testing matrix (high level)

-   Unit tests:
    -   Parse windows with/without timezone; invalid times; rollover
        windows.
    -   `renewPolicy.disabled=true` path.
-   Integration tests / e2e:
    -   Certificates with windows succeed only within windows.
    -   Certificates approaching expiry trigger fail-safe.
    -   Status conditions are correctly emitted in all cases.
-   Load test:
    -   Large number of Certificates with identical windows: ensure
        controller queueing and rate-limiting behave properly.

------------------------------------------------------------------------

## Documentation (what to add)

-   API docs for `renewPolicy` (fields, examples).
-   User guide: scenarios, recommended patterns (e.g., stagger windows
    for many certs), ACME consideration.
-   Troubleshooting: common messages in `status.conditions` and how to
    act.

------------------------------------------------------------------------

## Next steps

1.  Review this draft with maintainers.
2.  Decide timezone default and fail-safe policy.
3.  Prepare a PR that implements:
    -   API type changes + CRD update
    -   Controller logic and feature flag/config flag for fail-safe
        strictness
    -   Tests + docs

------------------------------------------------------------------------

*End of draft.*