# Proposal: Certificate Renewal Control (windows + disable)

**Author(s):** 
* Erik (draft) 
* Hemant Joshi

**Status:** Draft **Date:** 2025-09-20

- [Summary](#summary)
- [Motivation](#motivation)
  - [Goals](#goals)
  - [Non-Goals](#non-goals)
- [Proposed API](#proposed-api)
  - [CRD Snippet](#crd-snippet)
  - [Field Definitions](#field-definitions)
  - [Timezones](#timezones)
- [Controller logic](#controller-logic)
  - [Current behavior](#current-behavior)
  - [Updated behavior](#updated-behavior)

## Summary

Add a small, backward-compatible extension to the `Certificate` API that
allows users to:

1.  Define **renewal windows** --- time ranges when cert-manager is
    allowed to attempt automatic renewals.
2.  **Disable** automatic renewal entirely for a given Certificate
    resource.

The goal is to give cluster operators and application owners better
operational control over when certificate renewals happen (to avoid
renewal during business hours, maintenance windows, or restricted
network availability), while making the behavior explicit and
discoverable in `status` and safe-by-default.

------------------------------------------------------------------------

## Motivation

Current cert-manager behavior: certificates are renewed automatically
based on `duration` and `renewBefore`. There are valid real-world
situations where users want to control *when* renewal attempts are
performed:

-   Renewals that contact external ACME endpoints should be scheduled
    during off-peak windows to limit impact to rate limits or network
    egress costs.
-   Stateful applications may want to coordinate rolling restarts with
    certificate replacement; ops teams may only want renewals during
    maintenance windows.
-   For test environments the user might want to disable renewal
    entirely to test expiry behavior.

Providing a first-class API for these requirements improves transparency
and reduces reliance on out-of-band tooling (cronjobs, custom
controllers) to gate renewals.

------------------------------------------------------------------------

### Goals

-   Minimal, intuitive API extension to `Certificate` that is easy to
    reason about.
-   Backwards compatible: absence of fields implies existing behavior.
-   Clear observability: `status.conditions` show why a renewal is
    deferred or disabled.
-   Safe defaults: do not cause unexpected certificate expiries
    silently.
-   Update documentation for the `Certificate` CRD `renewalPolicy` field with examples of `windows`
    and recommended guidelines on how to configure `windows`.

### Non-Goals

-   Replace complex external scheduling systems. 
-   Implement full calendar/scheduling language.
-   Initially, use simple calendar windows similar to certbot systemd timers, and then 
    implement cron for power users.
-   Once the extension is stable, this could be migrated to a `RenewalPolicy` CRD
    so that the policies can be shared across certificates.

------------------------------------------------------------------------

## Proposed API

Add a new `renewal` block to `CertificateSpec` with two child fields:
`policy` and `windows`.

### CRD snippet

```yaml
spec:
  renewal:
    # Type of policy to use for renewal. Automatic uses the existing behavior where it uses `renewBefore` for renewal.
    # Default: Automatic 
    policy: Automatic # Automatic | Disabled | Scheduled

    # Optional. If provided, renewal may only happen during one of the listed windows.
    # If empty or omitted, renewals may occur at any time.
    windows:
      - daysOfWeek: ["Monday","Tuesday","Wednesday","Thursday","Friday"]
        start: "23:00"       # 24-hour local format (see timezone below)
        end: "05:00"         # allows next-day rollover
      - daysOfWeek: ["Saturday","Sunday"]
        start: "00:00"
        end: "23:59"
```

### Field definitions

-   `renewal.policy` (string, optional): when `Automatic`,
    cert-manager follows the existing behavior of using `renewBefore`
    to renew the certificates. If set to `Scheduled`, it uses the `renewalPolicy.windows`
    to determine when to renew the certs. If set to `Disabled` cert won't be renewed.

-   `renewal.windows` (array of `RenewWindow`, optional): defines
    one or more allowed renewal windows. If omitted, renewal can happen
    at any time (existing behavior).

`RenewWindow`: - `daysOfWeek` (`[]string`, optional): allowed days
(e.g. `"Monday"`, `"Tuesday"`, ...). If omitted, the window applies
every day. - `start` (string, required): local time in `HH:MM` 24-hour
format for window start. - `end` (string, required): local time in
`HH:MM` 24-hour format for window end. If `end` is earlier than `start`,
the window is considered to roll over to the next day (e.g., `23:00` -
`05:00`). - `timezone` (string, optional): IANA timezone name
(e.g. `Europe/Oslo`). If omitted, defaults to `UTC` or cluster-level
default (see later).

Notes: - `Automatic` and `windows` are mutually exclusive:
`policy=Automatic` takes precedence and `windows` will be ignored with a
status condition explaining this. - Multiple windows are ORed: if
current time is inside any window, renewal is allowed.

### Timezones

For the sake of uniformity, all `windows` defintions are going to use UTC timezone.

------------------------------------------------------------------------

## Controller logic

### Current behavior

Cert-manager typically schedules a renewal event when the certificate's
`NotAfter` minus `renewBefore` is reached (or earlier, depending on
internal jitter and queueing). The controller reconciles Certificates
and triggers issuers.

### Updated behavior

1.  On reconcile, compute `desiredRenewalTime` using existing logic
    (expiry - `renewBefore`).
2.  If `renewal.policy == Disabled`:
    -   Do not schedule renewal operations.
    -   Set a `RenewalDisabled` condition in status with a helpful
        message and the `observedGeneration` when it was last observed.
3.  Else if `renewalPolicy.policy == Automatic`:
    - Keep the existing behavior of cert-manager that is to use `renewBefore`.
      Adding `windows` here won't make any difference.
4.  Else if `windows` is provided and `renewalPolicy.policy == Scheduled`:
    -   Check whether the current time is in any allowed window.
    -   If yes: proceed with renewal as normal (trigger Issuer/ACME
        flow).
    -   If no: postpone the renewal attempt and set a `RenewalDeferred`
        condition in `status` with the next allowed window start time
        computed and included in the message.
4.  **Fail-safe**: If current time is *past* `NotAfter` (certificate
    already expired) and renewal has not been performed due to windows,
    then:
    -   Two options: (A) Strict: respect the windows and allow cert to
        remain expired. (B) Fail-safe: attempt renewal immediately to
        prevent outage.

Recommendation: implement a **configurable fail-safe policy** with
default of "fail-safe for critical expiry". Specifically, if
`now + safetyMargin > NotAfter` (e.g., safetyMargin = 24h), attempt
renewal even if outside windows and emit a `RenewalWindowBypassed`
condition explaining why. Allow cluster operators to toggle this
behavior with a `--renewal-window-strict=false|true` controller flag.

### Scheduling

-   If `desiredRenewalTime` occurs outside of an allowed window, the
    controller should requeue the Certificate to reconcile at the next
    allowed window start (or a short time before that to handle jitter).
    Use `workqueue.AddAfter(...)` with a computed duration.
-   If multiple windows are defined, find the earliest next start time
    \> now.

### Edge cases

-   If `renewBefore` is larger than certificate `duration` leading to
    immediate desiredRenewalTime in the past: behavior remains unchanged
    but the window logic still applies.
-   If windows are misconfigured (invalid timezone, invalid time
    string), set a `RenewalConfigInvalid` condition and **do not**
    schedule renewals until corrected.

------------------------------------------------------------------------

## Status changes & Conditions

Add the following `renewal` field to the status and also update some existing fields accordingly:

```yaml
status:
  renewalTime: "" # Update this according to the controller logic. Existing field.
  lastFailureTime: "" # Again this exists and probably doesn't need to be touched.
  renewal:
    policy: Automatic
    windows: # This will only be set if the policy is Scheduled.
      valid: "True"
      matchedWindow: "" # which window corresponded to the cert being renewed
```

When a renewal is attempted or completed, existing issuance conditions
(e.g., `Issuing`, `Ready`) still apply.

------------------------------------------------------------------------

## API examples

### 1) Disable renewal completely

``` yaml
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: no-renewal-cert
spec:
  secretName: no-renewal
  dnsNames: ["test.example.com"]
  renewal:
    policy: Disabled 
```

### 2) Allow renewals only during nightly window in Europe/Oslo

```yaml
spec:
  renewal:
    policy: Scheduled
    windows:
      - daysOfWeek: ["Monday","Tuesday","Wednesday","Thursday","Friday"]
        start: "23:00"
        end: "05:00"
        timezone: "Europe/Oslo"
      - daysOfWeek: ["Saturday","Sunday"]
        start: "00:00"
        end: "23:59"
        timezone: "Europe/Oslo"
```

------------------------------------------------------------------------

## Interactions with other features

-   **ACME rate limits**: By allowing windows, users may unintentionally
    bunch renewal attempts into smaller time periods. Document guidance
    about rate limits and encourage staggered windows for many
    Certificates.
-   **Certificate controllers / Reloader / Pod restarts**: If another
    controller watches secret updates and triggers restarts, users
    should ensure windows align with maintenance windows. This feature
    intentionally provides that control.
-   **Manual renewal**: `kubectl cert-manager renew` (or similar manual
    actions) should continue to work irrespective of `disabled` or
    windows because those are meant to affect automatic renewal
    only---**unless** the user explicitly requests that manual
    operations be blocked (not proposed here).

------------------------------------------------------------------------

## Safety and UX considerations

-   Make `disabled` explicit and require no special RBAC.
-   For any configuration parsing error, surface the problem in a
    `RenewalConfigInvalid` status to avoid silent misbehavior.
-   Provide helpful CLI/`kubectl` hints in messages where appropriate
    (e.g. `To renew manually: kubectl cert-manager renew certificate/no-renewal-cert`).

------------------------------------------------------------------------

## Implementation plan (rough)

1.  Update API types (Go structs) and CRD YAML. Add unit tests for
    validation parsing (time, timezone correctness).
2.  Add status condition types and helper methods.
3.  Extend the Certificate reconciler to evaluate `renewal`:
    -   Validate `renewal` early in reconcile.
    -   Compute next allowed window.
    -   Requeue reconcile for next allowed start when necessary.
    -   Implement fail-safe logic governed by a controller flag.
4.  Add e2e tests that simulate time progression (using fake clocks or
    test helpers) to verify:
    -   Renewal occurs inside windows.
    -   Renewal deferred outside windows and `RenewalDeferred` is set.
    -   `disabled` prevents automatic renewal but manual renew works.
    -   Fail-safe bypass occurs when expiry close.
5.  Documentation: user guide, examples, migration notes.

------------------------------------------------------------------------

## Validation and Admission

-   No admission webhook required for initial iteration. CRD validation
    should constrain `start`/`end` format using regex and invalid values 
    will be caught at runtime with `RenewalConfigInvalid`).

------------------------------------------------------------------------

## Metrics and Monitoring

Suggested metrics additions: -
`certmanager_certificate_renewal_deferred_total{reason="outside_window"}` -
`certmanager_certificate_renewal_bypassed_total{reason="expiry_imminent"}`

Document that operators should alert on many `renewal_deferred` events
for certificates approaching expiry.

------------------------------------------------------------------------

## Alternatives considered

1.  **Cron-like schedule field**: More expressive (cron expression) but
    increases complexity for users and parsing.
2.  **External scheduler integration**: Leave renewal control to an
    external controller. This keeps core simpler but adds operational
    burden.
3.  **Per-issuer scheduling**: Instead of per-Certificate, allow Issuers
    to be configured with windows. This reduces per-certificate
    flexibility.

We opted for per-Certificate windows for fine-grained control and
simplicity of the API.

------------------------------------------------------------------------

## Migration story

-   Old Certificates without `renewal` behave exactly as today.
-   Adding `renewal` is opt-in.
-   No existing certificates are changed.

------------------------------------------------------------------------

## Testing matrix 

Standard unit and end-to-end tests will be used to verify new behaviour, as used by cert-manager currently. 
Current end-to-end tests for `Certificate` resources will also give a good signal for `renewal` field.

-   Unit tests:
    -   Parse windows; invalid times; rollover windows.
    -   `renewal.policy=Disabled` path.
-   Integration tests / e2e:
    -   Certificates with windows succeed only within windows.
    -   Certificates approaching expiry trigger fail-safe.
    -   Status conditions are correctly emitted in all cases.

------------------------------------------------------------------------

