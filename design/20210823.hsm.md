 

Support HSM with attestation in cert-manager 

Authors:  @kailun-qin, @irisdingbj 

Reviewers: 

creation-date: 2021-07-14 

last-updated: 2021-08-23

status: draft 

--- 

 

# Support HSM with attestation in cert-manager 

 

## Summary 

 

The HSM(Hardware Security Module) using PKCS11 interface provides a way following PKCS standard to hide the private key, where only the reference to the underlying key is provided there by not exposing the key in memory (in the clear). 

Enhance cert-manager CA issuer and Self signed Issuers with HSM support. A new HSM controller will be added to take care of HSM related operations.
 

## Motivation 

 

Currently cert-manager CA issuer and self-signed issuer uses private key stored in the Secret to issue certificates. The private key will be cached and exposed in memory after fetching from etcd. Malicious software and/or hardware can extract those keys in the clear. 

 

### Third Party Projects 

SoftHSMv2 (https://github.com/opendnssec/SoftHSMv2) from OpenDNSSEC project can be utilized to provide HSM support for upstream. Other hardware based solutions should work seamlessly as well.  

  

--- 

 

## Reasons for Approach 

 

This mode is pluggable, no influence for all current functions if the user does not enable these controllers and  define related CRs.  

 

--- 

 

## Proposal 

 

Built-in CA and Self Signed issuer will be enhanced to support loading private keys from HSM via keyID or label if the related custom resource like: certificate, CA issuers, self signed issuers has annotation `cert-manager.io/hsm :true` defined.

 

(Encrypted) private keys will be generated by tenant admin offline and saved into HSM securely for CA issuers. 

 

One controller and two CustomResourceDefinitions will be added into cert-manager to support HSM and its attestation flow separately.  

 

### Workflow 
 
(Local) HSM Backend <-> HSM Controller <-> Attestation CRD <-> Attestation  

 

#### Attestation Part: 


1. Tenant(signer) admin generate private/cert offline if there is CA type issuer defined.  If there are no CA type issuer defined skip this step. 

2. Admin read attestation CR to get the quote/ public key 

3. Admin verify the quote/public key in the CR via supported ways to make sure quote/ public key is trusted.

4. If passed 

   * Admin wrap the each of the private key generated in step1 via the public key in the attestation CR.  
   * create secret in cluster which includes the wrapped private key and cert(generated in step1) 
   * The secret name will be using  issuer name + `-cacert` format.  
   * admin update attestation CR status with `success` and reason/message 
   * Admin update attestation CR to fill signer: secret info.

5. If failed 

   * admin update attestation CR status with `failed` and reason/message 

#### HSM Part:   

User can define a `HardwareSecurityModule` Custom Resource like below to enable HSM related functions: 

``` 

apiVersion: cert-manager.io/v1alpha3 

kind: HardwareSecurityModule 

metadata: 

  name: hsm 

  namespace: sandbox 

spec: 

  pkcs11LibPath:  /usr/local/xxx.so 

  pkcs11Token:  xxxx 

  pkcs11Pin:   xxxx 

  issuers: 

  - clusterissuers.cert-manager.io/my-cluster-issuer: ca 

  - clusterissuers.cert-manager.io/your-cluster-issuer: selfsigned 

``` 

 

Besides HSM backend info user also needs to provide info about issuers they want to leverage the HSM functions.  We support two kinds of issuers for now : CA issuer and Self-Signed Issuer.  For CA issuer admin need to generate private keys/certs manually.  see above attestation flow.
 

 

Controller `HSM` will be added to reconcile above CRs. The `HSM` controller is responsible for: 

1. Initializing related HSM contexts. 

2. Generating one key pair using HSM for all the issuers. 

3. Generating Quote and attestation CR with quote + public key( see below sample attestation CR) 

4. Watching quote verification result in attestation CR (updated manually via above attestation flow). 

5. If there are any CA type issue defined in HSM CR:  

   * load wrapped keys(from K8s Secret, for each issuer) into HSM  for CA issuers.  

   * Creating built-in CA issuers which use the generated secrets.  

   * Add Annotation `cert-manager.io/hsm :true` for the created CA issuers. 

6. If there are any Self Signed type issue defined in HSM CR: 

   * Create built-in Self Signed Issuers 

   * Create built-in Certificates 

   * Add Annotation `cert-manager.io/hsm :true` for the created self signed issuers and certificates. 

   * Create built-in CA issuers once the above certificate is ready  

    * Add Annotation `cert-manager.io/hsm :true` for the created CA issuers. 

7. Monitoring the created CA/self signed issuers and updating HardwareSecurityModule CR status. 


A sample Attestation CR generated by `HSM` controller is as below: 
``` 
apiVersion: cert-manager.io/v1alpha3 
kind: QuoteAttestation 
metadata: 
  name: quoteattestation 
  namespace: sandbox 
spec: 
  quote :  xxxxx 
  PublicKey :  xxxxxx 
 ``` 

The `HSM`  controllers will be added as experimental controllers at first.  

 

#### Enhanced CA issuers:   

CA issuers which has `cert-manager.io/hsm :true` will be enhanced to get private keys from HSM via keyID or label. 

 

#### Enhanced Self signed issuer: 

 

`cert-manager.io/hsm :true annotation will be added in Certificate and  certificateRequest to controll whether below controllers will use HSM functions.  

 

1. Key Manager Controller will be enhanced to generate private keys using HSM for certificates which has `cert-manager.io/hsm :true` annotation.  

 

2. Request manager controller will be enhanced to create certificateRequest with `cert-manager.io/hsm :true` annotation for those certificates and sign the CSR with private keys from HSM. 

 

3. Issuing controller will be enhanced to save secrets with key handler info with keys saved in HSM.  

### API Changes 

```
HardwareSecurityModule CRD:  
package v1alpha3 
import ( 
metav1 "k8s.io/apimachinery/pkg/apis/meta/v1" 
) 
type HardwareSecurityModule struct { 
 metav1.TypeMeta   `json:",inline"` 
 metav1.ObjectMeta `json:"metadata,omitempty"` 
 Spec HardwareSecurityModuleSpec `json:"spec"` 
 Status HardwareSecurityModuleStatus `json:"status"` 
} 
// HardwareSecurityModuleList is a list of HardwareSecurityModules 

type HardwareSecurityModuleList struct { 

metav1.TypeMeta `json:",inline"` 

metav1.ListMeta `json:"metadata"` 

Items []HardwareSecurityModule `json:"items"` 

} 

type HardwareSecurityModuleSpec struct { 

    Pkcs11LibPath string `json:"pkcs11LibPath"` 

    Pkcs11Pin string `json:"pkcs11Pin"` 

    Pkcs11Token string `json:"pkcs11Token"` 

    Issuers map[string]HSMIssuerType `json:"issuers"` 

} 
type HSMIssuerType string  

Const ( 
   CAIssuer   HSMIssuerType  = “CA” 

   SelfSigned HSMIssuerType  = “SelfSigned” 

) 
type HardwareSecurityModuleStatus struct { 
 // type of the condition. Known conditions are "Success", and "Failed". 

 Type           ConditionType `json:"type,omitempty"` 
 // +optional 

 State          string `json:"status,omitempty"` 

 // +optional 
 Message        string `json:"message,omitempty"` 

 // lastUpdateTime is the time of the last update to this condition 

 // +optional 

 LastUpdateTime metav1.Time `json:"lastUpdateTime,omitempty"` 

} 
 

const ( 

HardwareSecurityModuleSuccess ConditionType = "Success" 

HardwareSecurityModuleFailed ConditionType = "Failed" 

) 
```
 
```
QuoteAttestationSpec  CRD:  

package v1alpha3 
import ( 
corev1 "k8s.io/api/core/v1" 
metav1 "k8s.io/apimachinery/pkg/apis/meta/v1" 
) 

// ConditionType is the type of a QuoteAttestationCondition 
type ConditionType string  
 const ( 
 // Approved indicates the request was approved and should be issued by the signer. 

 AttestationSuccess ConditionType = "Success" 

 // Failed indicates the signer failed to issue the certificate. 

 AttestationFailed ConditionType = "Failed" 

) 
// QuoteAttestationSpec defines the desired state of QuoteAttestation 
type QuoteAttestationSpec struct { 

 // Quote to be verified, base64-encoded. 
 Quote        []byte    `json:"quote"` 
 // QuoteVersion used to for generated quote, default is ECDSA quote "3" 
 QuoteVersion string    `json:"quoteVersion,omitempty"` 
 // which is requesting the secret. 
 // To be decided whether this should be a SPIFFE trust domain! 
 ServiceID    string    `json:"serviceId"` 
 // PublicKey for encrypting the secret, hash is part of the quote data,  
 PublicKey    []byte `json:"publicKey"` 
 // Signers holds the signer names 
  Signers      []string  `json:"signers"` 
} 
// QuoteAttestationCondition describes a condition of a QuoteAttestation object 

type QuoteAttestationCondition struct { 

 // type of the condition. Known conditions are "Success", and "Failed". 
 // A "Success" indicating the attestation request was succeeded and the 
 // secret keys have been created. 
 // A "Failed" indicating the attestation request was failed for some reason, 
 // message holds the additional information about the failure. 
 Type           ConditionType `json:"type,omitempty"` 
 // state indicates current request state 
 // +optional 
 State          string `json:"status,omitempty"` 
 // message contains a human readable message with details about the request state 
 // +optional 
 Message        string `json:"message,omitempty"` 

 // lastUpdateTime is the time of the last update to this condition 
 LastUpdateTime metav1.Time `json:"lastUpdateTime,omitempty"` 
} 

// QuoteAttestationSecret defines the secret get from the Key Management Service 

type QuoteAttestationSecret struct { 

 // SecretName represents name of the Secret object (in the same namespace) 

 // which contains the secret keys. Added only after a successful quote 

 // validation. The secret may contain several keys and other encrypted data. 

 // +optional 

 SecretName string `json:"secretName,omitempty"` 

 // SecretType defines the internal structure of secret fetched from the 

 // Key Management Service, as there might be different formats accordingly. 

 // +optional 

 SecretType string `json:"secretType,omitempty"` 
} 

// QuoteAttestationStatus defines the observed state of QuoteAttestation 

type QuoteAttestationStatus struct { 
 // conditions applied to the request. Known conditions are "Success", and "Failed". 
 // +optional 
 Condition  QuoteAttestationCondition            `json:"condition,omitempty"` 
 // Secret fetched after the request has been processed successfully 
 // +optional 

 Secret     map[string]QuoteAttestationSecret    `json:"secret,omitempty"` 
} 

// QuoteAttestation is the Schema for the quoteattestations API 

type QuoteAttestation struct { 

 metav1.TypeMeta   `json:",inline"` 

 metav1.ObjectMeta `json:"metadata,omitempty"` 

 Spec   QuoteAttestationSpec   `json:"spec,omitempty"` 

 Status QuoteAttestationStatus `json:"status,omitempty"` 
} 
 
// QuoteAttestationList contains a list of QuoteAttestation 

type QuoteAttestationList struct { 

 metav1.TypeMeta `json:",inline"` 

 metav1.ListMeta `json:"metadata,omitempty"` 

 Items           []QuoteAttestation `json:"items"` 

} 
```
 

### Key retrieval 

 

With Crypto11 enabled, id and label are used as the identifiers to fetch the private key.  Either of them is usable to fetch the identical key.  




### Upgrading 

 

No effect to upgrade as this option will be enabled only if the user defines the related HardwareSecurityModule CR and enables the HSM and Attestation controller.  

 

 
