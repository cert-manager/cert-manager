# Image Configuration in Helm Chart: add $.imagePrefix and support default digest

<!-- toc -->
- [Release Signoff Checklist](#release-signoff-checklist)
- [Summary](#summary)
- [Motivation](#motivation)
  - [Goals](#goals)
  - [Non-Goals](#non-goals)
- [Proposal](#proposal)
  - [User Stories (Optional)](#user-stories-optional)
    - [Story 1](#story-1)
    - [Story 2](#story-2)
  - [Risks and Mitigations](#risks-and-mitigations)
- [Alternatives](#alternatives)
<!-- /toc -->

## Release Signoff Checklist

This checklist contains actions which must be completed before a PR implementing this design can be merged.

- [ ] This design doc has been discussed and approved
- [ ] User-facing documentation has been PR-ed against the release branch in [cert-manager/website]

## Summary

We propose to replace the existing `image.registry` and `image.repository` options with `$.imagePrefix`, `image.name` and `image.repository`. Allowing users to change the registry/ image location by only changing one value (`$.imagePrefix`). Additionally, we will introduce the `image._defaultReference` value which will allow us to set a default digest value that still can be overwritten by setting `image.tag`.

NOTE: This will be a backwards incompatible change in case you were using `image.registry`.

## Motivation

1. The current settings in our `image` Helm values are complex and don't fix our users' use cases (see https://github.com/cert-manager/cert-manager/issues/6160 and https://github.com/cert-manager/cert-manager/issues/7476).
The usefulness right now of `image.registry` is highly questionable, you always have to overwrite both `image.registry` and `image.repository` since `image.registry` defaults to ` ` and `image.repository` defaults to `quay.io/jetstack/cert-manager-controller`. Additionally, you have to overwrite `image.registry` for each of the images individually.

2. To improve security, we would like to change our default image references to be digest based. The current structure does not cleanly allow us to do this. If we set a default for `image.digest`, users who only specify `image.tag` will not see any change in their rendered YAML (since `image.digest` takes precedence over `image.tag`).

### Goals

- make it possible to change the OCI image registry by modifying one value in `values.yaml`
- simplify the `image` struct and only keep fields that make sense to be modified by users
- when leaving `image.tag` and `image.digest` empty, the image should look like `image:default-tag@sha256:default-digest`
- when setting `image.tag`, the default digest should be ignored
- when setting `image.digest`, the default digest should be ignored
- when setting `image.tag` and `image.digest`, the image should look like `image:custom-tag@sha256:custom-digest`
- don't break users who use `--set webhook.image.repository=ghcr.io/my-cert-manager/my-webhook`
- provide a global field (`imagePrefix`) that can be used to use a different container registry and repository namespace for all cert-manager's images that are used in the Helm chart

### Non-Goals

- introducing logic to add a digest to `image._defaultReference`
- keep support for `image.registry` field

## Existing situation

This is what our current values.yaml looks like:
```yaml
image:
    # The container registry to pull the manager image from.
    # +docs:property
    # registry: quay.io

    # The container image for the cert-manager controller.
    # +docs:property
    repository: quay.io/jetstack/cert-manager-controller

    # Override the image tag to deploy by setting this variable.
    # If no value is set, the chart's appVersion is used.
    # +docs:property
    tag: v1.2.3

    # Setting a digest will override any tag.
    # +docs:property
    # digest: sha256:0e072dddd1f7f8fc8909a2ca6f65e76c5f0d2fcfb8be47935ae3457e8bbceb20

    # Kubernetes imagePullPolicy on Deployment.
    pullPolicy: IfNotPresent
```

And this is the template we use to generate the image string:
```
{{- define "image" -}}
{{- $defaultTag := index . 1 -}}
{{- with index . 0 -}}
{{- if .registry -}}{{ printf "%s/%s" .registry .repository }}{{- else -}}{{- .repository -}}{{- end -}}
{{- if .digest -}}{{ printf "@%s" .digest }}{{- else -}}{{ printf ":%s" (default $defaultTag .tag) }}{{- end -}}
{{- end }}
{{- end }}
```

And in pseudocode:
```pseudocode
if values.image.registry != "" {
  repository = values.image.registry + "/" + values.image.repository
} else {
  repository = values.image.repository
}

if values.image.digest != "" {
  tagAndDigest = "@" + values.image.digest
} else {
  tagAndDigest = ":" + values.image.tag
}

fullImage = repository + tagAndDigest
```

## Proposal

We propose the following `image` values.yaml structure:
```yaml
# The container registry and repository namespace to pull the images from.
# +docs:property
imagePrefix: quay.io/jetstack

image:
    # The name of the image to pull (is combined with $.imagePrefix).
    # +docs:property
    name: cert-manager-controller

    # The full container image URL. When set, .name and $.imagePrefix
    # are not used to compute the image URL.
    # +docs:property
    # repository: my-registry.local/cert-manager/my-image

    # Sets the image tag.
    # +docs:property
    # tag: vX.Y.Z

    # Sets the image digest. Kubernetes will pull the image
    # based on digest if both digest and tag are provided.
    # +docs:property
    # digest: sha256:0000000000000000000000000000000000000000000000000000000000000000

    # Default tag + digest combination that is used when neither tag nor digest
    # is set. This value is generated when the chart is built and should not
    # be changed by the user, set .tag or .digest directly instead.
    # +docs:hidden
    _defaultReference: ":v1.2.3@sha256:0000000000000000000000000000000000000000000000000000000000000000"

    # Kubernetes imagePullPolicy on Deployment.
    pullPolicy: IfNotPresent
```

And the following Helm helper
```go template
{{- define "image" -}}
{{- $imagePrefix := index . 1 -}}
{{- with index . 0 -}}
{{- if .repository -}}{{ .repository }}{{- else -}}{{ printf "%s/%s" $imagePrefix .name }}{{- end -}}
{{- if .tag -}}{{ printf ":%s" .tag }}{{- end -}}
{{- if .digest -}}{{ printf "@%s" .digest }}{{- end -}}
{{- if not (or .tag .digest) -}}{{ printf ":%s" (splitn ":" 2 ._defaultReference)._1 }}{{- end -}}
{{- end }}
{{- end }}
```

And in pseudocode:
```pseudocode
if values.image.repository != "" {
  repository = values.image.repository
} else {
  repository = values.imagePrefix + "/" + values.image.name
}

tagAndDigest = ""
if values.image.tag != "" {
  tagAndDigest += ":" + values.image.tag
}
if values.image.digest != "" {
  tagAndDigest += "@" + values.image.digest
}
if tagAndDigest == "" {
  tagAndDigest = regexSelect(values.image._defaultReference, ":.*")
}

fullImage = repository + tagAndDigest
```

### Before vs After

This table compares the behavior before and after this proposed change:

| IN | OUT Before | OUT After |
|---|---|---|
| `--set controller.image.repository=ghcr.io/my-cert-manager/my-controller` | `ghcr.io/my-cert-manager/my-controller:v1.2.3` | `ghcr.io/my-cert-manager/my-controller:v1.2.3` |
| `--set controller.image.registry=test.com` | `test.com/quay.io/jetstack/cert-manager-controller:v1.2.3` | ERROR: field controller.image.registry not supported |
| `--set controller.image.registry=ghcr.io` `--set controller.image.repository=my-cert-manager/my-controller` | `ghcr.io/my-cert-manager/my-controller:v1.2.3` | ERROR: field controller.image.registry not supported |
| `--set imagePrefix=ghcr.io/my-cert-manager` | ERROR: field imagePrefix not supported | `ghcr.io/my-cert-manager/cert-manager-controller:v1.2.3` |
| `--set controller.image.name=custom-image` | ERROR: field controller.image.name not supported | `quay.io/jetstack/custom-image:v1.2.3` |
| `--set controller.image.digest=aaaa` | `quay.io/jetstack/cert-manager-controller@aaaa` | `quay.io/jetstack/cert-manager-controller@aaaa` |
| `--set controller.image.tag=v9.9.9` | `quay.io/jetstack/cert-manager-controller:v9.9.9` | `quay.io/jetstack/cert-manager-controller:v9.9.9` |
| `--set controller.image.digest=aaaa` `--set controller.image.tag=v9.9.9` | `quay.io/jetstack/cert-manager-controller@aaaa` | `quay.io/jetstack/cert-manager-controller:v9.9.9@aaaa` |

### User Stories (Optional)

<!--
Detail the things that people will be able to do if this proposal gets implemented.
Include as much detail as possible so that people can understand the "how" of
the system. The goal here is to make this feel real for users without getting
bogged down.
-->

#### Story 1

User 1 copies the cert-manager images to their own OCI registry and want to quickly point
the Helm chart to this registry. They can now install cert-manager as follows:
```console
helm install \
  cert-manager jetstack/cert-manager \
  --namespace cert-manager \
  --create-namespace \
  --version v1.17.2 \
  --set crds.enabled=true \
  --set imagePrefix=ghcr.io/my-cert-manager
```

#### Story 2

User 2 overwrites one of the cert-manager images, and wants to not get broken by this Helm chart change:
```console
helm install \
  cert-manager jetstack/cert-manager \
  --namespace cert-manager \
  --create-namespace \
  --version v1.17.2 \
  --set crds.enabled=true \
  --set webhook.image.repository=ghcr.io/my-cert-manager/my-webhook
```

### Risks and Mitigations

Users might be using `image.registry` even though it does not add much benefit currently.
Their options will fail to install cert-manager after upgrading.

It will no longer be possible to install cert-manager with the following options:
```console
helm install \
  cert-manager jetstack/cert-manager \
  --namespace cert-manager \
  --create-namespace \
  --version v1.17.2 \
  --set crds.enabled=true \
  --set webhook.image.registry=ghcr.io
  --set webhook.image.repository=my-cert-manager/my-webhook
...
Error: values don't meet the specifications of the schema(s) in the following chart(s):
cert-manager:
- at '/webhook/image': additional properties 'registry' not allowed
```

### Alternatives

- Keep `image.registry` for backwards compatibility. This will make the Helm templating logic a lot more complex and the Helm chart values.yaml harder to understand.
